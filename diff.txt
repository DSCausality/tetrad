diff --git a/docs/manual/README.md b/docs/manual/README.md
deleted file mode 100644
index 5cdb1911..00000000
--- a/docs/manual/README.md
+++ /dev/null
@@ -1,7 +0,0 @@
-# Tetrad Single-Page HTML Manual
-
-This `/docs/manual` folder is the home of the Tetrad HTML manual. The live version is published via the Github pages. And the live URL is: http://cmu-phil.github.io/tetrad/manual/
-
-## How to Edit
-
-If you are a team member and want to edit this HTML manual, just open the `index.html` with your favorite text editor and search for the corresponding sections to make changes. All the embeded images are stored in the `/images` folder.
\ No newline at end of file
diff --git a/docs/manual/css/normalize.css b/docs/manual/css/normalize.css
deleted file mode 100755
index 3d6624cd..00000000
--- a/docs/manual/css/normalize.css
+++ /dev/null
@@ -1,341 +0,0 @@
-/*! normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css */
-
-/* Document
-   ========================================================================== */
-
-/**
- * 1. Correct the line height in all browsers.
- * 2. Prevent adjustments of font size after orientation changes in iOS.
- */
-
-html {
-  line-height: 1.15; /* 1 */
-  -webkit-text-size-adjust: 100%; /* 2 */
-}
-
-/* Sections
-   ========================================================================== */
-
-/**
- * Remove the margin in all browsers.
- */
-
-body {
-  margin: 0;
-}
-
-/**
- * Correct the font size and margin on `h1` elements within `section` and
- * `article` contexts in Chrome, Firefox, and Safari.
- */
-
-h1 {
-  font-size: 2em;
-  margin: 0.67em 0;
-}
-
-/* Grouping content
-   ========================================================================== */
-
-/**
- * 1. Add the correct box sizing in Firefox.
- * 2. Show the overflow in Edge and IE.
- */
-
-hr {
-  box-sizing: content-box; /* 1 */
-  height: 0; /* 1 */
-  overflow: visible; /* 2 */
-}
-
-/**
- * 1. Correct the inheritance and scaling of font size in all browsers.
- * 2. Correct the odd `em` font sizing in all browsers.
- */
-
-pre {
-  font-family: monospace, monospace; /* 1 */
-  font-size: 1em; /* 2 */
-}
-
-/* Text-level semantics
-   ========================================================================== */
-
-/**
- * Remove the gray background on active links in IE 10.
- */
-
-a {
-  background-color: transparent;
-}
-
-/**
- * 1. Remove the bottom border in Chrome 57-
- * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
- */
-
-abbr[title] {
-  border-bottom: none; /* 1 */
-  text-decoration: underline; /* 2 */
-  text-decoration: underline dotted; /* 2 */
-}
-
-/**
- * Add the correct font weight in Chrome, Edge, and Safari.
- */
-
-b,
-strong {
-  font-weight: bolder;
-}
-
-/**
- * 1. Correct the inheritance and scaling of font size in all browsers.
- * 2. Correct the odd `em` font sizing in all browsers.
- */
-
-code,
-kbd,
-samp {
-  font-family: monospace, monospace; /* 1 */
-  font-size: 1em; /* 2 */
-}
-
-/**
- * Add the correct font size in all browsers.
- */
-
-small {
-  font-size: 80%;
-}
-
-/**
- * Prevent `sub` and `sup` elements from affecting the line height in
- * all browsers.
- */
-
-sub,
-sup {
-  font-size: 75%;
-  line-height: 0;
-  position: relative;
-  vertical-align: baseline;
-}
-
-sub {
-  bottom: -0.25em;
-}
-
-sup {
-  top: -0.5em;
-}
-
-/* Embedded content
-   ========================================================================== */
-
-/**
- * Remove the border on images inside links in IE 10.
- */
-
-img {
-  border-style: none;
-}
-
-/* Forms
-   ========================================================================== */
-
-/**
- * 1. Change the font styles in all browsers.
- * 2. Remove the margin in Firefox and Safari.
- */
-
-button,
-input,
-optgroup,
-select,
-textarea {
-  font-family: inherit; /* 1 */
-  font-size: 100%; /* 1 */
-  line-height: 1.15; /* 1 */
-  margin: 0; /* 2 */
-}
-
-/**
- * Show the overflow in IE.
- * 1. Show the overflow in Edge.
- */
-
-button,
-input { /* 1 */
-  overflow: visible;
-}
-
-/**
- * Remove the inheritance of text transform in Edge, Firefox, and IE.
- * 1. Remove the inheritance of text transform in Firefox.
- */
-
-button,
-select { /* 1 */
-  text-transform: none;
-}
-
-/**
- * Correct the inability to style clickable types in iOS and Safari.
- */
-
-button,
-[type="button"],
-[type="reset"],
-[type="submit"] {
-  -webkit-appearance: button;
-}
-
-/**
- * Remove the inner border and padding in Firefox.
- */
-
-button::-moz-focus-inner,
-[type="button"]::-moz-focus-inner,
-[type="reset"]::-moz-focus-inner,
-[type="submit"]::-moz-focus-inner {
-  border-style: none;
-  padding: 0;
-}
-
-/**
- * Restore the focus styles unset by the previous rule.
- */
-
-button:-moz-focusring,
-[type="button"]:-moz-focusring,
-[type="reset"]:-moz-focusring,
-[type="submit"]:-moz-focusring {
-  outline: 1px dotted ButtonText;
-}
-
-/**
- * Correct the padding in Firefox.
- */
-
-fieldset {
-  padding: 0.35em 0.75em 0.625em;
-}
-
-/**
- * 1. Correct the text wrapping in Edge and IE.
- * 2. Correct the color inheritance from `fieldset` elements in IE.
- * 3. Remove the padding so developers are not caught out when they zero out
- *    `fieldset` elements in all browsers.
- */
-
-legend {
-  box-sizing: border-box; /* 1 */
-  color: inherit; /* 2 */
-  display: table; /* 1 */
-  max-width: 100%; /* 1 */
-  padding: 0; /* 3 */
-  white-space: normal; /* 1 */
-}
-
-/**
- * Add the correct vertical alignment in Chrome, Firefox, and Opera.
- */
-
-progress {
-  vertical-align: baseline;
-}
-
-/**
- * Remove the default vertical scrollbar in IE 10+.
- */
-
-textarea {
-  overflow: auto;
-}
-
-/**
- * 1. Add the correct box sizing in IE 10.
- * 2. Remove the padding in IE 10.
- */
-
-[type="checkbox"],
-[type="radio"] {
-  box-sizing: border-box; /* 1 */
-  padding: 0; /* 2 */
-}
-
-/**
- * Correct the cursor style of increment and decrement buttons in Chrome.
- */
-
-[type="number"]::-webkit-inner-spin-button,
-[type="number"]::-webkit-outer-spin-button {
-  height: auto;
-}
-
-/**
- * 1. Correct the odd appearance in Chrome and Safari.
- * 2. Correct the outline style in Safari.
- */
-
-[type="search"] {
-  -webkit-appearance: textfield; /* 1 */
-  outline-offset: -2px; /* 2 */
-}
-
-/**
- * Remove the inner padding in Chrome and Safari on macOS.
- */
-
-[type="search"]::-webkit-search-decoration {
-  -webkit-appearance: none;
-}
-
-/**
- * 1. Correct the inability to style clickable types in iOS and Safari.
- * 2. Change font properties to `inherit` in Safari.
- */
-
-::-webkit-file-upload-button {
-  -webkit-appearance: button; /* 1 */
-  font: inherit; /* 2 */
-}
-
-/* Interactive
-   ========================================================================== */
-
-/*
- * Add the correct display in Edge, IE 10+, and Firefox.
- */
-
-details {
-  display: block;
-}
-
-/*
- * Add the correct display in all browsers.
- */
-
-summary {
-  display: list-item;
-}
-
-/* Misc
-   ========================================================================== */
-
-/**
- * Add the correct display in IE 10+.
- */
-
-template {
-  display: none;
-}
-
-/**
- * Add the correct display in IE 10.
- */
-
-[hidden] {
-  display: none;
-}
\ No newline at end of file
diff --git a/docs/manual/css/tetrad.css b/docs/manual/css/tetrad.css
deleted file mode 100755
index 4c650824..00000000
--- a/docs/manual/css/tetrad.css
+++ /dev/null
@@ -1,549 +0,0 @@
-
-/*
- * Remove text-shadow in selection highlight: h5bp.com/i
- * These selection rule sets have to be separate.
- * Customize the background color to match your design.
- */
-::-moz-selection {
-background: #b3d4fc;
-text-shadow: none;
-}
-
-::selection {
-background: #b3d4fc;
-text-shadow: none;
-}
-
-/*
- * Remove the gap between images, videos, audio and canvas and the bottom of
- * their containers: h5bp.com/i/440
- */
-audio,
-canvas,
-img,
-svg,
-video {
-vertical-align: middle;
-}
-
-/*
- * Remove default fieldset styles.
- */
-fieldset {
-    border: 0;
-    margin: 0;
-    padding: 0;
-}
-
-/*
- * Allow only vertical resizing of textareas.
- */
-textarea {
-    resize: vertical;
-}
-
-/* Hyperlinks */
-a:link, a:visited {
-color:#3b5998;
-}
-
-/* a:hover MUST come after a:link and a:visited in the CSS definition in order to be effective! */
-a:hover {
-color:#f75342;
-}
-
-/* selected link */
-/* a:active MUST come after a:hover in the CSS definition in order to be effective! */
-a:active {
-color:#f75342;
-}
-
-p {
-line-height:1.6;
-}
-
-h1,
-h2,
-h3,
-h4,
-h5,
-h6{
-line-height: 1.1;
-}
-
-/* Tables
-   ========================================================================== */
-
-/**
- * Remove most spacing between table cells.
- */
-
-table {
-  border-collapse: collapse;
-  border-spacing: 0;
-}
-
-td,
-th {
-  padding: 0;
-}
-
-
-/* Unordered Lists and Ordered Lists */
-/* http://www.w3.org/wiki/Styling_lists_and_links */
-.ul, .ol {
-margin-left: 0;
-padding-left: 0;
-}
-
-.ul li {
-margin-left:1.8em;
-line-height:1.6;
-}
-
-.ol li {
-margin-left:2em;
-line-height:1.6;
-}
-
-/* Description Lists */
-.dl {
-margin:20px 0;
-}
-
-.dl dt{
-font-weight: 700;
-}
-
-.dl dd {
-margin-bottom: 10px;
-margin-left: 0;
-line-height:1.6;
-}
-
-/* 12 or 16 Column Grid Layout  */
-.inner {
-width:940px;
-margin:0 auto;
-padding:0;
-}
-
-.row12, .row16 {
-margin-left: -20px;
-width: 960px; /* Total width 940px  */
-}
-
-.row12:before, .row12:after, .row16:before, .row16:after {
-display: table;
-content: "";
-}
-
-.row12:after, .row16:after {
-clear: both;
-}
-
-/* 12 Column Grid */
-.row12 .span1,
-.row12 .span2,
-.row12 .span3,
-.row12 .span4,
-.row12 .span5,
-.row12 .span6,
-.row12 .span7,
-.row12 .span8,
-.row12 .span9,
-.row12 .span10,
-.row12 .span11,
-.row12 .span12 {
-float: left;
-margin-left: 20px; /*Gutter 20px */
-min-height: 1px; /* In case empty columns collapse horizontally */
-}
-
-/* 12 Column Grid */
-.row12 .span1 {
-width: 60px;
-}
-
-.row12 .span2 {
-width: 140px;
-}
-
-.row12 .span3 {
-width: 220px;
-}
-
-.row12 .span4 {
-width: 300px;
-}
-
-.row12 .span5 {
-width: 380px;
-}
-
-.row12 .span6 {
-width: 460px;
-}
-
-.row12 .span7 {
-width: 540px;
-}
-
-.row12 .span8 {
-width: 620px;
-}
-
-.row12 .span9 {
-width: 700px;
-}
-
-.row12 .span10 {
-width: 780px;
-}
-
-.row12 .span11 {
-width: 860px;
-}
-
-.row12 .span12 {
-width: 940px;
-}
-
-/* 16 Column Grid */
-.row16 .span1,
-.row16 .span2,
-.row16 .span3,
-.row16 .span4,
-.row16 .span5,
-.row16 .span6,
-.row16 .span7,
-.row16 .span8,
-.row16 .span9,
-.row16 .span10,
-.row16 .span11,
-.row16 .span12,
-.row16 .span13,
-.row16 .span14,
-.row16 .span15,
-.row16 .span16 {
-float: left;
-margin-left: 20px; /*Gutter 20px */
-min-height: 1px; /* In case empty columns collapse horizontally */
-}
-
-/* 16 Column Grid */
-.row16 .span1 {
-width: 40px;
-}
-
-.row16 .span2 {
-width: 100px;
-}
-
-.row16 .span3 {
-width: 160px;
-}
-
-.row16 .span4 {
-width: 220px;
-}
-
-.row16 .span5 {
-width: 280px;
-}
-
-.row16 .span6 {
-width: 340px;
-}
-
-.row16 .span7 {
-width: 400px;
-}
-
-.row16 .span8 {
-width: 460px;
-}
-
-.row16 .span9 {
-width: 520px;
-}
-
-.row16 .span10 {
-width: 580px;
-}
-
-.row16 .span11 {
-width: 640px;
-}
-
-.row16 .span12 {
-width: 700px;
-}
-
-.row16 .span13 {
-width: 760px;
-}
-
-.row16 .span14 {
-width: 820px;
-}
-
-.row16 .span15 {
-width: 880px;
-}
-
-.row16 .span16 {
-width: 940px;
-}
-
-
-/* Text Colors */
-.red_tx{
-color:#e27b67 !important;
-}
-
-.orange_tx{
-color:#ff8d5b !important;
-}
-
-.yellow_tx{
-color:#fbdca0 !important;
-}
-
-.green_tx{
-color:#7AC4A0 !important;
-}
-
-.grey_tx{
-color:#d6d6d6 !important;
-}
-
-.blue_tx{
-color:#82ACDE !important;
-}
-
-.purple_tx{
-color:#8763A3 !important;
-}
-
-/* Background Colors */
-.red_bg{
-background-color:#e27b67 !important;
-}
-
-.orange_bg{
-background-color:#ff8d5b !important;
-}
-
-.yellow_bg{
-background-color:#fbdca0 !important;
-}
-
-.green_bg{
-background-color:#7AC4A0 !important;
-}
-
-.grey_bg{
-background-color:#d6d6d6 !important;
-}
-
-.blue_bg{
-background-color:#82ACDE !important;
-}
-
-.purple_bg{
-background-color:#AE87C4 !important;
-}
-
-/* Misc CSS Helper Classes */
-.quote {
-font-family: "Georgia", serif;
-font-size: 17.5px;
-color: #666;
-border-left: 5px solid #859ce6;
-padding-left:20px;
-margin:20px;
-line-height:1.6;
-}
-
-.quote footer {
-display: block;
-font-size: .85em;
-color: #999;
-}
-
-.quote footer:before {
-content: '\2014 \00A0';
-}
-
-/* clearfix hack http://nicolasgallagher.com/micro-clearfix-hack/ */
-.clearfix:before,
-.clearfix:after {
-content: " "; /* 1 */
-display: table; /* 2 */
-}
-
-.clearfix:after {
-clear: both;
-}
-
-.inline_code {
-padding: 2px 4px;
-font-size: 90%;
-color: #DC4945;
-white-space: nowrap;
-background-color: #f9f2f4;
-border-radius: 4px;
-}
-
-/* The <acronym> tag is not supported in HTML5. Use the <abbr> tag instead. */
-.abbr { 
-border-bottom:1px dotted #ff0000; 
-cursor:help;
-}
-
-/* For the <address> tag. */
-.addr {
-margin:10px 0 20px;
-font-style: normal;
-line-height: 1.428571429;
-}
-
-.hide { 
-display: none; 
-}
-
-.float_left {
-float:left;
-}
-
-.float_right {
-float:right;
-}
-
-.align_left {
-text-align:left;
-}
-
-.align_right {
-text-align:right;
-}
-
-.align_center {
-text-align:center;
-}
-
-.line_through{
-text-decoration:line-through;
-}
-
-.external_link {
-background-image:url('images/external_link.png') !important; 
-background-repeat:no-repeat !important;
-background-position: center right !important; 
-padding-right:12px !important;
-}
-
-.card { 
-padding:20px; 
-border:1px solid #ccc; 
-}
-
-/* Table */
-.table {
-width:100%;
-border:1px solid #ccc;
-margin:20px 0;
-}
-
-.table th {
-padding:10px; 
-background:#ebeff9;
-border:1px solid #ccc;
-/* The text in th are bold and centered by default. */
-}
-
-.table td {
-line-height:1.6;
-padding:10px; 
-border:1px solid #ccc;
-}
-
-
-/*--------------------------------------------------------------
-Application-specific Styles
--------------------------------------------------------------- */
-html {
-overflow-y:scroll;
-font-size: 62.5%; /* 16*62.5%=10px */
--webkit-tap-highlight-color: rgba(0, 0, 0, 0);
-}
-
-body {
-font-family:Arial, Helvetica, sans-serif;
-font-size: 14px;
-line-height: 1.428571429;
-color: #333;
-background-color: #ddd;
-}
-
-/* page layout / structure
--------------------------------------------------------------- */
-.inner {
-margin:20px auto;
-padding:40px 40px;
-background-color: #fff;
-}
-
-h1 {
-font-size: 3em;
-margin: 0.67em 0;
-}
-
-h2 {
-font-size: 2.2em;
-margin: 1em 0 0.5em;
-padding-bottom: 9px;
-border-bottom: 1px solid #eee;
-}
-
-
-h3 {
-font-size: 1.4em;
-margin: 0.4em 0;
-}
-
-h4 {
-font-size: 1.2em;
-margin: 0.4em 0;
-}
-
-h5 {
-font-size: 1em;
-margin: 0.4em 0;
-}
-
-.header {
-background:#ddd;
-padding:20px;
-text-align:center;
-}
-
-.toc_container {
-background: #f9f9f9;
-border: 1px solid #aaa;
-display: table;
-padding: 20px;
-margin-top:40px;
-width: auto;
-}
-
-.section_heading {
-border-left: 5px solid #D66061;
-padding-left:10px;
-}
-
-img {
-display:block;
-margin:10px auto;
-}
\ No newline at end of file
diff --git a/docs/manual/images/classify_box_1.png b/docs/manual/images/classify_box_1.png
deleted file mode 100644
index 2a8d56da..00000000
Binary files a/docs/manual/images/classify_box_1.png and /dev/null differ
diff --git a/docs/manual/images/classify_box_2.png b/docs/manual/images/classify_box_2.png
deleted file mode 100644
index 58a78d52..00000000
Binary files a/docs/manual/images/classify_box_2.png and /dev/null differ
diff --git a/docs/manual/images/classify_box_3.png b/docs/manual/images/classify_box_3.png
deleted file mode 100644
index 3cd0b058..00000000
Binary files a/docs/manual/images/classify_box_3.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_1.png b/docs/manual/images/compare_box_1.png
deleted file mode 100644
index edd96686..00000000
Binary files a/docs/manual/images/compare_box_1.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_10.png b/docs/manual/images/compare_box_10.png
deleted file mode 100644
index 78ed1462..00000000
Binary files a/docs/manual/images/compare_box_10.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_2.png b/docs/manual/images/compare_box_2.png
deleted file mode 100644
index c40e8977..00000000
Binary files a/docs/manual/images/compare_box_2.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_3.png b/docs/manual/images/compare_box_3.png
deleted file mode 100644
index bc051fa8..00000000
Binary files a/docs/manual/images/compare_box_3.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_4.png b/docs/manual/images/compare_box_4.png
deleted file mode 100644
index 7c0a6734..00000000
Binary files a/docs/manual/images/compare_box_4.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_5.png b/docs/manual/images/compare_box_5.png
deleted file mode 100644
index bbbc57fd..00000000
Binary files a/docs/manual/images/compare_box_5.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_6.png b/docs/manual/images/compare_box_6.png
deleted file mode 100644
index a4952242..00000000
Binary files a/docs/manual/images/compare_box_6.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_7.png b/docs/manual/images/compare_box_7.png
deleted file mode 100644
index bf0609f6..00000000
Binary files a/docs/manual/images/compare_box_7.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_8.png b/docs/manual/images/compare_box_8.png
deleted file mode 100644
index 3df757b7..00000000
Binary files a/docs/manual/images/compare_box_8.png and /dev/null differ
diff --git a/docs/manual/images/compare_box_9.png b/docs/manual/images/compare_box_9.png
deleted file mode 100644
index 89eaae18..00000000
Binary files a/docs/manual/images/compare_box_9.png and /dev/null differ
diff --git a/docs/manual/images/data_box_1.png b/docs/manual/images/data_box_1.png
deleted file mode 100644
index 66d8f747..00000000
Binary files a/docs/manual/images/data_box_1.png and /dev/null differ
diff --git a/docs/manual/images/data_box_10.png b/docs/manual/images/data_box_10.png
deleted file mode 100644
index 3f6941a0..00000000
Binary files a/docs/manual/images/data_box_10.png and /dev/null differ
diff --git a/docs/manual/images/data_box_2.png b/docs/manual/images/data_box_2.png
deleted file mode 100644
index 5da2488e..00000000
Binary files a/docs/manual/images/data_box_2.png and /dev/null differ
diff --git a/docs/manual/images/data_box_3.png b/docs/manual/images/data_box_3.png
deleted file mode 100644
index f4af66ca..00000000
Binary files a/docs/manual/images/data_box_3.png and /dev/null differ
diff --git a/docs/manual/images/data_box_4.png b/docs/manual/images/data_box_4.png
deleted file mode 100644
index 689ac80c..00000000
Binary files a/docs/manual/images/data_box_4.png and /dev/null differ
diff --git a/docs/manual/images/data_box_5.png b/docs/manual/images/data_box_5.png
deleted file mode 100644
index 4e63782b..00000000
Binary files a/docs/manual/images/data_box_5.png and /dev/null differ
diff --git a/docs/manual/images/data_box_6.png b/docs/manual/images/data_box_6.png
deleted file mode 100644
index 6d4b06eb..00000000
Binary files a/docs/manual/images/data_box_6.png and /dev/null differ
diff --git a/docs/manual/images/data_box_7.png b/docs/manual/images/data_box_7.png
deleted file mode 100644
index 3323f48d..00000000
Binary files a/docs/manual/images/data_box_7.png and /dev/null differ
diff --git a/docs/manual/images/data_box_8.png b/docs/manual/images/data_box_8.png
deleted file mode 100644
index 49648bb9..00000000
Binary files a/docs/manual/images/data_box_8.png and /dev/null differ
diff --git a/docs/manual/images/data_box_9.png b/docs/manual/images/data_box_9.png
deleted file mode 100644
index ad9f08c8..00000000
Binary files a/docs/manual/images/data_box_9.png and /dev/null differ
diff --git a/docs/manual/images/estimator_box_1.png b/docs/manual/images/estimator_box_1.png
deleted file mode 100644
index 4b010190..00000000
Binary files a/docs/manual/images/estimator_box_1.png and /dev/null differ
diff --git a/docs/manual/images/estimator_box_2.png b/docs/manual/images/estimator_box_2.png
deleted file mode 100644
index 47bee133..00000000
Binary files a/docs/manual/images/estimator_box_2.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_1.png b/docs/manual/images/instantiated_model_box_1.png
deleted file mode 100644
index 1e0d5779..00000000
Binary files a/docs/manual/images/instantiated_model_box_1.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_10.png b/docs/manual/images/instantiated_model_box_10.png
deleted file mode 100644
index 03ae2b84..00000000
Binary files a/docs/manual/images/instantiated_model_box_10.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_11.png b/docs/manual/images/instantiated_model_box_11.png
deleted file mode 100644
index e4f24057..00000000
Binary files a/docs/manual/images/instantiated_model_box_11.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_12.png b/docs/manual/images/instantiated_model_box_12.png
deleted file mode 100644
index a2b6b7b0..00000000
Binary files a/docs/manual/images/instantiated_model_box_12.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_13.png b/docs/manual/images/instantiated_model_box_13.png
deleted file mode 100644
index 6dc9594b..00000000
Binary files a/docs/manual/images/instantiated_model_box_13.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_14.png b/docs/manual/images/instantiated_model_box_14.png
deleted file mode 100644
index 286ba7c0..00000000
Binary files a/docs/manual/images/instantiated_model_box_14.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_2.png b/docs/manual/images/instantiated_model_box_2.png
deleted file mode 100644
index a2f8578e..00000000
Binary files a/docs/manual/images/instantiated_model_box_2.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_3.png b/docs/manual/images/instantiated_model_box_3.png
deleted file mode 100644
index 2c352782..00000000
Binary files a/docs/manual/images/instantiated_model_box_3.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_4.png b/docs/manual/images/instantiated_model_box_4.png
deleted file mode 100644
index 6285f20e..00000000
Binary files a/docs/manual/images/instantiated_model_box_4.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_5.png b/docs/manual/images/instantiated_model_box_5.png
deleted file mode 100644
index 754492d2..00000000
Binary files a/docs/manual/images/instantiated_model_box_5.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_6.png b/docs/manual/images/instantiated_model_box_6.png
deleted file mode 100644
index 7b26f11a..00000000
Binary files a/docs/manual/images/instantiated_model_box_6.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_7.png b/docs/manual/images/instantiated_model_box_7.png
deleted file mode 100644
index 518c05ce..00000000
Binary files a/docs/manual/images/instantiated_model_box_7.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_8.png b/docs/manual/images/instantiated_model_box_8.png
deleted file mode 100644
index c33d5c33..00000000
Binary files a/docs/manual/images/instantiated_model_box_8.png and /dev/null differ
diff --git a/docs/manual/images/instantiated_model_box_9.png b/docs/manual/images/instantiated_model_box_9.png
deleted file mode 100644
index 655f167b..00000000
Binary files a/docs/manual/images/instantiated_model_box_9.png and /dev/null differ
diff --git a/docs/manual/images/knowledge_box_1.png b/docs/manual/images/knowledge_box_1.png
deleted file mode 100644
index a13c27d5..00000000
Binary files a/docs/manual/images/knowledge_box_1.png and /dev/null differ
diff --git a/docs/manual/images/knowledge_box_2.png b/docs/manual/images/knowledge_box_2.png
deleted file mode 100644
index f4e3dbdc..00000000
Binary files a/docs/manual/images/knowledge_box_2.png and /dev/null differ
diff --git a/docs/manual/images/knowledge_box_3.png b/docs/manual/images/knowledge_box_3.png
deleted file mode 100644
index a7779e28..00000000
Binary files a/docs/manual/images/knowledge_box_3.png and /dev/null differ
diff --git a/docs/manual/images/knowledge_box_4.png b/docs/manual/images/knowledge_box_4.png
deleted file mode 100644
index b89be699..00000000
Binary files a/docs/manual/images/knowledge_box_4.png and /dev/null differ
diff --git a/docs/manual/images/parametric_model_box_1.png b/docs/manual/images/parametric_model_box_1.png
deleted file mode 100644
index aad8470d..00000000
Binary files a/docs/manual/images/parametric_model_box_1.png and /dev/null differ
diff --git a/docs/manual/images/parametric_model_box_2.png b/docs/manual/images/parametric_model_box_2.png
deleted file mode 100644
index 09adbd78..00000000
Binary files a/docs/manual/images/parametric_model_box_2.png and /dev/null differ
diff --git a/docs/manual/images/parametric_model_box_3.png b/docs/manual/images/parametric_model_box_3.png
deleted file mode 100644
index a02b0fd4..00000000
Binary files a/docs/manual/images/parametric_model_box_3.png and /dev/null differ
diff --git a/docs/manual/images/parametric_model_box_4.png b/docs/manual/images/parametric_model_box_4.png
deleted file mode 100644
index 40ee3382..00000000
Binary files a/docs/manual/images/parametric_model_box_4.png and /dev/null differ
diff --git a/docs/manual/images/parametric_model_box_5.png b/docs/manual/images/parametric_model_box_5.png
deleted file mode 100644
index 5284e149..00000000
Binary files a/docs/manual/images/parametric_model_box_5.png and /dev/null differ
diff --git a/docs/manual/images/parametric_model_box_6.png b/docs/manual/images/parametric_model_box_6.png
deleted file mode 100644
index 37bc6613..00000000
Binary files a/docs/manual/images/parametric_model_box_6.png and /dev/null differ
diff --git a/docs/manual/images/parametric_model_box_7.png b/docs/manual/images/parametric_model_box_7.png
deleted file mode 100644
index b196e5bb..00000000
Binary files a/docs/manual/images/parametric_model_box_7.png and /dev/null differ
diff --git a/docs/manual/images/parametric_model_box_8.png b/docs/manual/images/parametric_model_box_8.png
deleted file mode 100644
index de6737e1..00000000
Binary files a/docs/manual/images/parametric_model_box_8.png and /dev/null differ
diff --git a/docs/manual/images/regression_box_1.png b/docs/manual/images/regression_box_1.png
deleted file mode 100644
index 50844402..00000000
Binary files a/docs/manual/images/regression_box_1.png and /dev/null differ
diff --git a/docs/manual/images/regression_box_2.png b/docs/manual/images/regression_box_2.png
deleted file mode 100644
index 9a838b37..00000000
Binary files a/docs/manual/images/regression_box_2.png and /dev/null differ
diff --git a/docs/manual/images/regression_box_3.png b/docs/manual/images/regression_box_3.png
deleted file mode 100644
index 7fc6fe70..00000000
Binary files a/docs/manual/images/regression_box_3.png and /dev/null differ
diff --git a/docs/manual/images/search_box_1.png b/docs/manual/images/search_box_1.png
deleted file mode 100644
index c9b69f49..00000000
Binary files a/docs/manual/images/search_box_1.png and /dev/null differ
diff --git a/docs/manual/images/simulation_box_1.png b/docs/manual/images/simulation_box_1.png
deleted file mode 100644
index b18a18aa..00000000
Binary files a/docs/manual/images/simulation_box_1.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_1.png b/docs/manual/images/updater_box_1.png
deleted file mode 100644
index 4df1342e..00000000
Binary files a/docs/manual/images/updater_box_1.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_10.png b/docs/manual/images/updater_box_10.png
deleted file mode 100644
index 908214cb..00000000
Binary files a/docs/manual/images/updater_box_10.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_2.png b/docs/manual/images/updater_box_2.png
deleted file mode 100644
index 36474dee..00000000
Binary files a/docs/manual/images/updater_box_2.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_3.png b/docs/manual/images/updater_box_3.png
deleted file mode 100644
index bb352de8..00000000
Binary files a/docs/manual/images/updater_box_3.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_4.png b/docs/manual/images/updater_box_4.png
deleted file mode 100644
index 1f95cfe4..00000000
Binary files a/docs/manual/images/updater_box_4.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_5.png b/docs/manual/images/updater_box_5.png
deleted file mode 100644
index a9a33324..00000000
Binary files a/docs/manual/images/updater_box_5.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_6.png b/docs/manual/images/updater_box_6.png
deleted file mode 100644
index 2015bbb0..00000000
Binary files a/docs/manual/images/updater_box_6.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_7.png b/docs/manual/images/updater_box_7.png
deleted file mode 100644
index 65021710..00000000
Binary files a/docs/manual/images/updater_box_7.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_8.png b/docs/manual/images/updater_box_8.png
deleted file mode 100644
index 12fa1d85..00000000
Binary files a/docs/manual/images/updater_box_8.png and /dev/null differ
diff --git a/docs/manual/images/updater_box_9.png b/docs/manual/images/updater_box_9.png
deleted file mode 100644
index 97c6b0a7..00000000
Binary files a/docs/manual/images/updater_box_9.png and /dev/null differ
diff --git a/docs/manual/index.html b/docs/manual/index.html
deleted file mode 100755
index 0719144d..00000000
--- a/docs/manual/index.html
+++ /dev/null
@@ -1,2427 +0,0 @@
-<!DOCTYPE html>
-<html>
-<head>
-<meta charset="utf-8">
-<meta http-equiv="X-UA-Compatible" content="ie=edge">
-<title>Tetrad Single HTML Manual</title>
-<meta name="description" content="">
-<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
-<link rel="stylesheet" href="css/normalize.css">
-<link rel="stylesheet" href="css/tetrad.css">
-</head>
-<body>
-<!--[if lte IE 9]>
-<p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
-<![endif]-->
-
-<div class="inner">
-
-<div class="header">
-<h1>Tetrad Manual</h1>
-<p>Last updated: March 7th, 2018</p>
-</div>
-
-<!-- Table of Contents, give each section a unique id -->
-<div class="toc_container">
-
-<b>Table of Contents</b>
-<ul class="ul">
-<li><a href="#graph_box">Graph Box</a></li>
-<li><a href="#compare_box">Compare Box</a></li>
-<li><a href="#parametric_model_box">Parametric Model Box</a></li>
-<li><a href="#instantiated_model_box">Instantiated Model Box</a></li>
-<li><a href="#data_box">Data Box</a></li>
-<li><a href="#estimator_box">Estimator Box</a></li>
-<li><a href="#updater_box">Updater Box</a></li>
-<li><a href="#classify_box">Classify Box</a></li>
-<li><a href="#knowledge_box">Knowledge Box</a></li>
-<li><a href="#simulation_box">Simulation Box</a></li>
-<li><a href="#search_box">Search Box</a></li>
-<li><a href="#regression_box">Regression Box</a></li>
-</ul>
-
-</div>
-
-<!-- Assign id with the section name, this will be linked in the table of contents -->
-<h2 id="graph_box"><span  class="section_heading">Graph Box</span></h2>
-
-<p>The graph box can be used to create a new graph, or to copy or edit a graph from another box.</p>
-
-<!-- Follow this example to create a list of items -->
-<h3>Possible Parent Boxes of the Graph Box</h3>
-
-<!-- Assign a class="ul" for pretty look -->
-<ul class="ul">
-<li>Another graph box</li>
-<li>A parametric model box</li>
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>An updater box</li>
-<li>A regression box</li>
-</ul>
-
-<!-- Follow this example to create a list of items -->
-<h3>Possible Child Boxes of the Graph Box</h3>
-
-<!-- Assign a class="ul" for pretty look -->
-<ul class="ul">
-<li>Another graph box</li>
-<li>A compare box</li>
-<li>A parametric model box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>A knowledge box</li>
-</ul>
-
-<h3>Creating a New Graph</h3>
-
-<p>When you first open a graph box with no parent, you will be presented with several options for which kind of graph you would like to create: a directed acyclic graph (DAG), a structural equation model (SEM)graph, a general graph, or a time lag graph. Once you have selected the type of graph you want to create, an empty graph box will open.</p>
-
-<p>You can add variables to your graph by clicking on the variable button on the left, then clicking inside the graph area. Add edges by clicking on an edge type, then clicking and dragging from one variable to another.  Variables may be measured (represented by rectangular icons) or latents (represented by elliptical icons). Edges may be directed, undirected, bidirected, or uncertain (represented by circles at the ends of an edge). Depending on the type of graph you choose to create, your choice of edges may be limited.</p>
-
-<p><i>DAGs</i> allow only directed, bidirected, and uncertain edges. If an edge would create a cycle (or potential cycle, in the case of uncertain edges) it will not be accepted. A graph box containing a DAG can be used as input for any parametric model box, and is the only kind of graph box that can be used as input for a Bayes parametric model.</p>
-
-<p><i>SEM graphs</i> allow only directed and bidirected edges. A graph box containing a SEM graph can be used as input to a SEM parametric model or generalized SEM parametric model, where a bidirected edge between two variables X and Y will be interpreted as X and Y having correlated error terms.</p>
-
-
-<p><i>Time lag graphs</i> allow only directed edges. New variables that you add will be initialized with a single lag. (The number of lags in the graph may be changed under “Edit—Configuration…”) Edges from later lags to earlier lags will not be accepted. Edges added within one lag will automatically be replicated in later lags.</p>
-
-<p>The general <i>graph</i> option allows all edge types and configurations.</p>
-
-
-<h3>Creating a Random Graph </h3>
-
-<p>Instead of manually creating a new graph, you can randomly create one. To do so, open up a new empty graph box and click on “Graph—Random Graph.” This will open up a dialog box from which you can choose the type of random graph you would like to create by clicking through the tabs at the top of the window. Tetrad will randomly generate a DAG, a multiple indicator model (MIM) graph, or a scale-free graph. Each type of graph is associated with a number of parameters (including but not limited to the number of nodes and the maximum degree) which you can set.</p>
-
-<p>Once a graph has been randomly generated, you can directly edit it within the same graph box by adding or removing any variables or edges that that type of graph box allows. So, for instance, although you cannot randomly generate a graph with bidirected edges, you can manually add bidirected edges to a randomly generated DAG in a SEM graph box.</p>
-
-<p>Random graph generation is not available for time lag graphs. </p>
-
-
-<h3>Loading a Saved Graph</h3>
-
-<p>If you have previously saved a graph from Tetrad, you can load it into a new graph box by clicking “File—Load…,” and then clicking on the file type of the saved graph. Tetrad can load graphs from XML, from text, and from JSON files.</p>
-
-<p>To save a graph to file, click “File—Save…,” then click on the file type you would like to save your graph as. Tetrad can save graphs to XML, text, JSON, and R files. (If you save your graph to R, you will not be able to load that file back into Tetrad.)</p>
-
-<p>You can also save an image of your graph by clicking “File—Save Graph Image…” Tetrad cannot load graphs from saved image files.</p>
-
-
-<h3>Copying a Graph</h3>
-
-<p>There are two ways to copy a graph. </p>
-
-<p>The first method allows you to copy a graph from any box which contains one. First, create a new graph box in the workspace, and draw an arrow from the box whose graph you want to copy to the new graph box. When opened, the new graph box will automatically contain a direct copy of the graph its parent box contains. </p>
-
-<p>The second method allows you to copy a graph directly from most types of graph box. First, highlight the graph in the old graph box and click “Edit—Copy Selected Graph.” Then open up your new graph box and click “Edit—Paste Selected Graph.” (Some types of graph box do not have this functionality; see “Manipulating a Graph.”)</p>
-
-
-<h3>Manipulating a Graph</h3>
-
-<p>If you create a graph box as a child of another box, you can also choose to perform a graph manipulation on the parent graph. Your graph box will then contain the manipulated version of the parent graph.</p>
-
-<p>The available graph manipulations are:</p>
-
-<h4>Display Subgraphs</h4>
-
-<p>This option allows you to isolate a subgraph from the parent graph. Add variables to the subgraph by highlighting the variable name in the “Unselected” pane and clicking on the right arrow. The hiighlighted variable will then show up in the “Selected” pane. (You may also define which variables go in the “Selected” pane by clicking on the “Text Input…” button and typing the variable names directly into the window.) Choose the type of subgraph you want to display from the drop-down panel below. Then click “Graph It!” and the resulting subgraph of the selected variables will appear in the pane on the right. (Some types of subgraph, such as “Markov Blanket,” will include unselected variables if they are part of the subgraph as defined on the selected variables. So, for instance, an unselected variable that is in the Markov blanket of a selected variable will appear in the Markov Blanket subgraph. Edges between unselected variables will not be shown.) For large or very dense graphs, it may take a long time to isolate and display subgraphs.</p>
-
-<p>The types of subgraphs that can be displayed are:</p>
-
-<ul class="ul">
-<li>Subgraph (displays the selected nodes and all edges between them)</li>
-<li>Adjacents (displays the selected nodes and all edges between them, as well as nodes 	adjacent to the selected nodes)</li>
-<li>Adjacents of adjacents (displays the selected nodes and all edges between them, as 	well as nodes adjacent to the selected nodes and nodes adjacent to adjacencies of the 	selected nodes)</li>
-<li>Adjacents of adjacents of adjacents (displays the selected nodes and all edges 	between them, as well as nodes adjacent to the selected nodes, nodes adjacent to 	adjacencies of the selected nodes, and nodes adjacent to adjacencies  of adjacencies 	of the selected nodes)</li>
-<li>Markov Blankets (displays the selected nodes and all edges between them, as well 	as the Markov blankets of each selected node)</li>
-<li>Treks (displays the selected nodes, with an edge between each pair if and only if a 	trek exists between them in the full graph)</li>
-<li>Trek Edges (displays the selected nodes, and any treks between them, including 	nodes not in the selected set if they are part of a trek)</li>
-<li>Paths (displays the selected nodes, with an edge between each pair if and only if a 	path exists between them in the full graph)</li>
-<li>Path Edges (displays the selected nodes, and any paths between them, including 	nodes not in the selected set if they are part of a path)</li>
-<li>Directed Paths (displays the selected nodes, with a directed edge between each pair 	if and only if a directed path exists between them in the full graph)</li>
-<li>Directed Path Edges (displays the selected nodes, and any directed paths between 	them, including nodes not in the selected set if they are part of a path)</li>
-<li>Y Structures (displays any Y structures involving  at least two of the selected nodes)</li>
-<li>Indegree (displays the selected nodes and their parents)</li>
-<li>Outdegree (displays the selected nodes and their children)</li>
-<li>Degree (displays the selected nodes and their parents and children)</li>
-</ul>
-
-<p>The “Graph Properties” and “Paths” functions are available in this type of graph box, but they will display information about the full graph, not the currently displayed subgraph. To see graph properties for the subgraph, first copy it into a new graph box.</p>
-
-<h4>Choose DAG in Pattern</h4>
-
-<p>If given a pattern as input, this chooses a random DAG from the Markov equivalence class of the pattern to display. The resulting DAG functions as a normal graph box.</p>
-
-<h4>Choose MAG in PAG</h4>
-
-<p>If given a partial ancestral graph (PAG) as input, this chooses a random mixed ancestral graph (MAG) from the equivalence class of the PAG to display. The resulting MAG functions as a normal graph box.</p>
-
-<h4>Show DAGs in Pattern</h4>
-
-<p>If given a pattern as input, this displays all DAGs in the pattern’s Markov equivalence class. Each DAG is displayed in its own tab. Most graph box functionality is not available in this type of graph box, but the DAG currently on display can be copied by clicking “Copy Selected Graph.”</p>
-
-<h4>Generate Pattern from DAG</h4>
-
-<p>If given a DAG as input, this displays the pattern of the Markov equivalence class to which the parent graph belongs. The resulting pattern functions as a normal graph box.</p>
-
-<h4>Generate PAG from DAG</h4>
-
-<p>Converts an input graph from partial ancestral to directed acyclic format. The resulting DAG functions as a normal graph box.</p>
-
-<h4>Generate PAG from tsDAG</h4>
-
-<p>Converts an input graph from partial ancestral to time series DAG format. The resulting DAG functions as a normal graph box.</p>
-
-<h4>Make Bidirected Edges Undirected</h4>
-
-<p>Replaces all bidirected edges in the input graph with undirected edges.</p>
-
-<h4>Make Undirected Edges Bidirected</h4>
-
-<p>Replaces all undirected edges in the input graph with bidirected edges.</p>
-
-<h4>Make All Edges Undirected</h4>
-
-<p>Replaces all edges in the input graph with undirected edges.</p>
-
-<h4>Generate Complete Graph</h4>
-
-<h4>Extract Structure Model</h4>
-
-
-<h3>Other Graph Box Functions</h3>
-
-<h4>Layout</h4>
-
-<p>You can change the layout of your graph by clicking on the “Layout” tab and choosing between several common layouts. You can also rearrange the layout of one graph box to match the layout of another graph box (so long as the two graphs have identical variables) by clicking “Layout—Copy Layout” and “Layout—Paste Layout.” You do not need to a highlight the graph in order to copy the layout.</p>
-
-<h4>Graph Properties</h4>
-
-<p>Clicking on “Graph—Graph Properties” will give you a text box containing the following properties of your graph:</p>
-
-<ul class="ul">
-<li>Number of nodes</li>
-<li>Number of latent nodes</li>
-<li>Number of edges</li>
-<li>Number of directed edges</li>
-<li>Number of bidirected edges</li>
-<li>Number of undirected edges</li>
-<li>Max degree</li>
-<li>Max indegree</li>
-<li>Max outdegree</li>
-<li>Cyclicity</li>
-</ul>
-
-<h4>Paths</h4>
-
-<p>Clicking on “Graph—Paths” opens a dialog box that allows you to see all the paths between any two variables. You can specify whether you want to see only adjacencies, only directed paths, only semidirected paths, or all treks between the two variables of interest, and the maximum length of the paths you are interested in using drop boxes at the top of the pane. To apply those settings, click “update.”</p>
-
-<h4>Meek Orientation</h4>
-
-<p>Clicking “Meek Orientation” will orient a pattern according to the Meek orientation rules.</p>
-
-<h4>Correlation</h4>
-
-<p>You can automatically correlate or uncorrelated exogenous variables under the Graph tab.</p>
-
-<h4>Highlighting</h4>
-
-<p>You can highlight bidirected edges, undirected edges, and latent nodes under the Graph tab.</p>
-
-
-
-
-<h2 id="compare_box"><span  class="section_heading">Compare Box</span></h2>
-
-<p>The compare box compares two or more graphs.</p>
-
-<h3>Possible Parent Boxes of the Compare box:</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>A regression box</li>
-</ul>
-
-<h3>Possible Child Boxes of the Compare box:</h3>
-
-<ul class="ul">
-<li>None</li>
-</ul>
-
-<h3>Edgewise Comparisons</h3>
-
-<p>An edgewise comparison compares two graphs, and gives a textual list of the edges which must be added to or taken away from one to make it identical to the other.</p>
-
-<p>Take, for example, the following two graphs. The first is the reference graph, the second is the graph to be compared to it. </p>
-
-<!-- Follow this image example to add an image -->
-<img src="images/compare_box_1.png" alt="" width="360">
-
-<img src="images/compare_box_2.png" alt="" width="360">
-
-<p>When these two graphs are input into the graph compare box, a window appears which allows you to specify which of the two graphs is the reference graph. When the comparison is complete, the following window results</p>
-
-<img src="images/compare_box_3.png" alt="" width="450">
-
-
-<p>When the listed changes have been made to the second graph, it will be identical to the first graph.</p>
-
-<p>If one of the parent boxes contains multiple graphs, each graph will be compared separately to the reference graph (or the estimated graph will be compared separately to each reference graph, depending on which parent box is selected as the reference), and each comparison will be housed in its own tab, located on the left side of the window.</p>
-
-<h3>Tabular Graph Comparisons</h3>
-
-<p>A tabular graph comparison tallies up and presents counts of the differences and similarities between a true graph and a reference graph. Consider the example used in the above section; once again, we’ll let graph one be the true graph. Just as above, when the graphs are input to the tabular graph compare box, we must specify which of the graphs is the reference graph, and whether it contains latent variables. When the comparison is complete, the following window results:</p>
-
-<img src="images/compare_box_4.png" alt="" width="650">
-
-
-<p>The first column lists the number of adjacencies in the reference graph that are also in the true graph. The second column lists the number of adjacencies in the reference graph which are not in the compared graph. The third column lists the number of adjacencies in the comparison graph which are not in the reference graph.  The next three columns list analogous information for arrowpoints (orientations of edges).</p>
-
-<p>If one of the parent boxes contains multiple graphs, each graph will be compared separately to the reference graph (or the estimated graph will be compared separately to each reference graph, depending on which parent box is selected as the reference), and the results listed in a separate row of the table.</p>
-
-<h3>Misclassifications</h3>
-
-<p>A misclassification procedure organizes a graph comparison by edge type. The edge types (undirected, directed, uncertain, partially uncertain, bidirected, and null) are listed as the rows and columns of a matrix, with the reference graph edges as the row headers and the estimate graph edges as the column headers. If, for example, there are three pairs of variables that are connected by undirected edges in the reference graph, but are connected by directed edges in the estimated graph, then there will be a 3 in the (undirected, directed) cell of the matrix. An analogous method is used to represent endpoint errors. For example:</p>
-
-<img src="images/compare_box_5.png" alt="" width="650">
-
-<p>If one of the parent boxes contains multiple graphs, then each estimated graph will be individually compared to the reference graph (or vice versa), and the results housed in their own tab, found on the left.</p>
-
-<h3>Graph Intersections</h3>
-
-<p>A graph intersection compares two or more graphs in the same comparison. It does so by ranking adjacencies (edges without regard to direction) and orientations based on how many of the graphs they appear in. In an n-graph comparison, it first lists any adjacencies found in all n graphs. Then it lists all adjacencies found in n – 1 graphs, then adjacencies found in n – 2 graphs, and so on. </p>
-
-<p>After it has listed all adjacencies, it lists any orientations that are not contradicted among the graphs, again in descending order of how many graphs the orientation appears in. An uncontradicted orientation is one on which all graphs either agree or have no opinion. So if the edge X  Y appears in all n graphs, it will be listed first. If the edge X  Z appears in n – 1 graphs, it will be listed next, but only if the nth graph doesn’t contradict it—that is, only if the edge Z  X does not appear in the final graph. If the undirected edge Z – X appears in the final graph, the orientation X  Z is still considered to be uncontradicted.</p>
-
-<p>Finally, any contradicted orientations (orientations that the graphs disagree on) are listed.</p>
-
-<h3>Independence Facts Comparison</h3>
-
-<p>Rather than comparing edges or orientation, this option directly compares the implied dependencies in two graphs. When you initially open the box, you will see the following window:</p>
-
-<img src="images/compare_box_6.png" alt="" width="650">
-
-<p>The drop-down menu allows you to choose which variables you want to check the dependence of. If you select more than two variables, an subsequent variables will be considered members of the conditioning set. So, if you select variables X1, X2, and X3, in that order, the box will determine whether X1 is independent of X2, conditional on X3, in each of the graphs being compared.  When you click “List,” in the bottom right of the window, the results will be displayed in the center of the window: </p>
-
-<img src="images/compare_box_7.png" alt="" width="650">
-
-<h3>Edge Weight Similarity Comparisons</h3>
-
-<p>Edge weight (linear coefficient) similarity comparisons compare two linear SEM instantiated models. The output is a score equal to the sum of the squares of the differences between each corresponding edge weight in each model. Therefore, the lower the score, the more similar the two graphs are. The score has peculiarities: it does not take account of the variances of the variables, and may therefore best be used with standardized models; the complete absence of an edge is scored as 0—so a negative coefficient compares less well with a positive coefficient than does no edge at all.</p>
-
-<p>Consider, for example, an edge weight similarity comparison between the following two SEM IMs:</p>
-
-<img src="images/compare_box_8.png" alt="" width="360">
-
-<img src="images/compare_box_9.png" alt="" width="360">
-
-<p>When they are input into an edge weight similarity comparison, the following window results: </p>
-
-
-<img src="images/compare_box_10.png" alt="" width="450">
-
-<p>This is, unsurprisingly, a high score; the input models have few adjacencies in common, let alone similar parameters.</p>
-
-<h3>Model Fit</h3>
-
-<p>A model fit comparison takes a simulation box and a search box (ideally, a search that has been run on the simulated data in the simulation box), and provides goodness-of-fit statistics for the output graph and the data, as well as estimating the values of any parameters. It looks and functions identically to the estimator box, but unlike the estimator box, it takes the search box directly as a parent, without needing to isolate and parameterize the graph output by the search.</p>
-
-
-
-
-<h2 id="parametric_model_box"><span  class="section_heading">Parametric Model Box</span></h2>
-
-<p>The parametric model box takes a nonparameterized input graph and creates a causal model.</p>
-
-<h3>Possible Parent Boxes of the Parametric Model Box:</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>Another  parametric model box</li>
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>A regression box</li>
-</ul>
-
-
-<h3>Possible Child Boxes of the Parametric Model Box:</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>Another  parametric model box</li>
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>A knowledge box</li>
-</ul>
-
-<h3>Bayes Parametric Models</h3>
-
-<p>A Bayes parametric model takes as input a DAG. Bayes PMs represent causal structures in which all of the variables are categorical.</p>
-
-<p>Bayes PMs consist of three components: the graphical representation of the causal structure of the model; for each named variable, the number of categories which that variable can assume; and the names of the categories associated with each variable.</p>
-
-<p>You may either manually assign categories to the variables or have Tetrad assign them at random. If you choose to manually create a Bayes PM, each variable will initially be assigned two categories, named numerically. If you choose to have Tetrad assign the categories, you can specify a minimum and maximum number of categories possible for any given variable. You can then manually edit the number of categories and category names.</p>
-
-<p>Take, for example, the following DAG:</p>
-
-<img src="images/parametric_model_box_1.png" alt="" width="360">
-
-<p>One possible random Bayes PM that Tetrad might generate from the above DAG, using the default settings, looks like this:</p>
-
-<img src="images/parametric_model_box_2.png" alt="" width="650">
-
-<p>To view the number and names of the categories associated with each variable, you can click on that variable in the graph, or choose it from the drop-down menu on the right. In this graph, X1 and X2 each have three categories, and the rest of the variables have four categories. The categories are named numerically by default.</p>
-
-<p>The number of categories associated with a particular variable can be changed by clicking up or down in the drop-down menu on the right. Names of categories can be changed by overwriting the text already present.</p>
-
-<p>Additionally, several commonly-used preset variable names are provided under the “Presets” tab on the right. If you choose one of these configurations, the number of categories associated with the current variable will automatically be changed to agree with the configuration you have chosen. If you want all of the categories associated with a variable to have the same name with a number appended (e.g., x1, x2, x3), choose the “x1, x2, x3…” option under Presets.</p>
-
-<p>You can also copy category names between variables in the same Bayes PM by clicking on “Transfer—Copy categories” and “Transfer—Paste categories.”</p>
-
-<h3>SEM Parametric Models</h3>
-
-<p>The parametric model of a structural equation model (SEM) will take any type of graph as input, as long as the graph contains only directed and bidirected edges. SEM PMs represent causal structures in which all variables are continuous. </p>
-
-<p>A SEM PM has two components: the graphical causal structure of the model, and a list of parameters used in a set of linear equations that define the causal relationships int the model. Each variable in a SEM PM is a linear function of a subset of the other variables and of an error term drawn from a Normal distribution.</p>
-
-<p>Here is an example of a SEM graph and the SEM PM that Tetrad creates from it:</p>
-
-<img src="images/parametric_model_box_3.png" alt="" width="360">
-
-<img src="images/parametric_model_box_4.png" alt="" width="450">
-
-<p>You can see the error terms in the model by clicking “Parameters—Show Error Terms.” In a SEM model, a bidirected edge indicates that error terms are correlated, so when error terms are visible, the edge between X1 and X2 will instead run between their error terms.</p>
-
-<p>To change a parameter’s name or starting value for estimation, double click on the parameter in the window.</p>
-
-<h3>Generalized SEM Parametric Models</h3>
-
-<p>A generalized SEM parametric model takes as input any type of graph, as long as the graph contains only directed edges. (The generalized SEM PM cannot currently interpret bidirected edges.) Like a SEM PM, it represents causal structures in which all variables are continuous. Also like a SEM PM, a generalized SEM PM contains two components: the graphical causal structure of the model, and a set of equations representing the causal structure of the model. Each variable in a generalized SEM PM is a function of a subset of the other variables and an error term. By default, the functions are linear and the error terms are drawn from a Normal distribution (as in a SEM PM), but the purpose of a generalized SEM PM is to allow editing of these features.</p>
-
-<p>Here is an example of a general graph and the default generalized SEM PM Tetrad creates using it:</p>
-
-<img src="images/parametric_model_box_5.png" alt="" width="360">
-
-<img src="images/parametric_model_box_6.png" alt="" width="650">
-
-
-<p>You can view the error terms by clicking “Tools: Show Error Terms.”
-
-<p>The Variables tab contains a list of the variables and the expressions that define them, and a list of the error terms and the distributions from which their values will be drawn. Values will be drawn independently for each case if the model is instantiated (see IM box) and used to simulate data (see data box).</p>
-
-<p>The Parameters tab contains a list of the parameters and the distributions from which they are drawn. When the model in instantiated in the IM box, a fixed value of each parameter will be selected according to the specified distribution. </p>
-
-<p>To edit an expression or parameter, double click on it (in any tab). This will open up a window allowing you to change the function that defines the variable or distribution of the parameter.</p> 
-
-<p>For instance, if you double click on the expression next to X1 (b1*X5+E_X1), the following window opens:</p>
-
-<img src="images/parametric_model_box_7.png" alt="" width="500">
-
-<p>The drop-down menu at the top of the window lists valid operators and functions. You could, for example, change the expression from linear to quadratic by replacing b1*X5+E_X1 with b1*X5^2+E_X1. You can also form more complicated expressions, using, for instance, exponential or sine functions. If the expression you type is well-formed, it will appear in black text; if it is invalid, it will appear in red text. Tetrad will not accept any invalid changes. </p> 
-
-<p>Parameters are edited in the same way as expressions.</p> 
-
-<p>If you want several expressions or parameters to follow the same non-linear model, you may wish to use the Apply Templates tool. This allows you to edit the expressions or parameters associated with several variables at the same time. To use the Apply Templates tool, click “Tools: Apply Templates….”  This will open the following window:</p> 
-
-<img src="images/parametric_model_box_8.png" alt="" width="500">
-
-<p>You can choose to edit variables, error terms, or parameters by clicking through the “apply to” radio buttons.  If you type a letter or expression into the “starts with” box, the template you create will apply only to variables, error terms, or parameters which begin with that letter for expression. For example, in the given generalized PM, there are two types of parameters: the standard deviations s1-s6 and the edge weights b1-b7. If you click on the “Parameters” radio button and type “b” into the “Starts with” box, only parameters b1-b7 will be affected by the changes you make.</p> 
-
-<p>The “Type Template” box itself works in the same way that the “Type Expression” box works in the “Edit Expression” window, with a few additions. If you scroll through the drop-down menu at the top of the window, you will see the options NEW, TSUM, and TPROD. Adding NEW to a template creates a new parameter for every variable the template is applied to. TSUM means “sum of the values of this variable’s parents,” and TPROD means “product of the values of this variable’s parents.” The contents of the parentheses following TSUM and TPROD indicate any operations which should be performed upon each variable in the sum or product, with the dollar sign ($) functioning as a wild card. For example, in the image above, TSUM(NEW(b)*$) means that, for each parent variable of the variable in question, a new “b” will be created and multiplied by the parent variable’s value, and then all of the products will be added together.</p> 
-
-
-<h2 id="instantiated_model_box"><span  class="section_heading">Instantiated Model Box</span></h2>
-
-<p>The instantiated model (IM) box takes a parametric model and assigns values to the parameters.</p>
-
-<h3>Possible Parent Boxes of the Instantiated Model Box:</h3>
-
-<ul class="ul">
-<li>A parametric model box</li>
-<li>Another instantiated model box</li>
-<li>An estimator box</li>
-<li>A simulation box</li>
-<li>An updater box</li>
-</ul>
-
-<h3>Possible Child Boxes of the Instantiated Model Box:</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A compare box</li>
-<li>A parametric model box</li>
-<li>Another instantiated model box</li>
-<li>An estimator box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>An updater box</li>
-<li>A classify box</li>
-<li>A knowledge box</li>
-</ul>
-
-
-<h3>Bayes Instantiated Models</h3>
-
-<p>A Bayes IM consists of a Bayes parametric model with defined probability values for all variables. This means that, conditional on the values of each of its parent variables, there is a defined probability that a variable will take on each of its possible values. For each assignment of a value to each of the parents of a variable X, the probabilities of the several values of X must sum to 1.</p>
-
-<p>You can manually set the probability values for each variable, or have Tetrad assign them randomly. If you choose to have Tetrad assign probability values, you can manually edit them later. If you wish for Tetrad to randomly reassign probability values each time the box is opened, check “Pick new random values every time this Bayes IM is re-initialized.” then if you destroy the model in the box and create a new one, the box will remember the random values it created.</p>
-
-<p>Here is an example of a Bayes PM and its randomly created instantiated model:</p>
-
-<img src="images/instantiated_model_box_1.png" alt="" width="650">
-
-<img src="images/instantiated_model_box_2.png" alt="" width="650">
-
-<p>In the model above, when X4 and X5 are both 0, the probability that X5 is 0 is 0.0346, that X5 is 1 is 0.4425, and that X5 is 2 is 0.5229. Since X5 must be 0, 1, or 2, those three values must add up to one, as must the values in every row.</p>
-
-<p>To view the probability values of a variable, either double click on the variable in the graph or choose it from the drop-down menu on the right. You can manually set a given probability value by overwriting the text box. Be warned that changing the value in one cell will delete the values in all of the other cells in the row.  Since the values in any row must sum to one, if all of the cells in a row but one are set, Tetrad will automatically change the value in the last cell to make the sum correct. For instance, in the above model, if you change the first row such that the probability that X5 = 0 is 0.5000 and the probability that X5 = 1 is 0.4000, the probability that X5 = 2 will automatically be set to 0.1000.</p>
-
-<p>If you right click on a cell in the table (or two-finger click on Macs), you can choose to randomize the probabilities in the row containing that cell, randomize the values in all incomplete rows in the table, randomize the entire table, or randomize the table of every variable in the model. You can also choose to clear the row or table.</p>
-
-
-<h3>Bayes Instantiated Models: Observed Variables Only</h3>
-
-<p>This box functions in the same way as a Bayes IM box, but represents only measured variables in the model.</p>
-
-<h3>Dirichlet Instantiated Models</h3>
-
-<p>A Dirichlet instantiated model is a specialized form of a Bayes instantiated model. Like a Bayes IM, a Dirichlet IM consists of a Bayes parametric model with defined probability values. Unlike a Bayes IM, these probability values are not manually set or assigned randomly. Instead, the pseudocount is manually set or assigned uniformly, and the probability values are derived from it.  The pseudocount of a given value of a variable is the number of data points for which the variable takes on that value, conditional on the values of the variable’s parents, where these numbers are permitted to take on non-negative real values. Since we are creating models without data, we can set the pseudocount to be any number we want. If you choose to create a Dirichlet IM, a window will open allowing you to either manually set the pseudocounts, or have Tetrad set all the pseudocounts in the model to one number, which you specify.</p>
-
-<p>Here is an example of a Bayes PM and the Dirichlet IM which Tetrad creates from it when all pseudocounts are set to one:</p>
-
-<img src="images/instantiated_model_box_3.png" alt="" width="650">
-
-<img src="images/instantiated_model_box_4.png" alt="" width="650">
-
-<p>In the above model, when X2=0 and X6=0, there is one (pseudo) data point at which X4=0, one at which X4=1, and one at which X4=2. There are three total (pseudo) data points in which X2=0 and X6=0. You can view the pseudocounts of any variable by clicking on it in the graph or choosing it from the drop-down menu at the top of the window. To edit the value of a pseudocount, double click on it and overwrite it. The total count of a row cannot be directly edited.</p>
-
-<p>From the pseudocounts, Tetrad determines the conditional probability of a category. This estimation is done by taking the pseudocount of a category and dividing it by the total count for its row. For instance, the total count of X4 when X2=0 and X6=0 is 3. So the conditional probability of X4=0 given that X2=0 and X6=0 is 1/3. The reasoning behind this is clear: in a third of the data points in which X2 and X6 are both 0, X4 is also 0, so the probability that X4=0 given that X2 and X6 also equal 0 is probably one third.  This also guarantees that the conditional probabilities for any configuration of parent variables add up to one, which is necessary.</p>
-
-<p>To view the table of conditional probabilities for a variable, click the Probabilities tab. In the above model, the Probabilities tab looks like this: </p>
-
-<img src="images/instantiated_model_box_5.png" alt="" width="650">
-
-<h3>SEM Instantiated Models</h3>
-
-<p>A SEM instantiated model is a SEM parametric model in which the parameters and error terms have defined values.  If you choose to create a SEM IM, the following window will open:</p>
-
-<img src="images/instantiated_model_box_6.png" alt="" width="450">
-
-
-<p>Using this box, you can specify the ranges of values from which you want coefficients, covariances, and variances to be drawn for the parameters in the model. In the above box, for example, all linear coefficients will be between -1.5 and -0.5 or 0.5 and 1.5. If you uncheck “symmetric about zero,” they will only be between 0.5 and 1.5.</p>
-
-<p>Here is an example of a SEM PM and a SEM IM generated from it using the default settings: </p>
-
-<img src="images/instantiated_model_box_7.png" alt="" width="360">
-
-<img src="images/instantiated_model_box_8.png" alt="" width="450">
-
-<p>You can now manually edit the values of parameters in one of two ways.  Double clicking on the parameter in the graph will open up a small text box for you to overwrite. Or you can click on the Tabular Editor tab, which will show all of the parameters in a table which you can edit.  The Tabular Editor tab of our SEM IM looks like this:</p>
-
-<img src="images/instantiated_model_box_9.png" alt="" width="450">
-
-<p>In the Tabular Editor tab of a SEM estimator box (which functions similarly to the SEM IM box), the SE, T, and P columns provide statistics showing how robust the estimation of each parameter is. Our SEM IM, however, is in an instantiated model box, so these columns are empty.</p>
-
-<p>The Implied Matrices tab shows matrices of relationships between variables in the model. In the Implied Matrices tab, you can view the covariance or correlation matrix for all variables (including latents) or just measured variables. In our SEM IM, the Implied Matrices tab looks like this:</p>
-
-<img src="images/instantiated_model_box_10.png" alt="" width="450">
-
-<p>You can choose the matrix you wish to view from the drop-down menu at the top of the window. Only half of any matrix is shown, because in a well-formed acyclic model, the matrices should be symmetric.  The cells in the Implied Matrices tab cannot be edited.</p>
-
-<p>In an estimator box, the Model Statistics tab provides goodness of fit statistics for the SEM IM which has been estimated. Our SEM IM, however, is in an instantiated model box, so no estimation has occurred, and the Model Statistics tab is empty.</p>
-
-
-<h3>Standardized SEM Instantiated Models </h3>
-
-<p>A standardized SEM instantiated model consists of a SEM parametric model with defined values for its parameters.  In a standardized SEM IM, each variable (not error terms) has a Normal distribution with 0 mean and unit variance. The input PM to a standardized SEM IM must be acyclic.</p>
-
-<p>Here is an example of an acyclic SEM PM and the standardized SEM IM which Tetrad creates from it</p>
-
-<img src="images/instantiated_model_box_11.png" alt="" width="360">
-
-<img src="images/instantiated_model_box_12.png" alt="" width="450">
-
-
-<p>To edit a parameter, double click on it. A slider will open at the bottom of the window (shown above for the edge parameter between X1 and X2). Click and drag the slider to change the value of the parameter, or enter the specific value you wish into the box. The value must stay within a certain range in order for the Normal distribution to stay standardized, so if you attempt to overwrite the text box on the bottom right with a value outside the listed range, Tetrad will not allow it. In a standardized SEM IM, error terms are not considered parameters and cannot be edited, but you can view them by clicking Parameters: Show Error Terms. </p>
-
-<p>The Implied Matrices tab works in the same way that it does in a normal SEM IM.</p>
-
-
-<h3>Generalized SEM Instantiated Models</h3>
-
-<p>A generalized SEM instantiated model consists of a a generalized SEM parametric model with defined values for its parameters. Since the distributions of the parameters were specified in the SEM PM, Tetrad does not give you the option of specifying these before it creates the instantiated model.</p>
-
-<p>Here is an example of a generalized SEM PM and its generalized SEM IM:</p>
-
-<img src="images/instantiated_model_box_13.png" alt="" width="450">
-
-<img src="images/instantiated_model_box_14.png" alt="" width="450">
-
-<p>Note that the expressions for X6 and X2 are not shown, having been replaced with the words “long formula.” Formulae over a certain length—the default setting is 25 characters—are hidden to improve visibility. Long formulae can be viewed in the Variables tab, which lists all variables and their formulae. You can change the cutoff point for long formulae by clicking Tools: Formula Cutoff.</p>
-
-<p>If you double click on a formula in either the graph or the Variables tab, you can change the value of the parameters in that formula. </p>
-
-
-<h2 id="data_box"><span  class="section_heading">Data Box</span></h2>
-
-<p>The data box stores or manipulates data sets.</p>
-
-<h3>Possible Parent Boxes of the Data Box</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>An estimator box</li>
-<li>Another data box</li>
-<li>A simulation box</li>
-<li>A regression box</li>
-</ul>
-
-
-<h3>Possible Child Boxes of the Data Box</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A parametric model box</li>
-<li>Another data box</li>
-<li>An estimator box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>A classify box</li>
-<li>A regression box</li>
-<li>A knowledge box</li>
-</ul>
-
-<h3>Using the Data Box:</h3>
-
-<p>The data box stores the actual data sets from which causal structures are determined. Data can be loaded into the data box from a preexisting source, manually filled in Tetrad, or simulated from an instantiated model.</p>
-
-<h3>Loading Data</h3>
-
-<p>Data sets loaded into Tetrad may be categorical, continuous, mixed, or covariance data.</p>
-
-<p>Covariance matrices loaded into Tetrad should be ascii text files. The first row contains the sample size, the second row contains the names of the variables. The first two rows are followed by a lower triangular matrix. For example:</p>
-
-<pre>
-1000
-X1	X2	X3	X4	X5	X6 
-1.0000
-0.0312	1.0000
--0.5746	0.4168	1.0000
--0.5996	0.4261	0.9544	1.0000
-0.8691	0.0414	-0.4372	-0.4487	1.0000	
-0.6188	0.0427	-0.1023	-0.0913	0.7172	1.0000
-</pre>
-
-
-<p>Categorical, continuous, or mixed data should also be an ascii text file, with columns representing variables and rows representing cases. Beyond that, there is a great deal of flexibility in the layout: delimiters may be commas, colons, tabs, spaces, semicolons, pipe symbols, or whitespace; comments and missing data may be marked by any symbol you like; there may be a row of variable names or not; and case IDs may be present or not.  There should be no sample size row.  For example:</p>
-
-<pre>
-X1	X2	X3	X4	X5
--3.0133	1.0361	0.2329	2.7829	-0.2878
-0.5542	0.3661	0.2480	1.6881	0.0775
-3.5579	-0.7431	-0.5960	-2.5502	1.5641
--0.0858	1.0400	-0.8255	0.3021	0.2654
--0.9666	-0.5873	-0.6350	-0.1248	1.1684
--1.7821	1.8063	-0.9814	1.8505	-0.7537
--0.8162	-0.6715	0.3339	2.6631	0.9014
--0.3150	-0.5103	-2.2830	-1.2462	-1.2765
--4.1204	2.9980	-0.3609	4.8079	0.6005
-1.4658	-1.4069	1.7234	-1.7129	-3.8298
-</pre>
-
-<p>To load data, create a data box with no parent. When you open it, an empty data window will appear: </p>
-
-<img src="images/data_box_1.png" alt="" width="650">
-
-<p>Click File: Load Data… and select the text file or files that contain your data. The following window will appear:</p>
-
-<p>The text of the source file appears in the Data Preview window. Above, there are options to describe your file, so that Tetrad can load it correctly. If you are loading categorical, continuous, or mixed data values, select the “Tabular Data” button. If you are loading a covariance matrix, select “Covariance Data.” Note that if you are loading a covariance matrix, your text file should contain only the lower half of the matrix, as Tetrad will not accept an entire matrix.</p>
-
-<p>Below the file type, you can specify a number of other details about your file, including information about the type of data (categorical/continuous/mixed), delimiter between data values, variable names, and more. If your data is mixed (some variables categorical, and some continuous), you must specify the maximum number of categories discrete variables in your data can take on. All columns with more than that number of values will be treated as continuous; the others will be treated as categorical. If you do not list the variable names in the file, you should uncheck “First row variable names.” If you provide case IDs, check the box for the appropriate column in the “Case ID column to ignore” area. If the case ID column is labeled, provide the name of the label; otherwise, the case ID column should be the first column, and you should check “First column.”</p>
-
-<p>Below this, you can specify your comment markers, quote characters, and the character which marks missing data values. Tetrad will use that information to distinguish continuous from discrete variables. You may also choose more files to load (or remove files that you do not wish to load) in the “Files” panel on the lower left.</p>
-
-<img src="images/data_box_2.png" alt="" width="650">
-
-<p>When you are satisfied with your description of your data, click “Validate” at the bottom of the window. Tetrad will check that your file is correctly formatted. If it is, you will receive a screen telling you that validation has passed with no error. At this point, you can revisit the settings page, or click “Load” to load the data. </p>
-
-<img src="images/data_box_3.png" alt="" width="650">
-
-<img src="images/data_box_4.png" alt="" width="650">
-
-<p>You can now save this data set to a text file by clicking File: Save Data.</p>
-
-<p>In addition to loading data from a file, you can manually enter data values and variable names by overwriting cells in the data table.</p>
-
-<h3>Manipulating Data</h3>
-
-<p>The data box can also be used to manipulate data sets that have already been loaded or simulated. If you create a data box as the child of another box containing a data set, you will be presented with a list of operations that can be performed on the data. The available data manipulations are:</p>
-
-<h4>Discretize Dataset:</h4>
-
-<p>This operation allows you to make some or all variables in a data set discrete. If you choose it, a window will open. </p>
-
-<img src="images/data_box_5.png" alt="" width="650">
-
-<p>When the window first opens, no variables are selected, and the right side of the window appears blank; in this case, we have already selected X1 ourselves. In order to discretize a variable, Tetrad assigns all data points within a certain range to a category.  You can tell Tetrad to break the range of the dataset into approximately even sections (Evenly Distributed Intervals) or to break the data points themselves into approximately even chunks (Evenly Distributed Values). Use the scrolling menu to increase or decrease the number of categories to create. You can also rename categories by overwriting the text boxes on the left, or change the ranges of the categories by overwriting the text boxes on the right. To discretize another variable, simply select it from the left. If you want your new data set to include the variables you did not discretize, check the box at the bottom of the window.</p>
-
-<p>You may discretize multiple variables at once by selecting multiple variables. In this case, the ranges are not shown, as they will be different from variable to variable.</p>
-
-<h4>Discretize Dataset</h4>
-
-<p><i>Convert Numerical Discrete to Continuous:</i> If you choose this option, any discrete variables with numerical category values will be treated as continuous variables with real values. For example, “1” will be converted to “1.0.”</p>
-
-<h4>Discretize Dataset:</h4>
-
-<p><i>Calculate:</i> The Calculate option allows you to add and edit relationships between variables in your data set, and to add new variables to the data set. </p>
-
-
-<img src="images/data_box_6.png" alt="" width="650">
-
-<p>In many ways, this tool works like the Edit Expression window in a generalized SEM parametric model. To edit the formula that defines a variable (which will change that variable’s values in the table) type that variable name into the text box to the left of the equals sign. To create a new variable, type a name for that variable into the text box to the left of the equals sign. Then, in the box on the right, write the formula by which you wish to define a new variable in place of, or in addition to, the old variable. You can select functions from the scrolling menu below. (For an explanation of the meaning of some the functions, see the section on generalized SEM models in the Parametric Model Box chapter.) To edit or create several formulae at once, click the “Add Expression” button, and another blank formula will appear. To delete a formula, check the box next to it and click the “Remove Selected Expressions” button.</p>
-
-<p>When you click “Save” a table will appear listing the data. Values of variables whose formulae you changed will be changed, and any new variables you created will appear with defined values.</p>
-
-<h4>Merge Datasets</h4>
-
-<p>This operation takes two or more data boxes as parents and creates a data box containing all data sets in the parent boxes. Individual data sets will be contained in their own tabs in the resulting box.</p>
-
-<h4>Convert to Correlation Matrix</h4>
-
-<p>This operation takes a tabular data set and outputs the lower half of the correlation matrix of that data set.</p>
-
-<h4>Convert to Covariance Matrix</h4>
-
-<p>This operation takes a tabular data set and outputs the lower half of the covariance matrix of that data set.</p>
-
-<h4>Inverse Matrix</h4>
-
-<p>This operation takes a covariance or correlation matrix and outputs its inverse. (Note: The output will not be acceptable in Tetrad as a covariance or correlation matrix, as it is not lower triangular.)</p>
-
-<h4>Simulate Tabular from Covariance</h4>
-
-<p>This operation takes a covariance matrix and outputs a tabular data set whose covariances comply with the matrix.</p>
-
-<h4>Difference of Covariance Matrices</h4>
-
-<p>This operation takes two covariance matrices and outputs their difference. The resulting matrix will be a well-formatted Tetrad covariance matrix data set.</p>
-
-<h4>Sum of Covariance Matrices</h4>
-
-<p>This operation takes two covariance matrices and outputs their sum. The resulting matrix will be a well-formatted Tetrad covariance matrix data set.</p>
-
-<h4>Average of Covariance Matrices</h4>
-
-<p>This operation takes two or more covariance matrices and outputs their average. The resulting matrix will be a well-formatted Tetrad covariance matrix data set.</p>
-
-<h4>Convert to Time Lag Data</h4>
-
-<p>This operation takes a tabular data set and outputs a time lag data set, in which each variable is recorded several times over the course of an experiment. You can specify the number of lags in the data. Each contains the same data, shifted by one “time unit.” For instance, if the original data set had 1000 cases, and you specify that the time lag data set should contain two lags, then the third stage variable values will be those of cases 1 to 998, the second stage variable values will be those of cases 2 to 999, and the first stage variable values will be those of cases 3 to 1000.</p>
-
-<h4>Convert to Time Lag Data with Index</h4>
-
-<p>This operation takes a tabular data set and outputs a time lag data set in the same manner as “Convert to Time Lag Data,” then adds an index variable.</p>
-
-<h4>Convert to AR Residuals</h4>
-
-<p>This operation is performed on a time lag data set. Tetrad performs a linear regression on each variable in each lag with respect to each of the variables in the previous lag, and derives the error terms.  The output data set contains only the error terms.</p>
-
-<h4>Whiten</h4>
-
-<p>Takes a continuous tabular data set and converts it to a data set whose covariance matrix is the identity matrix.</p>
-
-<h4>Nonparanormal Transform</h4>
-
-<p>Takes a continuous tabular data set and increases its Gaussianity, using a nonparanormal transformation to smooth the variables. (Note: This operation increases only marginal Gaussanity, not the joint, and in linear systems may eliminate information about higher moments that can aid in non-Gaussian orientation procedures.) </p>
-
-<h4>Convert to Residuals</h4>
-
-<p>The input for this operation is a directed acyclic graph (DAG) and a data set. Tetrad performs a linear regression on each variable in the data set with respect to all of the variables that the graph shows to be its parents, and derives the error terms. The output data set contains only the error terms.</p>
-
-<h4>Standardize Data</h4>
-
-<p>This operation manipulates the data in your data set such that each variable has 0 mean and unit variance.</p>
-
-<h4>Remove Cases with Missing Values</h4>
-
-<p>If you choose this operation, Tetrad will remove any row in which one or more of the values is missing.</p>
-
-<h4>Replace Missing Values with Column Mode</h4>
-
-<p>If you choose this operation, Tetrad will replace any missing value markers with the most commonly used value in the column.</p>
-
-<h4>Replace Missing Values with Column Mean</h4>
-
-<p>If you choose this operation, Tetrad will replace any missing value markers with the average of all of the values in the column.
-Replace Missing Values with Regression Predictions: If you choose this operation, Tetrad will perform a linear regression on the data in order to estimate the most likely value of any missing value.</p>
-
-<h4>Replace Missing Values by Extra Category</h4>
-
-<p>This operation takes as input a discrete data set. For every variable which has missing values, Tetrad will create an extra category for that variable (named by default “Missing”) and replace any missing data markers with that category.</p>
-
-<h4>Replace Missing with Random</h4>
-
-<p>For discrete data, replaces missing values at random from the list of categories the variable takes in other cases. For continuous data, finds the minimum and maximum values of the column (ignoring the missing values) and picks a random number from U(min, max)</p>
-
-<h4>Inject Missing Data Randomly</h4>
-
-<p>If you choose this operation, Tetrad will replace randomly selected data values with a missing data marker.  You can set the probability with which any particular value will be replaced (that is, approximately the percentage of values for each variable which will be replaced with missing data markers).</p>
-
-<h4>Bootstrap Sample</h4>
-
-<p>This operation draws a random subset of the input data set (you specify the size of the subset) with replacement (that is, cases which appear once in the original data set can appear multiple times in the subset). The resulting data set can be used along with similar subsets to achieve more accurate estimates of parameters.</p>
-
-<h4>Split by Cases</h4>
-
-<p>This operation allows you to split a data set into several smaller data sets. When you choose it, a window opens. </p>
-
-<img src="images/data_box_7.png" alt="" width="360">
-
-
-<p>If you would like the subsets to retain the ordering they had in the original set, click “Original Order.” Otherwise, the ordering of the subsets will be assigned at random. You can also increase and decrease the number of subsets created, and specify the range of each subset.</p>
-
-<h4>Permute Rows</h4>
-
-<p>This operation randomly reassigns the ordering of a data set’s cases.</p>
-
-<h4>First Differences</h4>
-
-<p>This operation takes a tabular data set and outputs the first differences of the data (i.e., if X is a variable in the original data set and X’ is its equivalent in the first differences data set, X’1 = X2 – X1). The resulting data set will have one fewer row than the original.</p>
-
-<h4>Concatenate Datasets</h4>
-
-<p>This operation takes two or more datasets and concatenates. The parent datasets must have the same number of variables.</p>
-
-<h4>Copy Continuous Variables</h4>
-
-<p>This operation takes as input a data set and creates a new data set containing only the continuous variables present in the original.</p>
-
-<h4>Copy Discrete Variables</h4>
-
-<p>This operation takes as input a data set and creates a new data set containing only the discrete variables present in the original.</p>
-
-<h4>Remove Selected Variables</h4>
-
-<h4>Copy Selected Variables</h4>
-
-<p>As explained above, you can select an entire column in a data set by clicking on the C1, C2, C3, etc… cell above the column. To select multiple columns, press and hold the “control” key while clicking on the cells. Once you have done so, you can use the Copy Selected Variables tool to create a data set in which only those columns appear.</p>
-
-<h4>Remove Constant Columns</h4>
-
-<p>This operation takes a data set as input, and creates a data set which contains all columns in the original data set except for those with constant values (such as, for example, a column containing nothing but 2’s).</p>
-
-<h4>Randomly Reorder Columns</h4>
-
-<p>This operation randomly reassigns the ordering of a data set’s variables.</p>
-
-<h3>Manually Editing Data</h3>
-
-<p>Under the Edit tab, there are several options to manipulate data. If you select a number of cells and click “Clear Cells,” Tetrad will replace the data values in the selected cells with a missing data marker.  If you select an entire row or column and click “Delete selected rows or columns,” Tetrad will delete all data values in the row or column, and the name of the row or column. (To select an entire column, click on the category number above it, labeled C1, C2, C3, and so on.  To select an entire row, click on the row number to the left of it, labeled 1, 2, 3, and so on.) You can also copy, cut, and paste data values to and from selected cells. You can choose to show or hide category names, and if you click on “Set Constants Col to Missing,” then in any column in which the variable takes on only one value (for example, a column in which every cell contains the number 2) Tetrad will set every cell to the missing data marker.</p>
-
-<p>Under the Tools tab, the Calculator tool allows you add and edit relationships between variables in the graph. For more information on how the Calculator tool works, see “Manipulating Data” section above.</p>
-
-<h3>Data Information</h3>
-
-<p>Under the Tools tab, there are options to view information about your data in several different formats.</p>
-
-<p>The Histograms tool shows histograms of the variables in the data set.</p>
-
-
-<img src="images/data_box_8.png" alt="" width="650">
-
-
-<p>These show the distribution of data for each variable, with the width of each bar representing a range of values, and height of each bar representing how many data points fall into that range. Using histograms, you can determine whether each variable has a distribution that is approximately Normal. To select a variable to view, choose it from the drop-down menu on the right.  You can increase or decrease the number of bars in the histogram (and therefore decrease or increase the range of each bar, and increase or decrease the accuracy of the histogram) using the menu on the right. You can also view only ranges with a certain amount of the data using the “cull bins” menu.</p>
-
-<p>The Scatter Plots tool allows you to view scatter plots of two variables plotted against each other.</p>
-
-<img src="images/data_box_9.png" alt="" width="650">
-
-<p>To view a variable as the x- or y-axis of the graph, select it from one the drop-down menus to the right.  To view the regression line of the graph, check the box on the right.</p>
-
-<p>You can see the correlation of two variables conditional on a third variable by using the Add New Conditional Variable button at the bottom of the window. This will open up a slider and a box in which you can set the granularity of the slider. By moving the slider to the left or right, you can change the range of values of the conditional variable for which the scatter plot shows the correlation of the variables on the x- and y- axes. You can increase and decrease the width of the ranges by changing the granularity of the slider. A slider with granularity 1 will break the values of the conditional variable into sections one unit long, etc. The granularity cannot be set lower than one.</p>
-
-<p>In a well-formed model, the scatter plot of a variable plotted against itself should appear as a straight line along the line y = x.</p>
-
-<p>The alpha-alpha Plot tool is a test for normality of distribution. </p>
-
-<img src="images/data_box_10.png" alt="" width="650">
-
-<p>If a variable has a distribution which is approximately Normal, its alpha-alpha plot should appear as a straight line with a positive slope. You can select the variable whose alpha-alpha plot you wish to view from the drop-down menu on the right.</p>
-
-<p>The Normality Tests tool gives a text box with the results of the Kolmogorov and Anderson Darling Tests for normality for each variable. The Descriptive Statistics tool gives a text box with statistical information such as the mean, median, and variance of each variable.</p>
-
-
-<h2 id="estimator_box"><span  class="section_heading">Estimator Box</span></h2>
-
-<p>The estimator box takes as input a data box (or simulation box) and a parametric model box and estimates, tests, and outputs an instantiated model for the data. With the exception of the EM Bayes estimator, Tetrad estimators do not accept missing values. If your data set contains missing values, the missing values can interpolated or removed using the data box. (Note that missing values are allowed in various Tetrad search procedures; see the section on the search box.)</p>
-
-<h3>Possible Parent Boxes of the Estimator Box:</h3>
-
-<ul class="ul">
-<li>A parametric model box</li>
-<li>An instantiated model box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-</ul>
-
-
-<h3>Possible Child Boxes of the Estimator Box:</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A compare box</li>
-<li>A parametric model box</li>
-<li>An instantiated model box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>An updater box</li>
-</ul>
-
-<h3>ML Bayes Estimations</h3>
-
-<p>Bayes nets are acyclic graphical models parameterized by the conditional probability distribution of each variable on its parents’ values, as in the instantiated model box. When the model contains no latent variables, the maximum likelihood (ML) estimate of each model parameter is just the corresponding conditional frequency from the data. </p>
-
-<p>The ML Bayes estimator, because it estimates Bayes IMs, works only on models with discrete variables. The model estimated must not include latent variables, and the input data set must not include missing data values.  A sample estimate looks like this:</p>
-
-<img src="images/estimator_box_1.png" alt="" width="650">
-
-<p>The Model tab works exactly as it does in a Bayes instantiated model. The Model Statistics tab provides the p-value for a chi square test of the model, degrees of freedom, the chi square value, and the Bayes Information Criterion (BIC) score of the model.</p>
-
-<h3>Dirichlet Estimations</h3>
-
-<p>A Dirichlet estimate estimates a Bayes instantiated model using a Dirichlet distribution for each category. In a Dirichlet estimate, the probability of each value of a variable (conditional on the values of the variable’s parents) is estimated by adding together a prior pseudo count (which is 1, by default) of cases and the number of cases in which the variable takes that value in the data, and then dividing by the total number of cases in the prior and in the data with that configuration of parent variables. The default prior pseudo-count can be changed inside the box. (For a full explanation of pseudocounts and Dirichlet estimate, see the section on Dirichlet instantiated models.) </p>
-
-<p>Dirichlet estimates do not work if the input data set contains missing data values.</p>
-
-<h3>EM Bayes Estimations</h3>
-
-<p>The EM Bayes estimator takes the same input and gives the same output as the ML Bayes estimator, but is designed to handle data sets with missing data values, and input models with latent variables.</p>
-
-<h3>SEM Estimates</h3>
-
-<p>A SEM estimator estimates the values of parameters for a SEM parametric model. SEM estimates do not work if the input data set contains missing data values. A sample output looks like this: </p>
-
-<img src="images/estimator_box_2.png" alt="" width="650">
-
-<p>Tetrad provides five parameter optimizers: RICF, expectation-maximization (EM), regression, Powell and random search. Accurate regression estimates assume that the input parametric model is a DAG, and that its associated statistics are based on a linear, Gaussian model. The EM optimizer has the same input constraints as regression, but can handle latent variables. </p>
-
-<p>Tetrad also provides two scores that can be used in estimation: feasible generalized least squares (FGLS) and Full Information Maximum Likelihood (FML). </p>
-
-<p>If the graph for the SEM is a DAG, and we may assume that the SEM is linear with Gaussian error terms, we use multilinear regression to estimate coefficients and residual variances. Otherwise, we use a standard maximum likelihoood fitting function (see Bollen, Structural Equations with Latent Variables, Wiley, 1989, pg. 107) to minimize the distance between (a) the covariance over the variables as implied by the coefficient and error covariance parameter values of the model and (b) the sample covariance matrix. Following Bollen, we denote this function Fml; it maps points in parameter values space to real numbers, and, when minimized, yields the maximum likelihood estimation point in parameter space.</p>
-
-<p>In either case, an Fml value may be obtained for the maximum likelihood point in parameter space, either by regression or by direct minimization of the Fml function itself. The value of Fml at this minimum (maximum likelihood) point, multiplied by N - 1 (where N is the sample size), yields a chi square statistics (ch^2) for the model, which when referred to the chi square table with appropriate degrees of freedom, yields a model p value. The degrees of freedom (dof) in this case is equal to the m(m-1)/2 - f, where m is the number of measured variables, and f is the number of free parameters, equal to the number of coefficient parameters plus the number of covariance parameters. (Note that the degrees of freedom many be negative, in which case estimation should not be done.) The BIC score is calculated as ch^2 - dof * log(N).</p>
-
-<p>You can change which score optimizer Tetrad uses by choosing them from the drop-down menus at the bottom of the window and clicking “Estimate Again.”</p>
-
-<p>The Tabular Editor and Implied Matrices tabs function exactly as they do in the instantiated model box, but in the estimator box, the last three columns of the table in the Tabular Editor tab are filled in. The SE, T, and P columns provide the standard errors, t statistics, and p values of the estimation.</p>
-
-<p>The Model Statistics tab provides the degrees of freedom, chi square, p value, comparative fit index (CFI), root mean square error of approximation (RMSEA) and BIC score of a test of the model. It should be noted that while these test statistics are standard, they are not in general correct.  See Mathias Drton, 2009, Likelihood ratio tests and singularities. Annals of Statistics 37(2):979-1012. arXiv:math.ST/0703360. </p>
-
-
-
-<h2 id="updater_box"><span  class="section_heading">Updater Box</span></h2>
-
-<p>The updater box takes an instantiated model as input, and, given information about the values of parameters in that model, updates the information about the values and relationships of other parameters.</p>
-
-<p>There are four available updater algorithms in Tetrad: the approximate updater, the row summing exact updater, the CPT invariant updater, and the SEM updater. All except for the SEM updater function only when given Bayes instantiated models as input; the SEM updater functions when given a SEM instantiated model as input. None of the updaters work on cyclic models.</p>
-
-<h3>Possible Parent Boxes of the Updater Box:</h3>
-
-<ul class="ul">
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-</ul>
-
-
-<h3>Possible Child Boxes of the Updater Box:</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-</ul>
-
-<h3>Approximate Updater</h3>
-
-<p>The approximated updater is a fast but inexact algorithm. It randomly draws a sample data set from the instantiated model and calculates the conditional frequency of the variable to be estimated.</p>
-
-<p>Take, for example, the following instantiated model: </p>
-
-<img src="images/updater_box_1.png" alt="" width="650">
-
-<p>When it is input into the approximate updater, the following window results:</p>
-
-<img src="images/updater_box_2.png" alt="" width="650">
-
-<p>If we click “Do Update Now” now, without giving the updater any evidence, the right side of the screen changes to show us the marginal probabilities of the variables.</p>
-
-<img src="images/updater_box_3.png" alt="" width="360">
-
-<p>The blue lines, and the values listed across from them, indicate the probability that the variable takes on the given value in the input instantiated model. The red lines indicate the probability that the variable takes on the given value, given the evidence we’ve added to the updater. </p>
-
-<p>Since we have added no evidence to the updater, the red and blue lines are very similar in length. To view the marginal probabilities for a variable, either click on the variable in the graph to the left, or choose it from the scrolling menu at the top of the window. At the moment, they should all be very close to the marginal probabilities taken from the instantiated model.</p>
-
-<p>Now, we’ll return to the original window. We can do so by clicking “Edit Evidence” under the Evidence tab. Suppose we know that X1 takes on the value 1 in our model, or suppose we merely want to see how X1 taking that value affects the values of the other variables. We can click on the box that says “1” next to X1.  When we click “Do Update Now,” we again get a list of the marginal probabilities for X1.</p>
-
-<img src="images/updater_box_4.png" alt="" width="360">
-
-<p>Now that we have added evidence, the “red line” marginal probabilities have changed; for X1, the probability that X1=1 is 1, because we’ve told Tetrad that that is the case. Likewise, the probabilities that X1=0 and X1=2 are both 0.</p>
-
-<p>Now, let’s look at the updated marginal probabilities for X2, a parent of X1.</p>
-
-<img src="images/updater_box_5.png" alt="" width="360">
-
-<img src="images/updater_box_6.png" alt="" width="360">
-
-<p>The image on the left is the marginal probabilities before we added the evidence that X1=1. The image on the right is the updated marginal probabilities. They have changed; in particular, it has become much more likely that X2=0.</p>
-
-<p>Under the Mode tab, we can change the type of information that the updater box gives us. The mode we have been using so far is “Marginals Only (Multiple Variables).” We can switch the mode to “In-Depth Information (Single Variable).” Under this mode, when we perform the update, we receive more information (such as log odds and joints, when supported; joint probabilities are not supported by the approximate updater), but only about the variable which was selected in the graph when we performed the update. To view information about a different variable, we must re-edit the evidence with that variable selected.</p>
-
-<p>If the variable can take one of several values, or if we know the values of more than one variable, we can select multiple values by pressing and holding the Shift key and then making our selections. For instance, in the model above, suppose that we know that X1 can be 1 or 2, but not 0. We can hold the Shift key and select the boxes for 1 and 2, and when we click “Do Update Now,” the marginal probabilities for X2 look like this: </p>
-
-<img src="images/updater_box_7.png" alt="" width="650">
-
-<p>Since X1 must be 1 or 2, the updated probability that it is 0 is now 0. The marginal probabilities of X2 also change: </p>
-
-<img src="images/updater_box_8.png" alt="" width="650">
-
-<p>The updated marginal probabilities are much closer to their original values than they were when we knew that X1 was 1.</p>
-
-<p>Finally, if we are arbitrarily setting the value of a variable—that is, the values of its parents have no effect on its value—we can check the “Manipulated” box next to it while we are we editing evidence, and the update will reflect this information.</p>
-
-<h3>Row Summing Exact Updater</h3>
-
-<p>The row summing exact updater is a slower but more accurate updater than the approximate updater. The complexity of the algorithm depends on the number of variables and the number of categories each variable has. It creates a full exact conditional probability table and updates from that. Its window functions exactly as the approximate updater does, with two exceptions: in “Multiple Variables” mode, you can see conditional as well as marginal probabilities, and in “Single Variable” mode, you can see joint values. </p>
-
-<h3>CPT Invariant Exact Updater</h3>
-
-<p>The CPT invariant exact updater is more accurate than the approximate updater, but slightly faster than the row summing exact updater. Ifs window functions exactly as the approximate updater down, with one exception: in “Multiple Variables” mode, you can see conditional as well as marginal probabilities.</p>
-
-<h3>SEM Updater</h3>
-
-<p>The SEM updater does not deal with marginal probabilities; instead, it deals with means.</p>
-
-
-<img src="images/updater_box_9.png" alt="" width="360">
-
-<p>When it is input to the SEM updater, the following window results: </p>
-
-<img src="images/updater_box_10.png" alt="" width="650">
-
-<p>Suppose we know that the mean of X1 is .5. When we enter that value into the text box on the left and click “Do Update Now,” the model on the right updates to reflect that mean, changing the means of both X1 and several other variables. In the new model, the means of X2, X4, and X5 will all have changed. If we click the “Manipulated” check box as well, it means that we have arbitrarily set the mean of X1 to .5, and that the value of its parent variable, X4, has no effect on it. The graph, as well as the updated means, changes to reflect this.</p>
-
-<p>The rest of the window has the same functionality as a SEM instantiated model window.</p>
-
-
-
-<h2 id="classify_box"><span  class="section_heading">Classify Box</span></h2>
-
-<p>The classify box takes as input a categorical data set and a Bayes instantiated model and, for a given variable, tries to predict that variable’s value in each case based on the other variables’ values in that case.</p>
-
-<h3>Possible Parents Boxes of the Classify Box: </h3>
-
-<ul class="ul">
-<li>An instantiated model box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-</ul>
-
-<h3>Possible Child Boxes of the Classify Box: </h3>
-
-<ul class="ul">
-<li>None</li>
-</ul>
-
-
-<h3>Using the Classify Box:</h3>
-
-<p>Consider the following instantiated model, and a data set derived from it:</p>
-
-<img src="images/classify_box_1.png" alt="" width="650">
-
-<p>When they are input to the classify box, the following window results: </p>
-
-<img src="images/classify_box_2.png" alt="" width="650">
-
-<p>By clicking on the “Test Data” tab, we can see the data set which we input. Now, suppose we want to predict the values of X1 in each case. We select X1 from the scrolling menu at the top and click “Classify.” Three new tabs now appear: “Classification,” “ROC Plot,” and “Confusion Matrix.”  The classification tab, in this case, looks like this: </p>
-
-<img src="images/classify_box_3.png" alt="" width="650">
-
-
-<p>There is a column for each of the possible values which X1 can take, and for each case, Tetrad has computed the probability that X1 will take each value, based on the configuration of other variables in that case. It then chooses the category with the highest conditional probability, and assigns X1 that value for that case. Comparison to the test data will show that the values are reasonably (though not completely) similar.</p>
-
-<p>The ROC plot tab displays the receiver operating characteristic (ROC) curve for whichever value you specified before classification.</p>
-
-<p>The confusion matrix tab provides information on how similar the estimated values of the target variable are to the true values (if the true values are available). </p> 
-
-<p>Because classification is a form of estimation, the variable which is classified does not have to be in the input data set; it merely has to be in the input instantiated model. In this case, the ROC plot and confusion matrix tabs will not appear.</p>
-
-
-
-<h2 id="knowledge_box"><span  class="section_heading">Knowledge Box</span></h2>
-
-<p>The knowledge box takes as input a graph or a data set and imposes additional constraints onto it, to aid with search.</p>
-
-<h3>Possible Parent Boxes of the Knowledge Box:</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A parametric model box</li>
-<li>An instantiated model box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-<li>Another knowledge box</li>
-</ul>
-
-<h3>Possible Child Boxes of the Knowledge Box:</h3>
-
-<ul class="ul">
-<li>A search box</li>
-<li>Another knowledge box</li>
-</ul>
-
-<h3>Tiers and Edges</h3>
-
-<p>The tiers and edges option allows you to sort variables into groupings that can or cannot affect each other. It also allows you to manually add forbidden and required edges one at a time.</p>
-
-<h4>Tiers</h4>
-
-<p>The tiers tab for a graph with four variables looks like this: </p>
-
-<img src="images/knowledge_box_1.png" alt="" width="650">
-
-<p>Tiers separate your variables into a time line. Variables in higher-numbered tiers occur later than variables in lower-numbered tiers, which gives Tetrad information about causation. For example, a variable in Tier 3 could not possibly be a cause of a variable in Tier 1.</p>
-
-<p>To place a variable in a tier, click on the variable in the “Not in tier” box, and then click on the box of the tier. If you check the “Forbid Within Tier” box for a tier, variables in that tier will not be allowed to be causes of each other. To increase or decrease the number of tiers, use the scrolling box in the upper right corner of the window.</p>
-
-<h4>Groups</h4>
-
-<p>The groups tab for a graph with four variables looks like this: </p>
-
-<img src="images/knowledge_box_2.png" alt="" width="650">
-
-<p>In the groups tab, you can specify certain groups of variables which are forbidden or required to cause other groups of variables. To add a variable to the “cause” section of a group, click on the variable in the box at the top, and then click on the box to the left of the group’s arrow. To add a variable to the “effect” section of a group, click on the variable in the box at the top, and then click on the box to the right of the group’s arrow. You can add a group by clicking on one of the buttons at the top of the window, and remove one by clicking the “remove” button above the group’s boxes.</p>
-
-<h4>Edges</h4>
-
-<p>The edges tab for a graph with four variables looks like this: </p>
-
-<img src="images/knowledge_box_3.png" alt="" width="650">
-
-<p>In the edges tab, you can require or forbid individual causal edges between variables. To add an edge, click the type of edge you’d like to create, and then click and drag from the “cause” variable to the “effect” variable.</p>
-
-<p>You can also use this tab to see the effects of the knowledge you created in the other tabs by checking and unchecking the boxes at the bottom of the window.  You can adjust the layout to mimic the layout of the source (by clicking “source layout”) or to see the variables in their timeline tiers (by clicking “knowledge layout”).</p>
-
-<h3>Forbidden Graph</h3>
-
-<p>If you use a graph as input to a knowledge box with the “Forbidden Graph” operation, the box will immediately add all edges in the parent graph as forbidden edges. It will otherwise work like a Tiers and Edges box.</p>
-
-<h3>Required Graph</h3>
-
-<p>If you use a graph as input to a knowledge box with the “Required Graph” operation, the box will immediately add all edges in the parent graph as required edges. It will otherwise work like a Tiers and Edges box.</p>
-
-<h3>Measurement Model</h3>
-
-<p>This option allows you to build clusters for a measurement model. When first opened, the window looks like this:</p>
-
-<img src="images/knowledge_box_4.png" alt="" width="650">
-
-<p>You can change the number of clusters using the text box in the upper right hand corner. To place a variable in a cluster, click and drag the box with its name into the cluster pane. To move multiple variables at once, shift- or command-click on the variables, and (without releasing the shift/command button or the mouse after the final click) drag. In the search boxes, these variables will be assumed to be children of a common latent cause.</p>
-
-
-<h2 id="simulation_box"><span  class="section_heading">Simulation Box</span></h2>
-
-<p>The simulation box takes a graph, parametric model, or instantiated model and uses it to simulate a data set.</p>
-
-<h3>Possible Parent Boxes of the Simulation Box</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A parametric model box</li>
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-<li>A data box</li>
-<li>Another simulation box</li>
-<li>A search box</li>
-<li>An updater box</li>
-<li>A regression box</li>
-</ul>
-
-
-<h3>Possible Child Boxes of the Simulation Box</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A compare box</li>
-<li>A parametric model box</li>
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-<li>A data box</li>
-<li>Another simulation box</li>
-<li>A search box</li>
-<li>A classify box</li>
-<li>A regression box</li>
-<li>A knowledge box</li>
-</ul>
-
-
-<h3>Using the Simulator Box</h3>
-
-<p>When you first open the simulation box, you will see some variation on this window:</p>
-
-<img src="images/simulation_box_1.png" alt="" width="650">
-
-<p>The “True Graph” tab contains a copy of the “Generate Subgraphs” function from the graph box. This allows you to isolate subgraphs of the parent graph to use to model data. The “Data” tab will contain the data once it has been simulated.</p>
-
-<p>Exactly what you see and can do in the simulation box is determined by what kind of box you input into it. </p>
-
-
-<h4>The Simulation Box with no Input</h4>
-
-<p>Because it has no input box to create constraints, a parentless simulation box offers the greatest freedom for setting the graph type, model type, and parameters of your simulated data. In particular, it is the only way that the simulation box will allow you to create a random graph or graphs within the box. (If you are simulating multiple data sets, and want to use a different random graph for each one, you can select “Yes” under “Yes if a different graph should be used for each run.”) You can choose the type of graph you want Tetrad to create from the “Type of Graph” drop-down list.</p>
-
-<h5>Random Forward DAG</h5>
-
-<p> This option creates a DAG by randomly adding forward edges (edges that do not point to a variable’s ancestors) one at a time. You can specify graph parameters such as number of variables, maximum and minimum degrees, and connectedness.</p>
-
-<h5>Scale Free DAG</h5>
-
-<p> This option creates a DAG whose variable’s degrees obey a power law. You can specify graph parameters such as number of variables, alpha, beta, and delta values.</p>
-
-<h5>Cyclic, constructed from small loops</h5>
-
-<p> This option creates a cyclic graph. You can specify graph parameters such as number of variables, maximum and average degrees, and the probability of the graph containing at least one cycle.</p>
-
-<h5>Random One Factor MIM</h5>
-
-<p> This option creates a one-factor multiple indicator model. You can specify graph parameters such as number of latent nodes, number of measurements per latent, and number of impure edges.</p>
-
-<h5>Random Two Factor MIM</h5>
-
-<p> This option creates a two-factor multiple indicator model. You can specify graph parameters such as number of latent nodes, number of measurements per latent, and number of impure edges.</p>
-
-<p>In addition to the graph type, you can also specify the type of model you would like Tetrad to simulate.</p>
-
-<h5>Bayes net</h5>
-
-<p> Simulates a Bayes instantiated model. You can specify model parameters including maximum and minimum number of categories for each variable.</p>
-
-<h5>Structural Equation Model</h5>
-
-<p> Simulates a SEM instantiated model. You can specify model parameters including coefficient, variance, and covariance ranges.</p>
-
-<h5>Linear Fisher Model</h5>
-
-<p>Simulates data using a linear Markov 1 DBN without concurrent edges. The Fisher model suggests that shocks should be applied at intervals and the time series be allowed to move to convergence between shocks. This simulation has many parameters that can be adjusted, as indicated in the interface. The ones that require some explanation are as follows.</p>
-
-<ul class="ul">
-<li>Low end of coefficient range, high end of coefficient range, low end of variance range, high end of variance range. Each variable is a linear function of the parents of the variable (in the previous time lag) plus Gaussian noise. The coefficients are drawn randomly from U(a, b) where a is the low end of the coefficient range and b is the high end of the coefficient range. Here, a < b. The Gaussian noise is drawn uniformly from U(c, d), where c is the low end of the variance range and d is the high end of the variance range. Here, c < d.</li>
-<li>Yes, if negative values should be considered. If no, only positive values will be recorded. This should not be used for large numbers of variables, since it is more difficult to find cases with all positive values when the number of variables is large.</li>
-<li>Percentage of discrete variables. The model generates continuous data, but some or all of the variables may be discretized at random. The user needs to indicate the percentage of variables (randomly chosen that one wishes to have discretized. The default is zero—i.e., all continuous variables.</li>
-<li>Number of categories of discrete variables. For the variables that are discretized, the number of categories to use to discretize each of these variables.</li>
-<li>Sample size. The number of records to be simulated.</li>
-<li>Interval between shocks. The number of time steps between shocks in the model.</li>
-<li>Interval between data recordings. The data are recorded every so many steps. If one wishes to allow to completely converge between steps (i.e., produce equilibrium data), set this interval to some large number like 20 and set the interval between shocks likewise to 20 Other values can be used, however.</li>
-<li>Epsilon for convergence. Even if you set the interval between data recordings to a large number, you can specify an epsilon such that if all values of variables differ from their values one time step back by less than epsilon, the series will be taken to have converged, and the remaining steps between data recordings will be skipped, the data point being recorded at convergence.</li>
-</ul>
-
-<h5>Lee &amp; Hastie</h5>
-
-<p> This is a model for simulating mixed data (data with both continuous and discrete variables. The model is given in Lee J, Hastie T. 2013, Structure Learning of Mixed Graphical Models, Journal of Machine Learning Research 31: 388-396. Here, mixtures of continuous and discrete variables are treated as log-linear.</p>
-
-<ul class="ul">
-<li>Percentage of discrete variables. The model generates continuous data, but some or all of the variables may be discretized at random. The user needs to indicate the percentage of variables (randomly chosen that one wishes to have discretized. The default is zero—i.e., all continuous variables.</li>
-<li>Number of categories of discrete variables. For the variables that are discretized, the number of categories to use to discretize each of these variables.</li>
-<li>Sample size. The number of records to be simulated.</li>
-</ul>
-
-<h5>Time Series</h5>
-
-<p> This is a special simulation for representing time series. Concurrent edges are allowed. This can take a Time Series Graph as input, in which variables in the current lag are written as functions of the parents in the current and previous lags.</p>
-
-<ul class="ul">
-<li>Sample size. The number of records to be simulated.</li>
-</ul>
-
-<h5>Boolean Glass</h5>
-
-<p> The instantiated model used to simulate the data will be re-parameterized for each run of the simulation.</p>
-
-
-<h4>The Simulation Box with a Graph Input</h4>
-
-<p>If you input a graph, you will be able to simulate any kind of model, with any parameters. But the model will be constrained by the graph you have input (or the subgraph you choose in the “True Graph” tab.) Because of this, if you create a simulation box with a graph as a parent, you will not see the “Type of Graph” option.</p>
-
-<h4>The Simulation Box with a Parametric Model Input</h4>
-
-<p>At the time of writing, a simulation box with a parametric model input acts as though the PM’s underlying graph had been input into the box.</p>
-
-
-<h4>The Simulation Box with an Instantiated Model Input</h4>
-
-<p>If you input an instantiated model, your only options will be the sample size of your simulation and the number of data sets you want to simulate; Tetrad will simulate every one of them based on the parameters of the IM. The model will not be re-parameterized for each run of the simulation.</p>
-
-
-
-
-
-<h2 id="search_box"><span  class="section_heading">Search Box</span></h2>
-
-<p>The search box takes as input a data set (in either a data or simulation box) and optionally a knowledge box, and searches for causal explanations represented by directed graphs. The result of a search is not necessarily—and not usually—a unique graph, but an object such as a pattern that represents a set of graphs, usually a Markov Equivalence class. More alternatives can be found by varying the parameters of search algorithms.</p>
-
-<h3>Possible Parent Boxes of the Search Box</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A parametric model box</li>
-<li>An instantiated model box</li>
-<li>An estimator box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-<li>Another search box</li>
-<li>A regression box</li>
-<li>A knowledge box</li>
-</ul>
-
-
-<h3>Possible Child Boxes of the Simulation Box</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A compare box</li>
-<li>A parametric model box</li>
-<li>A simulation box</li>
-<li>Another search box</li>
-<li>A knowledge box</li>
-</ul>
-
-<h3>Using the Search Box</h3>
-
-<p>When you first open the search box, you will be presented with a number of options for the kind of search you would like to perform:</p>
-
-<img src="images/search_box_1.png" alt="" width="650">
-
-
-<p>The “Output Graphs” tab is where the results of your search will be stored after it has been performed. The “Knowledge” tab contains a copy of the “Tiers and Edges” knowledge box, which you can use to add knowledge directly in the search box. (See the Knowledge Box section for more information.)</p>
-
-<p>In the “Algorithm” tab, you can choose which search algorithm you want to perform, and set any relevant parameters. (As most of the algorithms require different parameters, the contents of the “Parameters” pane will change depending on which algorithm you select.) To choose an algorithm, select it from the drop-down list next to the “Search” button.</p>
-
-<p>Choosing the correct algorithm for your needs is an important consideration. Tetrad provides over 30 search algorithms (and more are added all of the time) each of which makes different assumptions about the input data, uses different parameters, and produces different kinds of output. For instance, some algorithms produce Markov blankets or patterns, and some produce full graphs; some algorithms work best with Gaussian or non-Gaussian data; some algorithms require an alpha value, some require a penalty discount, and some require both or neither. You can narrow down the list using the “List algorithms that” dropdown box, which allows you to limit the provided algorithms according to whichever factor is important to you.</p>
-
-<p>Once you have selected an algorithm, click “Search” to have Tetrad perform the search or searches.</p>
-
-<h3>The PC Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="pc-all">
-
-<p>PC algorithm (Spirtes and Glymour, Social Science Computer Review, 1991) is a pattern search which assumes that the underlying causal structure of the input data is acyclic, and that no two variables are caused by the same latent (unmeasured) variable. In addition, it is 	assumed that the input data set is either entirely continuous or entirely discrete; if the data set is  continuous, it is assumed that the causal relation between any two variables is linear, and that the distribution of each variable is Normal. Finally, the sample should ideally be i.i.d.. Simulations show that PC and several of the other algorithms described here often succeed when these assumptions, needed to prove their correctness, do not strictly hold. The PC algorithm will sometimes output double headed edges. In the large sample limit, double headed edges in the output indicate that the adjacent variables have an unrecorded common cause, but PC tends to produce false positive double headed edges on small samples.</p>
-
-<p>The PC algorithm is correct whenever decision procedures for independence and conditional independence are available. The procedure conducts a sequence of independence and conditional independence tests, and efficiently builds a pattern from the results of those tests. As implemented in TETRAD, PC is intended for multinomial and approximately Normal distributions with i.i.d. data. The tests have an alpha value for rejecting the null hypothesis, which is always a hypothesis of independence or conditional independence. For continuous variables, PC uses tests of zero correlation or zero partial correlation for independence or conditional independence respectively. For discrete or categorical variables, PC uses either a chi square or a g square test of independence or conditional independence (see Causation, Prediction, and Search for details on tests). In either case, the tests require an alpha value for rejecting the null hypothesis, which can be adjusted by the user. The procedures make no adjustment for multiple testing. (For PC, CPC, JPC, JCPC, FCI, all testing searches.) </p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>The algorithm effectively takes conditional independence facts as input. Thus it will work for any type of data for which a conditional independence facts are known. In the interface, it will work for linear, Gaussian data (the Fisher Z test), discrete multinomial data the Chi Square test) and mixed multinomial/Gaussian data (the Conditional Gaussian test).</p>
-
-<h4>Output Format</h4>
-
-<p>The graph outputs a pattern (or CP-DAG). This is an equivalence class of directed acyclic graphs (DAGs). Each DAG in the equivalence class has all of the adjacencies (and no more) of the pattern. Each oriented edge in the pattern is so oriented in each of the DAG in the equivalence class. Unoriented edges in the equivalence class cannot be oriented by conditional independence facts. For example, if the model is X->Y->Z, the output will be X—Y—Z. There are not collider in this model, so the algorithm will not detect one. Since there are not colliders, the Meek cannot orient additional edges. If the model were X<-Y<-Z, the output would also be X—Y—Z; this model is in the same equivalence class as X->Y->Z. The model X->Y<-Z would be its own equivalence class, since the collider in this model can be oriented. See Spirtes et al. (2000) for more details.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value.  For instance, for depth 3, the maximum size of a conditioning set considered will be 3. Default -1 = unlimited.
-</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-<h3>The CPC Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="cpc">
-
-<p>The CPC (Conservative PC) algorithm (Ramsey et al., ??) modifies the collider orientation step of PC to make it more conservative—that is, to increase the precision of collider orientations at the expense of recall. It does this as follows. Say you want to orient X—Y—Z as a collider or a noncollider; the PC algorithm looks at variables adjacent to X or variables adjacent to Z to find a subset S such that X is independent of Z conditional on S. The CPC algorithm considers all possible such sets and records the set on which X is conditionally independent of Z. If all of these sets contain Y, it orients X—Y—Z as a noncollider. If none of them contains Z, if orient X—Y—Z as a collider. If some contain Z but other don’t, it marks it as ambiguous, with an underline. Thus, the output is ambiguous between patterns; in order to get a specific pattern out of the output, one needs first to decide whether the underlined triples are colliders or noncolliders and then to apply the orientation rules in Meek (1997).</p>
-
-<p>The PC algorithm is correct whenever decision procedures for independence and conditional independence are available. The procedure conducts a sequence of independence and conditional independence tests, and efficiently builds a pattern from the results of those tests. As implemented in TETRAD, PC is intended for multinomial and approximately Normal distributions with i.i.d. data. The tests have an alpha value for rejecting the null hypothesis, which is always a hypothesis of independence or conditional independence. For continuous variables, PC uses tests of zero correlation or zero partial correlation for independence or conditional independence respectively. For discrete or categorical variables, PC uses either a chi square or a g square test of independence or conditional independence (see Causation, Prediction, and Search for details on tests). In either case, the tests require an alpha value for rejecting the null hypothesis, which can be adjusted by the user. The procedures make no adjustment for multiple testing. (For PC, CPC, JPC, JCPC, FCI, all testing searches.) </p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Same as for PC.</p>
-
-<h4>Output Format</h4>
-
-<p>An e-pattern (extended pattern), consistent of directed and undirected edges where some of the triple may have been marked with underlines to indicate ambiguity, as above. It may be that bidirected edges are oriented as X->Y<->X<-W if two adjacent colliders are oriented; this is not ruled out.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3. Default -1 = unlimited.
-</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-<h3>The PCStable Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="pc-stable">
-
-<p>See Drton and Maathuis (??). The idea is to modify the adjacency search of PC so that if the order of the variables is randomized, the adjacency output is not affected. This is done as follows. The order of operations for the step where unconditional independencies are calculated is not affected; these may be done in any order. However, for the step in which one conditions on one variable, the output of that step could be affected by the order in which the operations are done. So instead of removing edges in this step, one simply records which edges one would remove, and then at the end of the step removes them all. Similarly for subsequence steps. In this way, the adjacencies of variables in the output of the adjacency step are fixed no matter the order in which the operations are visited. One them does collider orientation and applies the orientation rules in Meek (1997); there may be orientation differences from one run to the next still, if the order of the variables in the dataset is modified.</p>
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Same as for PC.</p>
-
-<h4>Output Format</h4>
-
-<p>Same as for PC.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3. Default -1 = unlimited.
-</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-
-<h3>The CPCStable Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="cpc-stable">
-
-<p>CPC, with the PC-Stable adjacency step substituted for the PC adjacency search.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Same as for PC.</p>
-
-<h4>Output Format</h4>
-
-<p>Same as for CPC (an e-pattern).</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3. Default -1 = unlimited.
-</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-<h3>The PcMax Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="cpc-stable">
-
-<p>Similar in spirit to CPC but orients all unshielded triples using maximum likelihood conditioning sets. The idea is as follows. The adjacency search is the same as for PC, but colliders are oriented differently. Let X—Y—Z be an unshielded triple (X not adjacent to Z) and find all subsets S from among the adjacents of X or the adjacents of Z such that X is independent of Z conditional on S. However, instead of using the CPC rule to orient the triple, instead just list the p-values for each of these conditional independence judgments and pick the set S’ that yields the highest such p-value. Then orient X->Y<-Z if S does not contain Y and X—Y—Z otherwise. This orients all unshielded triples. It’s possible (though rare) that adjacent triples both both be oriented as 2-cycles, X->Y<->Z<-W. If this happens, pick one of the other of these triples or orient as a collider, arbitrarily. This guarantees that the resulting graph will be a pattern.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Same as for PC.</p>
-
-<h4>Output Format</h4>
-
-<p>Same as PC, a pattern.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3. Default -1 = unlimited.
-</td>
-</tr>
-
-<tr>
-<td>Yes if heuristic for orienting ushielded colliders for max P should be used</td>
-<td>For orienting X->Y<-Z, if the adjacents of X and of Z are not too close to each other in the graph, one can tell that this is a collider by looking at the difference in p-value between X _||_ Z | Y and X _||_ Z. This is faster and under the “closeness” condition is more accurate. Should not be used for dense graphs. Default true.</td>
-</tr>
-
-<tr>
-<td>Maximum path length for the unshielded collider heuristic for max P</td>
-<td>This is the furthest distance among adjacents of X and Z that will be tolerated if the heuristic above is to be used. Default 3.</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-
-<h3>The FGES Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="fges">
-
-<p>
-FGES is an optimized and parallelized version of an algorithm developed by Meek
-[Meek, 1997] called the Greedy Equivalence Search (GES). The algorithm was further developed
-and studied by Chickering [Chickering, 2002]. GES is a Bayesian algorithm that heuristically
-searches the space of CBNs and returns the model with highest Bayesian score it finds. In
-particular, GES starts its search with the empty graph. It then performs a forward stepping search in
-which edges are added between nodes in order to increase the Bayesian score. This process
-continues until no single edge addition increases the score. Finally, it performs a backward
-stepping search that removes edges until no single edge removal can increase the score. For more
-information see http://www.ccd.pitt.edu/pdfs/fgesc.pdf. The reference is Ramsey et al., 2017.
-</p>
-
-<p>
-The algorithms requires a decomposable score—that is, a score that for the entire DAG model is a
-sum of logged scores of each variables given its parents in the model. The algorithms can take all
-continuous data (using the SEM BIC score), all discrete data (using the BDeu score) or a mixture
-of continuous and discrete data (using the Conditional Gaussian score); these are all decomposable
-scores.
-</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Data that’s all continuous, all discrete, or a mixture of continuous and discrete
-variables. Continuous variables will be assumed to be linearly associated; discrete variable will be
-assumed to be associated by multinomial conditional probability tables. Continuous variables for
-the mixed case will be assumed to be jointly Gaussian.</p>
-
-<h4>Output Format</h4>
-
-<p>A pattern, same as PC.</p>
-
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Sample prior</td>
-<td> For the BDeu score (discrete variables), this is the effective sample
-size added to each conditional probability table. Must be at least 1 (blame the 
-90
-Dirichlet distribution). Default 1.</td>
-</tr>
-
-<tr>
-<td>Structure prior</td>
-<td> For the BDeu score (discrete variables), this is the number of
-variables one expects to see on average in any particular conditional probability
-table. If one expects to see for the most part conditional models of variables with
-two parents, then this should be set to 2. Default 1.
-</td>
-</tr>
-
-<tr>
-<td>Penalty discount</td>
-<td>  For the SEM BIC score (continuous variables), BIC is calculated
-as BIC = 2 L – c k ln n, where L is the likelihood, k is the number of degrees of
-freedom, n is the sample size, and c (the “penalty discount” is some positive
-constant, usual greater than or equal to 1. Setting this to a larger number makes the
-output of FGES sparser. Default 2.</td>
-</tr>
-
-<tr>
-<td>Yes if the first step of FGES should do scoring for both X->Y and Y->X</td>
-<td> For the
-linear, Gaussian case, and for the multinomial case, the scores for these two
-directions are guaranteed to be equal, but in some domains, like mixed variables
-search, they are not, and the best score of the two should be used. Default false.</td>
-</tr>
-
-<tr>
-<td>Yes if (one edge) faithfulness should be assumed</td>
-<td>The algorithm will remove edges
-X—Y in the initial step if X and Y are uncorrelated; this speeds up the algorithm
-(See Maathuis, ??, Ramsey et al., ??). However, this may remove edges that the
-original GES algorithm would not remove, so an additional pass through the
-algorithm may need to be done to pick up these additional edges and guarantee
-correctness. This should be set to Yes if the additional pass should not be done, No
-if the additional pass should be done. Default false.</td>
-</tr>
-
-<tr>
-<td>The maximum degree of the graph</td>
-<td> For some graphs, FGES may be inclined to find
-many adjacents for particular nodes, and in the forward step it will add adjacents
-that will later be removed in the backward step. To keep such edges from being
-added, one may specify a maximum degree for the graph. In the forward step, fGES
-will not add edges that results in the degree of any node exceeding this maximum.
-Default 100.</td>
-</tr>
-</tbody>
-
-</table>
-
-
-<h3>The IMaGES Algorithm (BDeu Score)</h3>
-
-<h4>Description</h4>
-
-<div id="img">
-
-<p>Adjusts the discrete BDeu variable score of FGES so allow for multiple datasets as input. The BDeu scores for each data set are averaged at each step of the algorithm, producing a model for al data sets that assumes they have the same graphical structure across dataset. Note that in order to use this algorithm in a nontrivial way, one needs to have loaded or simulated multiple dataset.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>A set of discrete datasets with the same variables and sample sizes.</p>
-
-<h4>Output Format</h4>
-
-<p>A pattern, interpreted as a common model for all datasets.</p>
-
-<h4>Parameters</h4>
-
-<p>All of the parameters from FGES are available for IMaGES. Additionally:</p>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>The number of runs</td>
-<td>The number of times the algorithm should select data sets and run the algorithm. Default 1.</td>
-</tr>
-
-<tr>
-<td>The number of datasets that should be taken in each random sample</td>
-<td>IMaGES will randomly select a set of datasets to run, so that on different runs one can be an estimate of the consistency of results. To use all variables, set this to the total number of datasets. Default 1.
-</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-<h3>The IMaGES Algorithm (SEM BIC Score)</h3>
-
-<h4>Description</h4>
-
-<div id="img">
-
-<p>Adjusts the continuous variable score (SEM BIC) of FGES so allow for multiple datasets as input. The linear, Gaussian BIC scores for each data set are averaged at each step of the algorithm, producing a model for al data sets that assumes they have the same graphical structure across dataset.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>A set of continuous datasets with the same variables and sample sizes.</p>
-
-<h4>Output Format</h4>
-
-<p>A pattern, interpreted as a common model for all datasets.</p>
-
-<h4>Parameters</h4>
-
-<p>All of the parameters from FGES are available for IMaGES. Additionally:</p>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>The number of runs</td>
-<td>The number of times the algorithm should select data sets and run the algorithm. Default 1.</td>
-</tr>
-
-<tr>
-<td>The number of datasets that should be taken in each random sample</td>
-<td>IMaGES will randomly select a set of datasets to run, so that on different runs one can be an estimate of the consistency of results. To use all variables, set this to the total number of datasets. Default 1.
-</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-<h3>The FCI Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="fci">
-
-<p>The FCI algorithm is a constraint-based algorithm that takes as input sample data and optional background knowledge and in the large sample limit outputs an equivalence class of CBNs that (including those with hidden confounders) that entail the set of conditional independence relations judged to hold in the population. It is limited to several thousand variables, and on realistic sample sizes it is inaccurate in both adjacencies and orientations. FCI has two phases: an adjacency phase and an orientation phase. The adjacency phase of the algorithm starts with a complete undirected graph and then performs a sequence of conditional independence tests that lead to the removal of an edge between any two adjacent variables that are judged to be independent, conditional on some subset of the observed variables; any conditioning set that leads to the removal of an adjacency is stored. After the adjacency phase, the resulting undirected graph has the correct set of adjacencies, but all of the edges are unoriented. FCI then enters an orientation phase that uses the stored conditioning sets that led to the removal of adjacencies to orient as many of the edges as possible. </p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>The data are continuous, discrete, or mixed.</p>
-
-<h4>Output Format</h4>
-
-<p>A partial ancestral graph (see Spirtes et al., 2000).</p>
-
-<h4>Parameters</h4>
-
-<p>All of the parameters from FGES are available for IMaGES. Additionally:</p>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Defualt 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3. Default -1 = unlimited.
-</td>
-</tr>
-
-<tr>
-<td>The maximum length for any discriminating path</td>
-<td>For a description of discriminating paths, please see Spirtes et al, 2000. The idea is that one needs to search out from each variable in the orientation phase of the algorithm down all connected paths tree-like to see if there is a path of a certain sort. This can take time and for complex models can slow the algorithm down. A fix for this is to limit just how long these paths can be expected to be in maximum. The default is -1, or unlimited. Defualt -1 = unlimited.</td>
-</tr>
-
-<tr>
-<td>Yes if the complete FCI rule set should be used</td>
-<td>The standard rule set used in Spirtes et al., 2000, is guaranteed to include all arrowheads that can be found in the model but not all tails. Zhang (??) provides an extended rule set that is tail complete. This can be of benefit, for instance, when investigating selection bias. Default no (i.e. the algorithm in Spirtes et al., 2000).</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-
-<h3>The RFCI Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="rfci">
-
-<p>A modification of the FCI algorithm in which some expensive steps are finessed and the output is somewhat differently interpreted. In most cases this runs faster than FCI (which can be slow in some steps) and is almost as informative. See ??.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Data for which a conditional independence test is available.</p>
-
-<h4>Output Format</h4>
-
-<p>A partial ancestral graph (PAG). See Spirtes et al., 2000.</p>
-
-<h4>Parameters</h4>
-
-<p>All of the parameters from FGES are available for IMaGES. Additionally:</p>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Defualt 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3. Default -1 = unlimited.
-</td>
-</tr>
-
-<tr>
-<td>Yes if the complete FCI rule set should be used</td>
-<td>The standard rule set used in Spirtes et al., 2000, is guaranteed to include all arrowheads that can be found in the model but not all tails. Zhang (??) provides an extended rule set that is tail complete. This can be of benefit, for instance, when investigating selection bias. Default no (i.e. the algorithm in Spirtes et al., 2000).</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-<h3>The GFCI Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="gfci">
-
-<p>GFCI is a combination of the FGES [CCD-FGES, 2016] algorithm and the FCI algorithm [Spirtes, 1993] that improves upon the accuracy and efficiency of FCI. In order to understand the basic methodology of GFCI, it is necessary to understand some basic facts about the FGES and FCI algorithms.  The FGES algorithm is used to improve the accuracy of both the adjacency phase and the orientation phase of FCI by providing a more accurate initial graph that contains a subset of both the non-adjacencies and orientations of the final output of FCI. The initial set of nonadjacencies given by FGES is augmented by FCI performing a set of conditional independence tests that lead to the removal of some further adjacencies whenever a conditioning set is found that makes two adjacent variables independent. After the adjacency phase of FCI, some of the orientations of FGES are then used to provide an initial orientation of the undirected graph that is then augmented by the orientation phase of FCI to provide additional orientations.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Same as for FCI.</p>
-
-<h4>Output Format</h4>
-
-<p>Same as for FCI.</p>
-
-<h4>Parameters</h4>
-
-<p>Uses all of the parameters of FCI (see) and FGES (see).</p>
-
-
-<h3>The TsFCI Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="tsfci">
-
-<p>The tsGFCI algorithm is a version of GFCI for time series data. See the GFCI documentation for a description of the GFCI algorithm, which allows for unmeasured (hidden, latent) variables in the data-generating process and produces a PAG (partial ancestral graph). tsGFCI takes as input a “time lag data set,” i.e., a data set which includes time series observations of variables X1, X2, X3, ..., and their lags X1:1, X2:1, X3:1, ..., X1:2, X2:2,X3:2, ... and so on. X1:n is the nth-lag of the variable X1. To create a time lag data set from a standard tabular data set (i.e., a matrix of observations of X1, X2, X3, ...), use the “create time lag data” function in the data manipulation toolbox. The user will be prompted to specify the number of lags (n), and a new data set will be created with the above naming convention. The new sample size will be the old sample size minus n.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>The (continuous) data has been generated by a time series.</p>
-
-<h4>Output Format</h4>
-
-<p>(Need to get this from Dan.)</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Defualt 0.01.</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-
-<h3>The TsGFCI Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="ts-gfci">
-
-<p>tsGFCI uses a BIC score to search for a skeleton. Thus, the only user-specified parameter is an optional “penalty score” to bias the search in favor of more sparse models. See the description of the GES algorithm for discussion of the penalty score. For the traditional definition of the BIC score, set the penalty to 1.0. The orientation rules are the same as for FCI.
-As is the case with tsFCI, tsGFCI will automatically respect the time order of the variables and impose a repeating structure. Firstly, it puts lagged variables in appropriate tiers so, e.g., X3:2 can cause X3:1 and X3 but X3:1 cannot cause X3:2 and X3 cannot cause either X3:1 or X3:2. Also, it will assume that the causal structure is the same across time, so that if the edge between X1 and X2 is removed because this increases the BIC score, then also the edge between X1:1 and X2:1 is removed, and so on for additional lags if they exist. When some edge is removed as the result of a score increase, all similar (or “homologous”) edges are also removed.
-</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>The (continuous) data has been generated by a time series.</p>
-
-<h4>Output Format</h4>
-
-<p>(Need to get this from Dan.)</p>
-
-<h4>Parameters</h4>
-
-<p>Uses the parameters of FCI (see) and FGES (see).</p>
-
-
-
-<h3>The TsIMaGES Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="ts-imgs">
-
-<p>tsIMAGES is a version of tsGFCI which averages BIC scores across multiple data sets. Thus, it is used to search for a PAG (partial ancestral graph) from time series data from multiple units (subjects, countries, etc). tsIMAGES allows both for unmeasured (hidden, latent) variables and the possibility that different subjects have different causal parameters, though they share the
-same qualitative causal structure. As with IMAGES, the user can specify a “penalty score” to produce more sparse models. For the traditional definition of the BIC score, set the penalty to 1.0. See the documentation for IMAGES and tsGFCI.
-
-</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>The (continuous) data has been generated by a time series.</p>
-
-<h4>Output Format</h4>
-
-<p>(Need to get this from Dan.)</p>
-
-<h4>Parameters</h4>
-
-<p>Uses the parameters of IMaGES (see).</p>
-
-
-<h3>The FGES-MB Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="fges-mb">
-
-<p>This is a restriction of the FGES algorithm to union of edges over the combined Markov blankets of a set of targets, including the targets. In the interface, just one target may be specified. See Ramsey et al., 2017 for details. In the general case, finding the graph over the Markov blanket variables of a target (including the target) is far faster than finding the pattern for all of the variables.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>The same as FGES</p>
-
-<h4>Output Format</h4>
-
-<p>A graph over a selected group of nodes that includes the target and each node in the Markov blanket of the target. This will be the same as if FGES were run and the result restricted to just these variables, so some edges may be oriented in the returned graph that may not have been oriented in a pattern over the selected nodes.</p>
-
-<h4>Parameters</h4>
-
-<p>Uses the parameters of FGES (see). </p>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Target Name</td>
-<td>The name of the target variables for the Markov blanket one wishes to construct. Default blank (that is, unspecified.) A variable must be specified here to run the algorithm.</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-<h3>The MBFS Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="mbfs">
-
-<p>Markov blanket fan search. Similar to FGES-MB (see) but using PC as the basic search instead of FGES. The rules of the PC search are restricted to just the variables in the Markov blanket of a target T, including T; the result is a graph that is a pattern over these variables.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Same as for PC</p>
-
-<h4>Output Format</h4>
-
-<p>A pattern over a selected group of nodes that includes the target and each node in the Markov blanket of the target.</p>
-
-<h4>Parameters</h4>
-
-<p>Uses the parameters of PC (see).</p>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Target Name</td>
-<td>The name of the target variables for the Markov blanket one wishes to construct. Default blank (that is, unspecified.) A variable must be specified here to run the algorithm.</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-<h3>The FAS Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="fas">
-
-<p>This is just the adjacency search of the PC algorithm, included here for times when just the adjacency search is needed, as when one is subsequently just going to orient variables pairwise.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Same as for PC</p>
-
-<h4>Output Format</h4>
-
-<p>An undirected graph over the variables of the input dataset. In particular, parents of a variables are not married by FAS, so the resulting graph is not a Markov random field. For example, if X->Y<-Z, the output will be X—Y—Z with X—Z. The parents of Y will be joined by an undirected edge, morally, only if they are joined by a trek in the true graph.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3. Default -1 = unlimited.</td>
-</tr>
-</tbody>
-
-</table>
-
-
-<h3>The MGM Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="mgm">
-
-<p>Need reference. Finds a Markov random field (with parents married) for a dataset in which continuous and discrete variables are mixed together. For example, if X->Y<-Z, the output will be X—Y—Z with X—Z. The parents of Y will be joined by an undirected edge, morally, even though this edge does not occur in the true model.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Data are mixed.</p>
-
-<h4>Output Format</h4>
-
-<p>A Markov random field for the data.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>MGM Tuning Parameters #1, #2, #3</td>
-<td>Defaults for these are 0.1, though they can be adjusted. See ??.</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-<h3>The GLASSO Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="glasso">
-
-<p>A translation of the Fortran code for GLASSO (Graphical LASSO—see Tibshirani anad Hastie, ??) Like MGM, this produces an undirected graph in which parents are always married.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>The data are continuous.</p>
-
-<h4>Output Format</h4>
-
-<p>A Markov random field.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>MAXIT, IA, IS,  ITR, IPEN, THR</td>
-<td>These are parameters in the translated Fortan code (see). Defaults are given in the interface and are the same as for the Fortran code.</td>
-</tr>
-
-</tbody>
-
-</table>
-
-
-
-<h3>The BPC Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="bpc">
-
-<p>Searches for causal structure over latent variables, where the true models are Multiple Indicator Models (MIM’s) as described in the Graphs section. The idea is this. There is a set of latent (unmeasured) variables over which a directed acyclic model has been defined. Then for each of these latent L there are 3 (preferably 4) or more measures of that variable—that is, measured variables that are all children of L. Under these conditions, one may define tetrad constraints (see Spirtes et al., 2000). There is a theorem to the effect that if certain patterns of these tetrad constraints hold, there must be a latent common cause of all of them (the Tetrad Representation Theorem, see Silva and Scheines, ??, where the BPC (“Build Pure Clusters”) algorithm is defined and discussed.) Moreover, once one has such a “measurement model,” once can estimate a covariance matrix over the latent variables that are parents of the measures and use some algorithm such as PC or GES to estimate a pattern over the latents. The algorithm to run PC or GES on this covariance matrix is called MimBuild (“MIM” is the the graph, Multiple Indicator Model; “Build” means build). In this way, one may recover causal structure over the latents. The more measures one has for each latent, the better the result is, generally. The larger the sample size the better. One important issue is that the algorithm is sensitive to so-called “impurities”—that is, causal edges among the measured variables, or between measured variables and unintended latent. The algorithm will in effect remove one measure in each impure pair from consideration.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Continuous data, a collection of measurements in the above sense, excluding the latent variables (which are to be learned).</p>
-
-<h4>Output Format</h4>
-
-<p>For BPC, a measurement model, in the above sense. This is represented as a clustering of variables; it may be inferred that there is a single latent for each output cluster. For MimBuild, a pattern over the latent variables, one for each cluster.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Yes if the Wishart test should be used. No if the Delta test should be used.</td>
-<td>These are two tests of whether a set of four variables constitutes a pure tetrad—that is, if all tetrads for this set of four variables vanish. For the notion of a vanishing tetrad, see Spirtes et al., 2000. For the Delta test, see ??. Default No (Delta test).</td>
-</tr>
-</tbody>
-
-</table>
-
-
-<h3>The FOFC Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="fofc">
-
-<p>The FOFC (Find One Factor Clusters) is an alternative method that achieves the same goal as BPC; in testing, it seems to scale better with somewhat better accuracy (Kummerfeld and Ramsey, ??). The basic idea is to build up clusters one at a time by adding variables that keep them pure, in the sense that all relevant tetrad constraints still hold. There are different ways of going about this. One could try to build one cluster up as far as possible, then remove all of those variables from the set, and try to make a another cluster using the remaining variables (SAG, Seed and Grow). Or one can try in parallel to grow all possible clusters and then choose among the grown clusters using some criterion such as cluster size (GAP, Grow and Pick). In general, GAP is more accurate. The result is a clustering of variables. Similarly to BPC, MimBuild may be run on a covariance matrix estimated over the latents for the resulting clusters to find a pattern over the latents that represents the causal structure over the latents.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Continuous data containing as many measures as are available.</p>
-
-<h4>Output Format</h4>
-
-<p>For FOFC, a clustering of variables. For MimBuild, a pattern over latents.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Yes if the Wishart test should be used. No if the Delta test should be used.</td>
-<td>These are two tests of whether a set of four variables constitutes a pure tetrad—that is, if all tetrads for this set of four variables vanish. For the notion of a vanishing tetrad, see Spirtes et al., 2000. For the Delta test, see ??. Default No (Delta test).</td>
-</tr>
-
-<tr>
-<td>Yes if the GAP algorithm should be used. No if the SAG algorithm should be used. </td>
-<td>See algorithm description, above. Default No (SAG algorithm, faster, less accurate).</td>
-</tr>
-</tbody>
-
-</table>
-
-
-
-<h3>The FTFC Algorithm</h3>
-
-<h4>Description</h4>
-
-<div id="ftfc">
-
-<p>FTFC (Find Two Factor Clusters) is similar to FOFC, but instead of each cluster having one latent that is the parent of all of the measure in the cluster, it instead has two such latents. So each measure has two latent parents; these are two “factors.” Similarly to FOFC, constraints are checked for, but in this case, the constraints must be sextad constraints, and more of them must be satisfied for each pure cluster (see Kummerfelt et al., ??) Thus, the number of measures in each cluster, once impure edges have been taken into account, must be at least six, preferably more.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Continuous data over the measures with at least six variable variables in each cluster once variables involve in impure edges have been removed.</p>
-
-<h4>Output Format</h4>
-
-<p>A clustering of measures. It may be assumed that each cluster has at least two factors and that the clusters are pure.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Yes if the Wishart test should be used. No if the Delta test should be used.</td>
-<td>These are two tests of whether a set of four variables constitutes a pure tetrad—that is, if all tetrads for this set of four variables vanish. For the notion of a vanishing tetrad, see Spirtes et al., 2000. For the Delta test, see ??. Default No (Delta test).</td>
-</tr>
-
-<tr>
-<td>Yes if the GAP algorithm should be used. No if the SAG algorithm should be used. </td>
-<td>See algorithm description, above. Default No (SAG algorithm, faster, less accurate).</td>
-</tr>
-</tbody>
-
-</table>
-
-
-
-
-<h3>Orientation Algorithms (EB, R1, R2, R3, R4, RSkew, RSkewE, Skew, SkewE)</h3>
-
-<h4>Description</h4>
-
-<div id="">
-
-<p>These are algorithms that orient edges X—Y for continuous variables pairwise based on non-Gaussian information. (If the variables are all Gaussian, one cannot orient these edges. That is, these rules will orient left or right randomly.) For EB, RSkew, RSkewE, Skew and SkewE, see Hyvarinen and Smith, ??. For R1, R2, R3 and R4, see Ramsey et al., ??.</p>
-
-<p>The principles governing these rules vary. R1 and R2 appeal directly to the Central Limit Theorem to judge which of various conditioning sets yields the greatest non-Gaussianity measure. (The measure for non-Gaussianity measure used is Anderson-Darling.) R4 does as well, but allows coefficients for relevant parameters to be adjusted to achieve maximum non-Gaussianity. EB works by appealing to entropy for the orientation. R3 uses the same rule as EB except using the Anderson-Darling score for a measure of non-Gaussianity. RSkew and Skew appeal to measures of skew for the variables and assume positive skewness for all variables. The rules for the two are different; please see Hyvarinen and Smith for details. SkewE and RSkewE adjust the signs of variables by the signs of their skewnesses to ensure that the assumption of positive skewness holds. A comparison of all of these methods is given in Ramsey et al., ??. In general, for fMRI data, we find that the RSkew method works the best, followed by the R3 method. Cycles can be oriented using these methods, since each edge is oriented independently of the others.</p>
-
-</div>
-
-<h4>Input Assumptions</h4>
-
-<p>Continuous data in which the variables are non-Gaussian. Non-Gaussianity can be assessed using the Anderson-Darling score, which is available in the Data box.</p>
-
-<h4>Output Format</h4>
-
-<p>Orients all of the edges in the input graph using the selected score.</p>
-
-<h4>Parameters</h4>
-
-<table class="table">
-
-<thead>
-<tr><th>Parameter</th><th>Description</th></tr>
-</thead>
-
-<tbody>
-<tr>
-<td>Cutoff for p-values (alpha)</td>
-<td>Conditional independence tests with p-values greater than this will be judged to be independent (H0). Default 0.01.</td>
-</tr>
-
-<tr>
-<td>Maximum size of conditioning set (depth)</td>
-<td>PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3.</td>
-</tr>
-</tbody>
-
-</table>
-
-
-
-<h2 id="regression_box"><span  class="section_heading">Regression Box</span></h2>
-
-<p>The regression box performs regression on variables in a data set, in an attempt to discover causal correlations between them. Both linear and logistic regression are available.</p>
-
-<h3>Possible Parent Boxes of the Regression Box</h3>
-
-<ul class="ul">
-<li>A data box</li>
-<li>A simulation box</li>
-</ul>
-
-<h3>Possible Child Boxes of the Instantiated Model Box:</h3>
-
-<ul class="ul">
-<li>A graph box</li>
-<li>A compare box</li>
-<li>A parametric model box</li>
-<li>A data box</li>
-<li>A simulation box</li>
-<li>A search box</li>
-</ul>
-
-<h3>Multiple Linear Regression</h3>
-
-<p>Linear regression is performed upon continuous data sets. If you have a categorical data set upon which you would like to perform linear regression, you can make it continuous using the data manipulation box.</p>
-
-<p>Take, for example, a data set with the following underlying causal structure:</p>
-
-<img src="images/regression_box_1.png" alt="" width="360">
-
-<p>When used as input to the linear regression box, the following window results: </p>
-
-<img src="images/regression_box_2.png" alt="" width="650">
-
-<p>To select a variable as the response variable, click on it in the leftmost box, and then click on the top right-pointing arrow. If you change your mind about which variable should be the response variable, simply click on another variable and click on the arrow again. </p>
-
-<p>To select a variable as a predictor variable, click on it in the leftmost box, and then click on the second right- pointing arrow. To remove a predictor variable, click on it in the predictor box and then click on the left-pointing arrow.</p>
-
-<p>Clicking “Sort Variables” rearranges the variables in the predictor box so that they follow the same order they did in the leftmost box.  The alpha value in the lower left corner is a threshold for independence; the higher it is set, the less discerning Tetrad is when determining the independence of two variables.</p>
-
-<p>When we click “Execute,” the results of the regression appear in the box to the right. For each predictor variable, Tetrad lists the standard error, t value, and p value, and whether its correlation with the response variable is significant. </p>
-
-<p>The Output Graph tab contains a graphical model of the information contained in the Model tab. For the case in which X4 is the response variable and X1, X2, and X3 are the predictors, Tetrad finds that only X1 is significant, and the output graph looks like this:</p>
-
-<img src="images/regression_box_3.png" alt="" width="70">
-
-<p>Comparison to the true causal model shows that this correlation does exist, but that it runs in the opposite direction.</p>
-
-<h3>Logistic Regression</h3>
-
-<p>Logistic regression may be run on discrete, continuous, or mixed data sets; however, the response variable must be binary. In all other ways, the logistic regression box functions like the linear regression box.</p>
-
-
-</div>
-
-
-
-<!-- Google Analytics: change UA-XXXXX-Y to be your site's ID. -->
-<script>
-window.ga=function(){ga.q.push(arguments)};ga.q=[];ga.l=+new Date;
-ga('create','UA-XXXXX-Y','auto');ga('send','pageview')
-</script>
-<script src="https://www.google-analytics.com/analytics.js" async defer></script>
-
-</body>
-
-</html>
-
diff --git a/docs/notes/cliques.txt b/docs/notes/cliques.txt
index 513023a2..2d2975d5 100644
--- a/docs/notes/cliques.txt
+++ b/docs/notes/cliques.txt
@@ -3,9 +3,9 @@ This is an algorithm for listing all of the cliques for an undirected graph G.
 J Ramsey 12/2006
 
 Graph G is an undirected graph over nodes 1,...,n. L1 and L2 are perpetually
-sorted lists of integers. adj(perm) is a procedure that returns the list of nodes
-adjacent to n in G. addable(perm, L1) is a function that returns true just in case
-perm is adjacent to every node in L1 in graph G.
+sorted lists of integers. adj(k) is a procedure that returns the list of nodes
+adjacent to n in G. addable(k, L1) is a function that returns true just in case
+k is adjacent to every node in L1 in graph G.
 
 PROCEDURE cliques(G).
 1. nodes <- the nodes of G
diff --git a/docs/referenced_papers/CAUSAL.PS b/docs/referenced_papers/CAUSAL.PS
index a653b7a3..d909f60b 100644
--- a/docs/referenced_papers/CAUSAL.PS
+++ b/docs/referenced_papers/CAUSAL.PS
@@ -53,7 +53,7 @@ transform round exch round exch itransform moveto rulex 0 rlineto 0
 ruley neg rlineto rulex neg 0 rlineto fill grestore}B /a{moveto}B /delta
 0 N /tail{dup /delta X 0 rmoveto}B /M{S p delta add tail}B /b{S p tail}
 B /c{-4 M}B /d{-3 M}B /e{-2 M}B /f{-1 M}B /g{0 M}B /h{1 M}B /i{2 M}B /j{
-3 M}B /perm{4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p
+3 M}B /k{4 M}B /w{0 rmoveto}B /l{p -4 w}B /m{p -3 w}B /n{p -2 w}B /o{p
 -1 w}B /q{p 1 w}B /r{p 2 w}B /s{p 3 w}B /t{p 4 w}B /x{0 S rmoveto}B /y{
 3 2 roll p a}B /bos{/SS save N}B /eos{SS restore}B end
 %%EndProcSet
@@ -1610,7 +1610,7 @@ TeXDict begin
 589 y Fw(\003)827 768 y Fv(Chris)18 b(Meek)1120 747 y
 Fu(y)732 885 y Fv(Decem)n(b)r(er)g(23,)i(1997)164 1179
 y Ft(1)81 b(In)n(tro)r(duction)164 1288 y Fs(Directed)13
-b(acyclic)f(graphs)perm(ha)o(v)o(e)d(had)i(a)g(long)f(history)g(in)g(the)g
+b(acyclic)f(graphs)k(ha)o(v)o(e)d(had)i(a)g(long)f(history)g(in)g(the)g
 (mo)q(deling)f(of)h(statistical)164 1349 y(data.)33 b(One)20
 b(of)g(the)g(earliest)f(uses)h(is)g(b)o(y)f(Sew)o(all)g(W)l(righ)o(t)h
 (\(1921\))h(under)f(the)g(name)164 1409 y(path)g(analysis.)32
@@ -1642,7 +1642,7 @@ y(the)h(size)f(of)h(the)g(state)g(space,)g(and)h(\(iii\))d(the)i
 2235 648 2 v 220 2266 a Fr(\003)239 2281 y Fq(I)10 b(w)o(ould)g(lik)o
 (e)f(to)i(thank)f(Clark)g(Glymour,)e(Thomas)h(Ric)o(hardson)h(and)g(P)o
 (eter)i(Spirtes)f(for)g(helpful)164 2330 y(con)o(v)o(ersations)j(ab)q
-(out)f(the)h(con)o(ten)o(ts)g(of)f(this)h(pap)q(er.)perm(Researc)o(h)d
+(out)f(the)h(con)o(ten)o(ts)g(of)f(this)h(pap)q(er.)k(Researc)o(h)d
 (for)e(this)g(pap)q(er)h(w)o(as)f(supp)q(orted)i(b)o(y)164
 2380 y(the)f(O\016ce)h(of)e(Na)o(v)o(el)h(Researc)o(h)h(gran)o(t)e(ONR)
 h(#N00014-93-1-0568)o(.)221 2415 y Fr(y)239 2430 y Fq(Departmen)o(t)d
@@ -1666,22 +1666,22 @@ b(\(ii\))14 b(Giv)o(en)g(that)h(there)f(is)g(suc)o(h)h(a)g(causal)164
 737 y(explanation)i(what)i(are)e(the)g(causal)h(relationships)f(common)
 f(to)h(ev)o(ery)f(suc)o(h)i(causal)164 797 y(explanation?)36
 b(A)20 b(sp)q(ecial)h(case)g(of)g(the)g(\014rst)g(question,)h(where)e
-(there)h(is)g(no)g(bac)o(perm-)164 857 y(ground)15 b(kno)o(wledge,)f(has)h
+(there)h(is)g(no)g(bac)o(k-)164 857 y(ground)15 b(kno)o(wledge,)f(has)h
 (b)q(een)g(answ)o(ered)f(in)g(V)l(erma)e(and)j(P)o(earl)f(\(1992\).)22
-b(I)14 b(consider)164 917 y(the)perm(more)f(realistic)g(case)h(where)g
+b(I)14 b(consider)164 917 y(the)k(more)f(realistic)g(case)h(where)g
 (the)g(mo)q(deler)f(ma)o(y)g(ha)o(v)o(e)h(additional)g(information)164
-978 y(ab)q(out)perm(causal)g(relationships.)35 b(The)21
+978 y(ab)q(out)k(causal)g(relationships.)35 b(The)21
 b(source)g(of)g(the)g(bac)o(kground)g(kno)o(wledge)f(ma)o(y)164
 1038 y(b)q(e)i(prior)g(exp)q(erience)f(of)h(the)g(existence)e(or)j
 (non-existence)e(of)h(a)h(causal)f(relation-)164 1098
 y(ship,)c(or)g(kno)o(wledge)f(of)h(temp)q(oral)f(ordering)h(among)f
 (the)h(v)m(ariables.)25 b(Question)18 b(\(ii\))164 1158
 y(is)c(a)g(fundamen)o(tal)f(question)h(ab)q(out)i(the)d(exten)o(t)g(to)
-i(whic)o(h)e(causal)i(relationships)f(can)164 1218 y(b)q(e)perm(inferred)e
+i(whic)o(h)e(causal)i(relationships)f(can)164 1218 y(b)q(e)k(inferred)e
 (from)h(a)h(set)g(of)g(indep)q(endence)e(facts)i(giv)o(en)f(the)h
 (assumptions)f(relating)164 1279 y(directed)e(graphs,)i(causalit)o(y)l
 (,)e(and)i(statistics)f(hold.)164 1423 y Fp(1.1)66 b(De\014nitions)164
-1515 y Fs(A)11 b Fo(dep)n(endency)perm(mo)n(del)c Fs(is)g(a)h(list)f
+1515 y Fs(A)11 b Fo(dep)n(endency)k(mo)n(del)c Fs(is)g(a)h(list)f
 Fn(M)h Fs(of)g(conditional)f(indep)q(endence)f(statemen)o(ts)g(of)i
 (the)164 1576 y(form)g Fm(A)p Fn(?)-8 b(?)o Fm(B)p Fn(j)p
 Fm(S)13 b Fs(where)f Fm(A)p Fs(,)h Fm(B)p Fs(,)g(and)h
@@ -1696,20 +1696,20 @@ Fn(i)20 b Fs(where)164 1696 y Fm(V)e Fs(is)f(a)g(set)g(of)g(v)o
 b(A)16 b Fo(p)n(artial)r(ly)i(dir)n(e)n(cte)n(d)g(gr)n(aph)e
 Fs(is)h(a)164 1756 y(graph)h(whic)o(h)e(ma)o(y)g(ha)o(v)o(e)g(b)q(oth)i
 (undirected)e(and)i(directed)e(edges)h(and)g(has)h(at)g(most)164
-1816 y(one)perm(edge)g(b)q(et)o(w)o(een)f(an)o(y)h(pair)f(of)i(v)o
+1816 y(one)k(edge)g(b)q(et)o(w)o(een)f(an)o(y)h(pair)f(of)i(v)o
 (ertices.)36 b(A)21 b(partially)g(directed)g(graph)i(is)f(said)164
 1876 y(to)c(b)q(e)g Fo(dir)n(e)n(cte)n(d)f Fs(if)g(and)h(only)g(if)f
 (there)g(are)g(no)i(undirected)d(edges)i(in)f(the)h(graph)g(and)164
 1937 y(a)i(partially)e(directed)g(graph)j(is)e Fo(undir)n(e)n(cte)n(d)g
 Fs(if)g(and)h(only)f(if)g(there)g(are)g(no)h(directed)164
 1997 y(edges)c(in)f(the)h(graph.)22 b Fk(A)13 b Fn(!)h
-Fk(B)perm Fs(if)d(and)h(only)g(if)f(there)g(is)h(a)g(directed)e(edge)i(b)q
+Fk(B)k Fs(if)d(and)h(only)g(if)f(there)g(is)h(a)g(directed)e(edge)i(b)q
 (et)o(w)o(een)e Fk(A)164 2057 y Fs(and)i Fk(B)j Fs(and)d
 Fk(A)g Fs(|)g Fk(B)j Fs(if)c(and)i(only)e(if)h(there)f(is)h(an)g
 (undirected)f(edge)h(b)q(et)o(w)o(een)f Fk(A)g Fs(and)164
 2117 y Fk(B)s Fs(.)20 b(The)c(paren)o(ts)f(of)g(a)h(v)o(ertex)e
 Fk(A)g Fs(\(written)h Fk(pa)p Fs(\()p Fk(A)p Fs(\)\))g(is)g(the)g(set)g
-(of)g(v)o(ertices)f(suc)o(h)g(that)164 2177 y(there)perm(is)g(a)h
+(of)g(v)o(ertices)f(suc)o(h)g(that)164 2177 y(there)k(is)g(a)h
 (directed)e(edge)h(from)g(the)g(v)o(ertex)f(to)h Fk(A)p
 Fs(.)28 b(The)18 b(adjacencies)g(of)g(v)o(ertex)f Fk(A)164
 2238 y Fs(\(written)f Fk(AD)q(J)5 b Fs(\()p Fk(A)p Fs(\)\))15
@@ -1727,27 +1727,27 @@ Fi(B)g Fq(giv)o(en)g Fi(S)g Fq(and)h(is)f(equiv)n(alen)o(t)g(to)164
 Fm(V)i Fs(the)f(set)g(of)g(v)o(ertices)e(in)i Fo(G)p
 Fs(.)f(The)h(pair)g Fn(h)p Fk(P)q(;)8 b Fo(G)t Fn(i)27
 b Fs(sat-)164 376 y(isfy)c(the)g Fo(Markov)h(c)n(ondition)g
-Fs(with)g(resp)q(ect)f(to)h(acyclic)d(graph)perm Fo(G)e
+Fs(with)g(resp)q(ect)f(to)h(acyclic)d(graph)k Fo(G)e
 Fs(if)g(and)h(only)f(if)164 436 y Fk(P)7 b Fs(\()p Fm(V)q
-Fs(\))14 b(=)349 403 y Fh(alpha)388 446 y Fg(A)p Ff(2)p Fe(V)480
+Fs(\))14 b(=)349 403 y Fh(Q)388 446 y Fg(A)p Ff(2)p Fe(V)480
 436 y Fk(P)7 b Fs(\()p Fk(A)p Fn(j)p Fk(pa)p Fs(\()p
 Fk(A)p Fs(\)\).)746 418 y Fl(2)785 436 y Fs(The)15 b(condition)g
 (states)g(that)g(the)g(join)o(t)f(distribution)164 496
 y(factors)j(in)o(to)f(conditional)g(distributions)g(according)h(to)g
 (the)f(graphical)h(structure)f(of)164 556 y Fo(G)p Fs(.)g
-Fk(M)5 b(ar)q(perm)r(ov)r Fs(\()p Fo(G)t Fs(\))18 b(is)f(the)g(set)g(of)h
+Fk(M)5 b(ar)q(k)r(ov)r Fs(\()p Fo(G)t Fs(\))18 b(is)f(the)g(set)g(of)h
 (distributions)f(that)g(satisfy)h(the)f(Mark)o(o)o(v)f(condition)164
 616 y(with)h(resp)q(ect)f(to)i Fo(G)p Fs(.)e(Tw)o(o)i(graphs,)p
 Fo(G)f Fs(and)h Fo(G)1030 598 y Ff(0)1058 616 y Fs(are)f(Mark)o(o)o(v)g
 (equiv)m(alen)o(t)e(if)i(and)g(only)164 677 y(if)f Fk(M)5
-b(ar)q(perm)r(ov)r Fs(\()p Fo(G)t Fs(\))14 b(=)f Fk(M)5
-b(ar)q(perm)r(ov)r Fs(\()p Fo(G)769 659 y Ff(0)781 677 y
+b(ar)q(k)r(ov)r Fs(\()p Fo(G)t Fs(\))14 b(=)f Fk(M)5
+b(ar)q(k)r(ov)r Fs(\()p Fo(G)769 659 y Ff(0)781 677 y
 Fs(\).)22 b Fo(G)15 b Fs(en)o(tail)h(that)g Fm(A)h Fs(is)f(indep)q
 (enden)o(t)f(of)h Fm(B)g Fs(giv)o(en)g Fm(S)164 737 y
 Fs(\(written)f Fo(G)j Fn(j)-8 b Fs(=)13 b Fm(A)p Fn(?)-8
 b(?)p Fm(B)p Fn(j)p Fm(S)p Fs(\))15 b(if)g(and)i(only)e(if)g
 Fm(A)p Fn(?)-8 b(?)p Fm(B)p Fn(j)p Fm(S)15 b Fs(is)h(true)f(in)g(ev)o
-(ery)f(distribution)164 797 y(in)g Fk(M)5 b(ar)q(perm)r(ov)r
+(ery)f(distribution)164 797 y(in)g Fk(M)5 b(ar)q(k)r(ov)r
 Fs(\()p Fo(G)t Fs(\).)21 b(It)13 b(is)h(easy)h(to)f(sho)o(w)h(that)f
 (the)g(set)g(of)h(en)o(tailed)e(indep)q(endence)g(facts)164
 857 y(for)19 b(t)o(w)o(o)g(Mark)o(o)o(v)f(equiv)m(alen)o(t)g(graphs)i
@@ -1763,7 +1763,7 @@ Fs(for)h(the)f(partially)g(directed)f(graph)j Fo(G)e
 Fs(is)h(the)f(graph)h(whic)o(h)f(has)164 1218 y(the)15
 b(iden)o(tical)f(adjacencies)h(as)h Fo(G)f Fs(and)h(whic)o(h)f(has)h
 (an)g(orien)o(ted)e(edge)h Fk(A)f Fn(!)f Fk(B)18 b Fs(if)d(and)164
-1279 y(only)perm(if)f(there)h(is)f(a)i(v)o(ertex)d Fk(C)22
+1279 y(only)k(if)f(there)h(is)f(a)i(v)o(ertex)d Fk(C)22
 b Fn(62)d Fk(AD)q(J)5 b Fs(\()p Fk(A)p Fs(\))18 b(suc)o(h)h(that)g
 Fk(A)14 b Fn(!)f Fk(B)22 b Fs(and)e Fk(C)d Fn(!)c Fk(B)22
 b Fs(in)d Fo(G)p Fs(.)164 1339 y(Let)c Fk(patter)q(n)p
@@ -1771,7 +1771,7 @@ Fs(\()p Fo(G)t Fs(\))g(denote)g(the)g(pattern)g(for)h
 Fo(G)p Fs(.)e(A)h(triple)f Fn(h)p Fk(A;)8 b(B)s(;)g(C)t
 Fn(i)14 b Fs(is)h(an)h Fo(unshielde)n(d)164 1399 y(c)n(ol)r(lider)h
 Fs(in)e Fo(G)h Fs(if)f(and)h(only)g(if)f Fk(A)e Fn(!)h
-Fk(B)r Fs(,)i Fk(C)h Fn(!)d Fk(B)perm Fs(and)e Fk(A)g Fs(is)f(not)h
+Fk(B)r Fs(,)i Fk(C)h Fn(!)d Fk(B)k Fs(and)e Fk(A)g Fs(is)f(not)h
 (adjacen)o(t)g(to)g Fk(B)s Fs(.)21 b(It)15 b(is)164 1459
 y(easy)i(to)h(sho)o(w)g(that)g(t)o(w)o(o)f(directed)f(acyclic)g(graphs)
 j(ha)o(v)o(e)d(the)i(same)e(pattern)h(if)g(and)164 1519
@@ -1836,21 +1836,21 @@ b(Giv)o(en)15 b(that)h(there)g(is)g(a)g(complete)e(causal)i
 y(causal)h(relationships)f(common)e(to)i(ev)o(ery)f(complete)f(causal)j
 (explanation?)186 1366 y(\(D\))25 b(Giv)o(en)e(that)h(there)f(is)g(a)h
 (complete)e(causal)i(explanation)f(for)h Fn(M)g Fs(what)g(are)286
-1426 y(the)16 b(causal)g(relationships)g(common)d(to)perm(ev)o(ery)d
+1426 y(the)16 b(causal)g(relationships)g(common)d(to)k(ev)o(ery)d
 (complete)g(causal)i(explanation)286 1486 y(consisten)o(t)g(with)g
 (resp)q(ect)g(to)g(a)h(set)f(of)h(bac)o(kground)g(kno)o(wledge)e
 Fn(K)q Fs(?)237 1581 y(Problems)21 b(\(A\))h(and)h(\(C\))g(are)f(just)h
 (sp)q(ecial)f(cases)g(of)h(problems)e(\(B\))h(and)h(\(D\))164
-1642 y(resp)q(ectiv)o(ely)l(.)38 b(V)l(erma)20 b(and)perm(P)o(earl)e
+1642 y(resp)q(ectiv)o(ely)l(.)38 b(V)l(erma)20 b(and)k(P)o(earl)e
 (\(1992\))i(ha)o(v)o(e)d(giv)o(en)h(an)h(algorithm)f(to)h(answ)o(er)164
 1702 y(problem)15 b(\(A\).)164 1845 y Fp(1.3)66 b(Ov)n(erview)23
 b(of)f(solutions)164 1937 y Fs(In)12 b(this)g(section)g(I)g(will)f
 (outline)h(solutions)g(of)h(problems)e(\(B\))h(and)h(\(D\).)f(The)g
-(algorithm)164 1998 y(for)perm(solving)h(problem)d(\(B\))i(consists)h(of)f
+(algorithm)164 1998 y(for)k(solving)h(problem)d(\(B\))i(consists)h(of)f
 (the)g(follo)o(wing)g(four)h(phases.)95 2103 y(Phase)g(1)25
 b(Examine)14 b(indep)q(endence)g(statemen)o(ts)h(in)g
 Fn(M)g Fs(and)i(try)e(to)h(construct)g(the)f(pat-)286
-2163 y(tern)perm(of)g(some)f(directed)g(acyclic)g(graph)i
+2163 y(tern)k(of)g(some)f(directed)g(acyclic)g(graph)i
 Fo(G)p Fs(.)e(Let)i(\005)1266 2170 y Fl(1)1304 2163 y
 Fs(b)q(e)f(the)g(result)g(of)g(Phase)286 2223 y(1.)95
 2323 y(Phase)e(2)25 b(T)l(ry)20 b(to)g(extend)f(\005)644
@@ -1862,7 +1862,7 @@ Fn(K)q Fs(.)33 b(Let)20 b(\005)1606 2330 y Fl(2)1645
 (G)f(extension)h(of)h(\005)1677 2489 y Fl(2)1696 2482
 y Fs(.)961 2607 y(4)p eop
 %%Page: 5 5
-5 4 bop 95 315 a Fs(Phase)17 b(4)25 b(Chec)o(perm)15 b(whether)h(\005)656
+5 4 bop 95 315 a Fs(Phase)17 b(4)25 b(Chec)o(k)15 b(whether)h(\005)656
 322 y Fl(3)692 315 y Fs(is)g(a)g(complete)e(causal)j(explanation)f(for)
 h Fn(M)p Fs(.)237 430 y(The)i(solution)g(to)g(problem)e(\(D\))h(and)h
 (th)o(us)g(problem)e(\(C\))i(is)f(closely)g(related)g(to)164
@@ -1887,7 +1887,7 @@ Fn(M)p Fs(.)20 b(This)14 b(is)f(accomplished)f(in)h(t)o(w)o(o)g(steps)g
 (describ)q(ed)164 1608 y(b)q(elo)o(w.)21 b(A)14 b(triple)g
 Fn(h)p Fk(A;)8 b(B)s(;)g(C)t Fn(i)15 b Fs(is)f(said)i(to)f(b)q(e)h
 Fo(unshielde)n(d)g Fs(if)e(and)i(only)f(if)f Fk(A)h Fs(is)g(adjacen)o
-(t)164 1668 y(to)i Fk(B)s Fs(,)e Fk(B)perm Fs(is)d(adjacen)o(t)g(to)h
+(t)164 1668 y(to)i Fk(B)s Fs(,)e Fk(B)k Fs(is)d(adjacen)o(t)g(to)h
 Fk(C)i Fs(and)e Fk(A)f Fs(is)g(not)h(adjacen)o(t)f(to)g
 Fk(C)t Fs(.)126 1782 y(Step)g(1)25 b(F)l(orm)15 b(an)h(undirected)f
 (graph)i Fo(G)f Fs(b)o(y)g(the)f(follo)o(wing)h(rule.)21
@@ -1941,7 +1941,7 @@ V 1426 409 V 1426 415 2 3 v 1426 421 V 1426 427 V 1426
 b(rules)f(for)i(graphs)237 771 y(A)g(brief)f(explanation)i(of)f(the)g
 (sc)o(hematic)e(rules)i(in)g(Figure)f(1.)25 b(Eac)o(h)17
 b(orien)o(tation)164 831 y(rule)j(consists)h(of)g(a)g(pair)g(of)g(sc)o
-(hematic)d(graphs.)35 b(A)21 b(sc)o(hematic)d(graph)perm(matc)o(hes)d(a)
+(hematic)d(graphs.)35 b(A)21 b(sc)o(hematic)d(graph)k(matc)o(hes)d(a)
 164 891 y(pattern)14 b(\005)372 873 y Ff(0)396 891 y
 Fs(if)f(there)g(exists)g(a)h(set)g(of)f(v)o(ertices)f(D)i(in)f(\005)
 1172 873 y Ff(0)1197 891 y Fs(and)h(a)g(bijectiv)o(e)d(mapping)i(\()p
@@ -1950,7 +1950,7 @@ Fk(f)5 b Fs(\))164 952 y(from)13 b(the)h(v)o(ertices)f(in)h(the)g(sc)o
 (ertices)164 1012 y(are)f(adjacen)o(t)g(in)g(the)g(sc)o(hematic)e(if)h
 (and)i(only)f(if)g(the)g(corresp)q(onding)h(pair)f(of)h(v)o(ertices)164
 1072 y(are)f(adjacen)o(t)g(in)g(\005)528 1054 y Ff(0)554
-1072 y Fs(and)g(\(ii\))g(if)f Fk(A)h Fn(!)f Fk(B)perm Fs(in)d(the)g(sc)o
+1072 y Fs(and)g(\(ii\))g(if)f Fk(A)h Fn(!)f Fk(B)k Fs(in)d(the)g(sc)o
 (hematic)e(then)i(the)g(corresp)q(onding)164 1132 y(edge)h(is)g(orien)o
 (ted)g Fk(f)5 b Fs(\()p Fk(A)p Fs(\))13 b Fn(!)h Fk(f)5
 b Fs(\()p Fk(B)s Fs(\))15 b(in)g(\005)906 1114 y Ff(0)933
@@ -1964,7 +1964,7 @@ Fn(!)c Fk(A)22 b Fs(app)q(ears)g(in)g(\005)1599 1235
 y Ff(0)1610 1253 y Fs(.)37 b(If)21 b(the)164 1313 y(sc)o(hematic)12
 b(to)i(the)g(left)f(of)i(the)f Fn(\))g Fs(matc)o(hes)e(pattern)j(\005)
 1203 1295 y Ff(0)1228 1313 y Fs(then)f(orien)o(t)g(the)g(unorien)o(ted)
-164 1373 y(edges)perm(in)f(\005)391 1355 y Ff(0)420 1373
+164 1373 y(edges)k(in)f(\005)391 1355 y Ff(0)420 1373
 y Fs(according)h(to)g(the)f(orien)o(ted)g(edges)h(in)f(the)h(sc)o
 (hematic)d(to)j(the)f(righ)o(t)h(of)164 1433 y(the)e
 Fn(\))p Fs(.)237 1493 y(Giv)o(en)f(the)h(rule)g(in)g(Figure)g(1)g
@@ -1984,13 +1984,13 @@ Fn(i)20 b Fs(b)q(e)f(the)f(bac)o(kground)i(kno)o(wledge)e(and)h(let)f
 (\005)1382 2254 y Fl(2)p Fg(:)p Fl(1)1447 2247 y Fs(b)q(e)h(the)g
 (partially)164 2307 y(directed)c(graph)i(obtained)g(from)e(phase)i
 (2.1.)88 2421 y(Step)f(1.1)25 b(If)15 b(there)g(is)g(an)h(edge)f
-Fk(A)e Fn(!)h Fk(B)perm Fs(in)d Fk(F)22 b Fs(suc)o(h)15
-b(that)h Fk(A)d Fn(!)h Fk(B)perm Fs(is)d(in)g(\005)1486
+Fk(A)e Fn(!)h Fk(B)k Fs(in)d Fk(F)22 b Fs(suc)o(h)15
+b(that)h Fk(A)d Fn(!)h Fk(B)k Fs(is)d(in)g(\005)1486
 2428 y Fl(2)p Fg(:)p Fl(1)1548 2421 y Fs(then)g(F)-5
 b(AIL.)961 2607 y(6)p eop
 %%Page: 7 7
 7 6 bop 88 315 a Fs(Step)16 b(1.2)25 b(If)15 b(there)g(is)h(an)g(edge)g
-Fk(A)d Fn(!)h Fk(B)perm Fs(in)e Fk(R)g Fs(suc)o(h)f(that)i
+Fk(A)d Fn(!)h Fk(B)k Fs(in)e Fk(R)g Fs(suc)o(h)f(that)i
 Fk(B)f Fn(!)e Fk(A)h Fs(is)h(in)f(\005)1490 322 y Fl(2)p
 Fg(:)p Fl(1)1552 315 y Fs(or)i Fk(A)e Fs(is)g(not)286
 376 y(adjacen)o(t)h(to)h Fk(B)h Fs(then)f(F)-5 b(AIL.)126
@@ -2006,7 +2006,7 @@ b Fk(R)g Fs(is)h(not)f(empt)o(y)e(then)i(go)h(to)g(Step)f(1.)237
 (causal)j(explanation)f(for)g Fn(M)164 903 y Fs(consisten)o(t)16
 b(with)g Fn(K)q Fs(.)164 1046 y Fp(2.3)66 b(Correctness)164
 1138 y Fs(By)13 b(assumption)g(there)g(is)h(a)g(directed)f(acyclic)e
-(graph)perm Fo(G)f Fs(whic)o(h)f(is)g(a)h(complete)e(causal)164
+(graph)k Fo(G)f Fs(whic)o(h)f(is)g(a)h(complete)e(causal)164
 1199 y(explanation)17 b(for)g Fn(M)p Fs(.)578 1181 y
 Fl(4)620 1199 y Fs(Since)f(a)h(graph)g Fo(G)969 1181
 y Ff(0)998 1199 y Fs(whic)o(h)f(is)h(Mark)o(o)o(v)e(equiv)m(alen)o(t)h
@@ -2015,39 +2015,39 @@ y Ff(0)998 1199 y Fs(whic)o(h)f(is)h(Mark)o(o)o(v)e(equiv)m(alen)o(t)h
 (complete)d(causal)i(explanation)164 1319 y(for)j Fn(M)p
 Fs(.)20 b(An)o(y)13 b(graph)j Fo(G)612 1301 y Ff(0)638
 1319 y Fs(whic)o(h)d(is)i(not)f(Mark)o(o)o(v)g(equiv)m(alen)o(t)f(to)h
-Fo(G)h Fs(is)f(not)g(a)h(complete)164 1379 y(causal)perm(explanation)f
+Fo(G)h Fs(is)f(not)g(a)h(complete)164 1379 y(causal)k(explanation)f
 (for)g Fn(M)p Fs(;)h(either)e Fo(G)930 1361 y Ff(0)960
 1379 y Fs(di\013ers)h(from)f Fo(G)h Fs(b)o(y)g(\(i\))g(an)h(adjacency)f
 (b)q(e-)164 1439 y(t)o(w)o(een)f Fk(A)g Fs(and)h Fk(B)i
-Fs(in)e(whic)o(h)e(case)i(for)g(some)f(set)g Fk(S)perm Fs(it)c(is)g(the)h
+Fs(in)e(whic)o(h)e(case)i(for)g(some)f(set)g Fk(S)k Fs(it)c(is)g(the)h
 (case)f(that)h Fk(A)p Fn(?)-8 b(?)o Fk(B)s Fn(j)p Fk(S)20
 b Fs(is)164 1500 y(en)o(tailed)14 b(in)i(one)f(but)h(not)g(the)g(other)
 f(graph)i(and)f(\(ii\))f(there)g(is)g(an)h(unshielded)f(triple)164
 1560 y Fn(h)p Fk(A;)8 b(B)s(;)g(C)t Fn(i)18 b Fs(whic)o(h)g(is)h(a)g
 (orien)o(ted)f Fk(A)13 b Fn(!)h Fk(B)21 b Fs(and)f Fk(C)d
 Fn(!)d Fk(B)21 b Fs(in)e(one)g(but)g(not)g(the)g(other)164
-1620 y(graph)perm(in)e(whic)o(h)g(case)h(there)f(is)h(a)g(set)g
+1620 y(graph)k(in)e(whic)o(h)g(case)h(there)f(is)h(a)g(set)g
 Fm(S)g Fs(whic)o(h)f(do)q(es)i(not)f(include)e Fk(B)25
 b Fs(suc)o(h)c(that)164 1680 y Fk(A)p Fn(?)-8 b(?)o Fk(C)t
 Fn(j)p Fm(S)15 b Fs(in)h(one)g(but)g(not)g(the)g(other)g(graph.)22
 b(The)16 b(correctness)g(of)g(phase)h(1)f(follo)o(ws)164
 1740 y(from)d(the)i(correctness)f(of)h(the)f(PC)h(algorithm)f
 (\(Spirtes)g(et)g(al.)g(1993\))i(or)f(the)f(correct-)164
-1800 y(ness)perm(of)h(the)f(algorithm)f(presen)o(ted)g(in)h(V)l(erma)e
+1800 y(ness)k(of)h(the)f(algorithm)f(presen)o(ted)g(in)h(V)l(erma)e
 (and)j(P)o(earl)e(\(1992\))j(whic)o(h)d(is)h(closely)164
 1861 y(related)h(to)h(the)f(IC)g(algorithm.)30 b(Ho)o(w)o(ev)o(er,)18
 b(the)h(PC)h(algorithm)e(is)h(more)f(judicious)164 1921
 y(than)c(the)f(algorithm)f(presen)o(ted)g(in)h(phase)g(1)h(with)f(resp)
 q(ect)g(to)g(the)g(n)o(um)o(b)q(er)f(and)h(t)o(yp)q(e)164
-1981 y(of)perm(indep)q(endence)e(facts)h(whic)o(h)g(need)g(to)g(b)q(e)h(c)
-o(hec)o(perm)o(ed,)c(whic)o(h,)i(in)h(practice,)f(leads)i(to)164
+1981 y(of)k(indep)q(endence)e(facts)h(whic)o(h)g(need)g(to)g(b)q(e)h(c)
+o(hec)o(k)o(ed,)c(whic)o(h,)i(in)h(practice,)f(leads)i(to)164
 2041 y(an)f(e\016cien)o(t)d(implem)o(en)o(tati)o(on)g(with)i(nice)g
 (statistical)f(prop)q(erties)i(\(see)f(Spirtes)f(et)h(al.)164
 2101 y(1993\).)237 2162 y(Giv)o(en)i(that)h(w)o(e)f(ha)o(v)o(e)g(found)
 i(the)e(correct)g(pattern)h(in)f(phase)i(1)f(w)o(e)f(can)h(restate)164
 2222 y(problems)c(\(C\))i(and)g(\(D\).)f(T)l(o)h(solv)o(e)f(problem)f
 (\(C\))h(w)o(e)g(m)o(ust)f(\014nd)i(all)f(of)h(the)f(orien)o(ta-)164
-2282 y(tions)i(common)f(to)h(Mark)o(o)o(v)g(equiv)m(alen)o(t)e(graphs)perm
+2282 y(tions)i(common)f(to)h(Mark)o(o)o(v)g(equiv)m(alen)o(t)e(graphs)k
 (with)e(the)g(pattern)g(obtained)h(from)164 2342 y(phase)f(1.)23
 b(T)l(o)18 b(solv)o(e)e(problem)f(\(D\))i(w)o(e)f(m)o(ust)f(\014nd)j
 (all)e(of)h(the)f(orien)o(tations)h(common)p 164 2387
@@ -2061,7 +2061,7 @@ b(T)l(o)18 b(solv)o(e)e(problem)f(\(D\))i(w)o(e)f(m)o(ust)f(\014nd)j
 (with)e(the)h(pattern)f(obtained)h(from)f(phase)h(1)g(with)164
 376 y(the)13 b(additional)h(restriction)f(that)h(the)f(orien)o(tations)
 g(agree)h(with)g(the)f(edges)h(in)f Fn(K)q Fs(,)g(the)164
-436 y(bac)o(kground)perm(kno)o(wledge.)perm(The)16 b(follo)o(wing)g
+436 y(bac)o(kground)k(kno)o(wledge.)k(The)16 b(follo)o(wing)g
 (de\014nition)g(formalizes)e(these)i(notions.)237 496
 y(The)g Fo(maximal)r(ly)j(oriente)n(d)e(gr)n(aph)f Fs(for)g(pattern)g
 Fo(G)g Fs(with)g(resp)q(ect)g(to)h(a)f(consisten)o(t)164
@@ -2080,7 +2080,7 @@ Fk(A)13 b Fn(!)h Fk(B)24 b Fs(in)d Fo(G)623 744 y Fl(1)664
 744 y Fl(2)1058 737 y Fs(,)i(\(ii\))d(ev)o(ery)g(edge)h(in)g
 Fm(R)h Fs(is)f(orien)o(ted)164 797 y(correctly)15 b(in)g
 Fk(max)p Fs(\()p Fo(G)t Fk(;)8 b Fn(K)q Fs(\),)14 b(and)j(\(iii\))d(no)
-j(edge)f Fk(A)d Fn(!)h Fk(B)perm Fs(in)e Fm(F)g Fs(is)g(orien)o(ted)f(as)h
+j(edge)f Fk(A)d Fn(!)h Fk(B)k Fs(in)e Fm(F)g Fs(is)g(orien)o(ted)f(as)h
 Fk(A)e Fn(!)f Fk(B)164 857 y Fs(in)j Fk(max)p Fs(\()p
 Fo(G)t Fk(;)8 b Fn(K)q Fs(\).)237 917 y(An)15 b(orien)o(tation)h(rule)f
 (is)g Fo(sound)h Fs(if)f(and)h(only)f(if)h(an)o(y)f(orien)o(tation)g
@@ -2091,12 +2091,12 @@ b Fo(The)f(four)h(orientation)g(rules)g(given)164 1152
 y(in)18 b(Figur)n(e)f(1)g(ar)n(e)g(sound.)164 1266 y
 Fm(Theorem)g(3)h(\(Orien)n(tation)g(completeness\))j
 Fo(The)13 b(r)n(esult)g(of)f(applying)h(rules)g(R1,)164
-1326 y(R2)perm(and)g(R3)g(to)h(a)f(p)n(attern)h(is)f(a)g(maximal)r(ly)i
+1326 y(R2)k(and)g(R3)g(to)h(a)f(p)n(attern)h(is)f(a)g(maximal)r(ly)i
 (oriente)n(d)e(gr)n(aph.)164 1440 y Fm(Theorem)g(4)h(\(Orien)n(tation)g
 (completeness)e(with)i(Bac)n(kground)h(Kno)n(wledge\))164
 1501 y Fo(L)n(et)c Fn(K)h Fo(b)n(e)g(a)f(set)h(of)f(b)n(ackgr)n(ound)h
 (know)r(le)n(dge)i(c)n(onsistent)f(with)e(p)n(attern)h
-Fs(\005)p Fo(.)21 b(The)16 b(r)n(esult)164 1561 y(of)perm(applying)g
+Fs(\005)p Fo(.)21 b(The)16 b(r)n(esult)164 1561 y(of)k(applying)g
 (rules)g(R1,)g(R2,)g(R3)f(and)h(R4)f(\(and)h(orienting)h(e)n(dges)f(ac)
 n(c)n(or)n(ding)f(to)h Fn(K)q Fo(\))164 1621 y(to)d(a)h(p)n(attern)f
 Fs(\005)g Fo(is)h(a)f(maximal)r(ly)h(oriente)n(d)g(gr)n(aph)f(with)h(r)
@@ -2105,7 +2105,7 @@ n(esp)n(e)n(ct)e(to)i Fn(K)q Fo(.)237 1735 y Fs(The)e(pro)q(ofs)i(of)f
 1902 y Ft(3)81 b(Existence)25 b(of)i(complete)g(causal)f(explanations)
 164 2011 y Fs(In)20 b(this)g(section)g(I)f(will)g(presen)o(t)h
 (solutions)h(for)f(problems)f(\(A\))h(and)g(\(B\))g(discussed)164
-2071 y(ab)q(o)o(v)o(e.)43 b(As)23 b(men)o(tioned)e(ab)q(o)o(v)o(e,)perm(V)
+2071 y(ab)q(o)o(v)o(e.)43 b(As)23 b(men)o(tioned)e(ab)q(o)o(v)o(e,)k(V)
 l(erma)c(and)j(P)o(earl)f(\(1992\))i(ga)o(v)o(e)e(a)h(solution)g(to)164
 2131 y(problem)19 b(\(A\).)g(Their)g(solution)i(of)f(problem)f(\(A\))g
 (consists)i(essen)o(tially)d(of)j(phase)g(1)164 2192
@@ -2122,7 +2122,7 @@ b(not)f(solv)o(e)e(problem)h(\(B\)\).)f(The)i(mo)q(di\014cation)164
 408 y Fs(The)15 b(solution)g(to)g(problem)e(\(B\))h(subsumes)g(the)h
 (solution)g(to)g(problem)e(\(A\);)g(problem)164 468 y(\(A\))h(is)h(the)
 f(instance)h(of)g(problem)e(\(B\))h(where)h(w)o(e)f(ha)o(v)o(e)g(no)h
-(bac)o(kground)h(kno)o(wledge.)164 528 y(The)perm(solution)h(of)g(problem)
+(bac)o(kground)h(kno)o(wledge.)164 528 y(The)k(solution)h(of)g(problem)
 d(\(B\))i(consists)h(of)g(four)g(phases.)34 b(The)20
 b(\014rst)h(t)o(w)o(o)f(phases)164 588 y(\(phase)c(1)g(and)h(phase)f
 (2\))g(ha)o(v)o(e)f(b)q(een)h(describ)q(ed)f(ab)q(o)o(v)o(e)h(and)g
@@ -2137,14 +2137,14 @@ Fl(2)407 1045 y Fs(has)h(no)g(unorien)o(ted)e(edges)i(then)f(STOP)126
 1147 y(Step)g(2)25 b(Cho)q(ose)18 b(an)e(unorien)o(ted)g(edge)g
 Fk(A)g Fs(|)g Fk(B)j Fs(from)c(\005)1203 1154 y Fl(2)126
 1249 y Fs(Step)h(3)25 b(Orien)o(t)13 b(edge)h Fk(A)g
-Fn(!)f Fk(B)perm Fs(and)e(close)f(orien)o(tations)g(under)h(rules)f(R1,)g
+Fn(!)f Fk(B)k Fs(and)e(close)f(orien)o(tations)g(under)h(rules)f(R1,)g
 (R2,)h(R3,)f(and)286 1309 y(R4.)126 1411 y(Step)i(4)25
 b(Go)17 b(to)f(Step)h(1.)237 1525 y(The)e(signi\014can)o(t)g
 (di\013erence)f(b)q(et)o(w)o(een)g(the)h(V)l(erma)e(and)j(P)o(earl)e
 (\(1992\))j(algorithm)164 1585 y(is)d(that)h(their)e(algorithm)h(has)h
-(the)f(p)q(oten)o(tial)g(for)h(bac)o(ktrac)o(king.)perm(Eac)o(h)14
+(the)f(p)q(oten)o(tial)g(for)h(bac)o(ktrac)o(king.)k(Eac)o(h)14
 b(time)f(that)h(an)164 1645 y(edge)g(is)g(orien)o(ted)f(in)h(step)g(3)g
-(the)g(edge)g(had)h(to)f(b)q(e)g(pushed)h(on)o(to)f(a)h(stac)o(perm)f(in)f
+(the)g(edge)g(had)h(to)f(b)q(e)g(pushed)h(on)o(to)f(a)h(stac)o(k)f(in)f
 (case)h(that)164 1705 y(the)h(sp)q(eci\014c)g(c)o(hoice)f(of)i(orien)o
 (tation)f(could)g(not)h(b)q(e)g(extended)e(to)i(a)g(consisten)o(t)f(D)o
 (A)o(G)164 1765 y(extension)f(of)g(\005)468 1772 y Fl(2)488
@@ -2158,7 +2158,7 @@ Fm(3.1.2)55 b(Phase)19 b(4)164 2108 y Fs(Let)d(\005)288
 2222 y Fs(is)g(cyclic)e(then)i(F)-5 b(AIL)126 2324 y(Step)16
 b(2)25 b(T)l(est)16 b(that)h(ev)o(ery)e(statemen)o(t)f(I)i(in)g
 Fn(M)g Fs(is)g(en)o(tailed)f(b)o(y)h(\005)1358 2331 y
-Fl(3)1393 2324 y Fs(\(i.e.)perm(\005)1533 2331 y Fl(3)1566
+Fl(3)1393 2324 y Fs(\(i.e.)k(\005)1533 2331 y Fl(3)1566
 2324 y Fn(j)-8 b Fs(=)14 b Fk(I)t Fs(\).)961 2607 y(9)p
 eop
 %%Page: 10 10
@@ -2166,7 +2166,7 @@ eop
 Fs(b)q(e)g(a)h(total)f(ordering)h(of)f(the)g(no)q(des)h(of)g(\005)1263
 322 y Fl(3)1303 315 y Fs(whic)o(h)f(agrees)g(with)g(the)286
 376 y(orien)o(tations)16 b(in)g(\005)647 383 y Fl(3)667
-376 y Fs(,)g(i.e.)perm Fk(A)14 b Fn(!)f Fk(B)19 b Fs(implies)14
+376 y Fs(,)g(i.e.)k Fk(A)14 b Fn(!)f Fk(B)19 b Fs(implies)14
 b(that)j Fk(A)d Fn(\036)g Fk(B)s Fs(.)21 b(Let)c Fk(A)1527
 383 y Ff(\036)1572 376 y Fs(b)q(e)g(the)f(set)286 436
 y(of)h(v)o(ertices)f(whic)o(h)g(are)h(b)q(efore)g Fk(A)g
@@ -2247,7 +2247,7 @@ b(phases)i(2.1)g(and)g(3)f(giv)o(es)g(us)h(an)g(algorithm)e(whic)o(h)h
 Fs(\()p Fo(H)8 b Fs(\))18 b(=)f Fo(G)t Fs(.)29 b(This)19
 b(is)f(of)h(use)164 1126 y(for)f(at)g(least)f(the)h(follo)o(wing)f
 (reason.)27 b(Information)16 b(scores)i(\(MDL,)g(AIC,)e(and)j(BIC\))164
-1186 y(and)c(the)g(scores)g(prop)q(osed)h(b)o(y)e(Hec)o(perm)o(erm)o(an)e
+1186 y(and)c(the)g(scores)g(prop)q(osed)h(b)o(y)e(Hec)o(k)o(erm)o(an)e
 (et)j(al.)f(\(1994\))i(are)f(iden)o(tical)e(for)i(Mark)o(o)o(v)164
 1247 y(equiv)m(alen)o(t)21 b(mo)q(dels.)39 b(These)23
 b(scores)g(are)f(used)h(as)g(the)g(basis)g(of)g(mo)q(del)e(selection)
@@ -2261,13 +2261,13 @@ b(graphs)164 1664 y Fs(A)10 b Fo(cycle)j Fs(in)d(a)h(partially)f
 Fn(h)p Fk(A)1519 1671 y Fl(1)1539 1664 y Fk(;)f(A)1598
 1671 y Fl(2)1617 1664 y Fk(;)g(:)g(:)g(:)f(;)h(A)1763
 1671 y Fg(n)1786 1664 y Fn(i)164 1724 y Fs(with)16 b
-Fk(n)e(>)f Fs(2)perm(suc)o(h)e(that)h(\(i\))g Fk(A)729 1731
+Fk(n)e(>)f Fs(2)k(suc)o(h)e(that)h(\(i\))g Fk(A)729 1731
 y Fl(1)762 1724 y Fs(=)e Fk(A)851 1731 y Fg(n)874 1724
 y Fs(,)h(\(ii\))g(all)g(other)h(pairs)g(of)g(v)o(ertices)e(are)i
 (distinct,)164 1784 y(\(iii\))f(for)h(all)g(1)f Fn(\024)e
 Fk(i)h(<)g(n)i Fs(it)g(is)g(the)g(case)g(that)h(either)e
 Fk(A)1186 1791 y Fg(i)1214 1784 y Fn(!)e Fk(A)1314 1791
-y Fg(i)p Fl(+1)1389 1784 y Fs(or)perm Fk(A)1486 1791 y Fg(i)1516
+y Fg(i)p Fl(+1)1389 1784 y Fs(or)k Fk(A)1486 1791 y Fg(i)1516
 1784 y Fs(|)f Fk(A)1618 1791 y Fg(i)p Fl(+1)1693 1784
 y Fs(is)g(in)164 1844 y Fo(G)p Fs(,)f(and)i(\(iv\))f(for)g(some)g(1)e
 Fn(\024)f Fk(i)h(<)g(n)i Fs(it)g(is)g(the)g(case)g(that)h
@@ -2284,9 +2284,9 @@ y(\(1989\))d(and)f(F)l(ryden)o(b)q(erg)e(\(1990\).)164
 2218 y Fm(Lemma)f(1)i Fo(L)n(et)g Fs(\005)525 2225 y
 Fl(0)560 2218 y Fo(b)n(e)g(the)g(r)n(esult)g(of)g(applying)g(the)h
 (orientation)f(rules)h(R1,)e(R2,)h(and)164 2278 y(R3)h(to)g(the)h(p)n
-(attern)g Fs(\005)p Fo(.)perm(In)17 b Fs(\005)723 2285 y
+(attern)g Fs(\005)p Fo(.)k(In)17 b Fs(\005)723 2285 y
 Fl(0)743 2278 y Fo(,)g(if)g Fk(A)d Fn(!)f Fk(B)20 b Fo(and)e
-Fk(B)i Fo(|)d Fk(C)perm Fo(then)e Fk(A)13 b Fn(!)h Fk(C)s
+Fk(B)i Fo(|)d Fk(C)k Fo(then)e Fk(A)13 b Fn(!)h Fk(C)s
 Fo(.)237 2351 y Fs(F)l(rom)e(Lemma)e(1)j(it)g(follo)o(ws)f(that)h(if)g
 (\005)f(is)g(the)h(pattern)g(for)g(a)g(Mark)o(o)o(v)f(equiv)m(alence)
 164 2411 y(class)g(then)g(the)g(graph)h Fk(max)p Fs(\(\005)p
@@ -2301,8 +2301,8 @@ Fs(\))19 b(constitutes)i(a)g(natural)g(w)o(a)o(y)f(to)h(represen)o(t)f
 b(This)12 b(ma)o(y)f(allo)o(w)164 436 y(researc)o(her)18
 b(to)i(dev)o(elop)f(searc)o(h)g(tec)o(hniques)f(for)h(directed)g
 (acyclic)e(represen)o(tations)164 496 y(using)g(c)o(hain)e(graph.)164
-662 y Ft(References)164 772 y Fs(Hec)o(perm)o(erm)o(an,)21
-b(D.,)i(D.)f(Geiger,)h(and)g(D.)f(Chic)o(perm)o(ering)f(\(1994\).)40
+662 y Ft(References)164 772 y Fs(Hec)o(k)o(erm)o(an,)21
+b(D.,)i(D.)f(Geiger,)h(and)g(D.)f(Chic)o(k)o(ering)f(\(1994\).)40
 b(Learning)23 b(Ba)o(y)o(esian)262 832 y(net)o(w)o(orks:)c(The)14
 b(com)o(bination)e(of)i(kno)o(wledge)g(and)g(statistical)f(data.)18
 b(T)l(ec)o(hnical)262 892 y(Rep)q(ort)e(MSR-TR-94-09,)i(Microsoft)e
@@ -2315,8 +2315,8 @@ b(R)n(e)n(asoning)g(in)h(Intel)r(ligent)j(systems)p Fs(.)h(San)18
 b(Mateo:)262 1216 y(Morgan-Kaufmann.)164 1318 y(P)o(earl,)j(J.)f(and)i
 (T.)e(V)l(erma)f(\(1991\).)37 b(A)20 b(theory)h(of)g(inferred)f
 (causation.)35 b(In)21 b(Allen,)262 1378 y(Fik)o(es,)15
-b(and)j(Sandw)o(all)f(\(Eds.\),)f Fo(Principles)perm(of)e(know)r(le)n(dge)
-i(r)n(epr)n(esentation)f(and)262 1438 y(r)n(e)n(asoning:)perm(Pr)n(o)n(c)n
+b(and)j(Sandw)o(all)f(\(Eds.\),)f Fo(Principles)k(of)e(know)r(le)n(dge)
+i(r)n(epr)n(esentation)f(and)262 1438 y(r)n(e)n(asoning:)k(Pr)n(o)n(c)n
 (e)n(e)n(dings)16 b(of)i(the)h(se)n(c)n(ond)e(International)j(c)n
 (onfer)n(enc)n(e)p Fs(,)d(pp.)f(441{)262 1498 y(452.)g(San)h(Mateo:)22
 b(Morgan)17 b(Kaufmann.)164 1600 y(Spirtes,)d(P)l(.,)h(C.)g(Glymour,)e
@@ -2354,10 +2354,10 @@ b(Rule)14 b(R4;)h(If)f(the)h(edge)f(w)o(ere)g(orien)o(ted)164
 863 y Fm(Lemma)16 b(1)24 b Fo(L)n(et)15 b Fs(\005)534
 870 y Fl(0)568 863 y Fo(b)n(e)g(the)h(r)n(esult)f(of)g(applying)g(the)h
 (orientation)f(rules)h(R1,)f(R2,)g(and)164 924 y(R3)i(to)g(the)h(p)n
-(attern)g Fs(\005)p Fo(.)perm(In)17 b Fs(\005)723 931 y
+(attern)g Fs(\005)p Fo(.)k(In)17 b Fs(\005)723 931 y
 Fl(0)743 924 y Fo(,)g(if)g Fk(A)d Fn(!)f Fk(B)20 b Fo(and)e
-Fk(B)i Fo(|)d Fk(C)perm Fo(then)e Fk(A)13 b Fn(!)h Fk(C)s
-Fo(.)164 1038 y Fm(Pro)r(of)perm Fs(|)g(W)l(e)g(sa)o(y)g(that)h(v)o(ertex)
+Fk(B)i Fo(|)d Fk(C)k Fo(then)e Fk(A)13 b Fn(!)h Fk(C)s
+Fo(.)164 1038 y Fm(Pro)r(of)k Fs(|)g(W)l(e)g(sa)o(y)g(that)h(v)o(ertex)
 e Fk(X)22 b Fs(is)c(an)h(ancestor)g(of)f(v)o(ertex)f
 Fk(Y)30 b Fs(with)18 b(resp)q(ect)g(to)164 1098 y(\005)201
 1105 y Fl(0)234 1098 y Fs(if)13 b(there)h(is)f(a)i(path)f(suc)o(h)g
@@ -2366,17 +2366,17 @@ b Fs(to)d Fk(Y)25 b Fs(in)13 b(\005)1645 1105 y Fl(0)1664
 1098 y Fs(.)21 b(The)164 1158 y(orien)o(tations)c(in)f(\005)526
 1165 y Fl(0)563 1158 y Fs(induce)g(a)h(partial)g(ordering)g(on)g(the)g
 (v)o(ertices)e(b)o(y)i(the)f(follo)o(wing)164 1218 y(rule;)f
-Fk(X)perm(<)14 b(Y)27 b Fs(if)16 b Fk(X)21 b Fs(is)16 b(an)h(ancestor)g
+Fk(X)k(<)14 b(Y)27 b Fs(if)16 b Fk(X)21 b Fs(is)16 b(an)h(ancestor)g
 (of)g Fk(Y)11 b Fs(.)22 b(With)16 b(resp)q(ect)g(to)h(this)f(partial)g
 (ordering,)164 1279 y(c)o(ho)q(ose)e(v)o(ertex)d Fk(B)16
 b Fs(to)d(b)q(e)h(a)f(minimal)d(v)o(ertex)h(suc)o(h)i(that)h(there)e
 (are)h(edges)h Fk(A)f Fn(!)h Fk(B)h Fs(and)164 1339 y
-Fk(B)perm Fs(|)d Fk(C)j Fs(in)d(\005)433 1346 y Fl(0)452
+Fk(B)k Fs(|)d Fk(C)j Fs(in)d(\005)433 1346 y Fl(0)452
 1339 y Fs(.)21 b(Note)16 b(that)h Fk(A)c Fn(2)h Fk(AD)q(J)5
 b Fs(\()p Fk(C)t Fs(\))15 b(otherwise)h Fk(B)j Fs(|)d
-Fk(C)perm Fs(w)o(ould)c(b)q(e)g(orien)o(ted)164 1399 y(b)o(y)g(rule)g(R1.)
-24 b(F)l(urthermore,)14 b Fk(A)i Fs(|)g Fk(C)perm Fs(m)o(ust)c(b)q(e)h
-(unorien)o(ted;)f(if)g Fk(A)g Fs(|)g Fk(C)perm Fs(is)d(orien)o(ted)164
+Fk(C)k Fs(w)o(ould)c(b)q(e)g(orien)o(ted)164 1399 y(b)o(y)g(rule)g(R1.)
+24 b(F)l(urthermore,)14 b Fk(A)i Fs(|)g Fk(C)k Fs(m)o(ust)c(b)q(e)h
+(unorien)o(ted;)f(if)g Fk(A)g Fs(|)g Fk(C)k Fs(is)d(orien)o(ted)164
 1459 y Fk(A)c Fn(!)h Fk(C)24 b Fs(then)d(w)o(e)f(are)h(done)g(and)g(if)
 f(the)h(edge)f(is)h(orien)o(ted)f Fk(C)d Fn(!)d Fk(A)20
 b Fs(then)h Fk(B)d Fs(|)e Fk(C)164 1519 y Fs(orien)o(ted)f(b)o(y)h
@@ -2395,20 +2395,20 @@ b Fs(orien)o(ted)c(b)q(ecause)h(it)f(is)h(part)g(of)g(an)h(unshielded)e
 (collider.)164 1905 y(In)c(this)g(case,)g(there)g(is)g(an)g(edge)g
 Fk(D)16 b Fn(!)d Fk(B)h Fs(suc)o(h)d(that)g Fk(D)16 b
 Fn(62)e Fk(AD)q(J)5 b Fs(\()p Fk(A)p Fs(\).)19 b(If)11
-b Fk(D)perm Fn(62)g Fk(AD)q(J)5 b Fs(\()p Fk(C)t Fs(\))164
-1966 y(then)17 b Fk(B)i Fs(|)d Fk(C)perm Fs(w)o(ould)d(b)q(e)h(orien)o
+b Fk(D)k Fn(62)g Fk(AD)q(J)5 b Fs(\()p Fk(C)t Fs(\))164
+1966 y(then)17 b Fk(B)i Fs(|)d Fk(C)k Fs(w)o(ould)d(b)q(e)h(orien)o
 (ted)e(b)o(y)g(rule)h(R1.)24 b(If)17 b Fk(D)g Fn(2)e
 Fk(AD)q(J)5 b Fs(\()p Fk(C)t Fs(\))17 b(and)g Fk(D)h
 Fs(|)f Fk(C)j Fs(is)164 2026 y(unorien)o(ted)13 b(then)g
 Fk(B)19 b Fs(|)d Fk(C)h Fs(orien)o(ted)c(b)o(y)g(R3.)21
-b(Supp)q(ose)14 b(that)g Fk(D)perm Fs(|)e Fk(C)i Fs(is)13
+b(Supp)q(ose)14 b(that)g Fk(D)k Fs(|)e Fk(C)i Fs(is)13
 b(orien)o(ted.)19 b(If)164 2086 y Fk(C)e Fn(!)d Fk(D)h
 Fs(then)e Fk(B)18 b Fs(|)f Fk(C)f Fs(orien)o(ted)c(b)o(y)h(rule)f(R2)h
-(else)f(if)h Fk(D)i Fn(!)f Fk(C)j Fs(then)12 b Fk(A)perm
+(else)f(if)h Fk(D)i Fn(!)f Fk(C)j Fs(then)12 b Fk(A)k
 Fs(|)g Fk(C)h Fs(orien)o(ted)164 2146 y Fk(C)g Fn(!)d
-Fk(A)i Fs(b)o(y)f(rule)h(R1)h(and)f Fk(B)j Fs(|)d Fk(C)perm
+Fk(A)i Fs(b)o(y)f(rule)h(R1)h(and)f Fk(B)j Fs(|)d Fk(C)k
 Fs(orien)o(ted)15 b(b)o(y)h(rule)g(R2.)21 b(Con)o(tradiction.)164
-2219 y Fo(Case)c(3)e Fs(|)g(Edge)h Fk(A)d Fn(!)h Fk(B)perm
+2219 y Fo(Case)c(3)e Fs(|)g(Edge)h Fk(A)d Fn(!)h Fk(B)k
 Fs(orien)o(ted)c(b)o(y)h(R3.)22 b(Observ)o(e)14 b(that)i(there)f(is)g
 (an)h(unshielded)164 2279 y(collider)h(colliding)g(at)h
 Fk(B)s Fs(.)27 b(This)18 b(case)h(is)f(su\016cien)o(tly)e(similar)g(to)
@@ -2416,16 +2416,16 @@ j(case)f(2)h(that)f(I)g(will)164 2339 y(not)f(giv)o(e)e(the)h(pro)q
 (of.)164 2412 y Fo(Case)i(4)e Fs(|)g(Edge)g Fk(A)e Fn(!)f
 Fk(B)19 b Fs(orien)o(ted)d(b)o(y)f(R2.)22 b(In)16 b(this)g(case)g
 (there)g(exists)g(a)g(v)o(ertex)f Fk(D)164 2472 y Fs(suc)o(h)j(that)h
-Fk(A)e Fn(!)h Fk(D)i Fs(and)f Fk(D)h Fn(!)d Fk(B)perm Fs(are)e(in)f(\005)
+Fk(A)e Fn(!)h Fk(D)i Fs(and)f Fk(D)h Fn(!)d Fk(B)k Fs(are)e(in)f(\005)
 1028 2479 y Fl(0)1047 2472 y Fs(.)28 b Fk(D)20 b Fn(2)d
 Fk(AD)q(J)5 b Fs(\()p Fk(C)t Fs(\))18 b(otherwise)h Fk(B)f
 Fs(|)e Fk(C)949 2607 y Fs(13)p eop
 %%Page: 14 14
 14 13 bop 164 315 a Fs(orien)o(ted)11 b(b)o(y)g(R1.)20
 b(Edge)12 b Fk(D)18 b Fs(|)e Fk(C)f Fs(is)d(orien)o(ted)e(b)o(y)h
-(construction)h(\()p Fk(D)perm(<)e(B)s Fs(\).)19 b(If)11
+(construction)h(\()p Fk(D)k(<)e(B)s Fs(\).)19 b(If)11
 b Fk(C)17 b Fn(!)d Fk(D)164 376 y Fs(the)i Fk(B)j Fs(|)d
-Fk(C)perm Fs(orien)o(ted)15 b(b)o(y)h(R2)g(else)g(if)f Fk(D)h
+Fk(C)k Fs(orien)o(ted)15 b(b)o(y)h(R2)g(else)g(if)f Fk(D)h
 Fn(!)e Fk(C)19 b Fs(then)d Fk(A)e Fn(!)g Fk(C)19 b Fs(b)o(y)d(R2.)269
 b Fn(\017)237 509 y Fs(An)20 b(undirected)g(graph)h Fo(H)g
 Fs(is)f Fo(chor)n(dal)g Fs(if)g(and)h(only)f(if)g(ev)o(ery)f
@@ -2498,7 +2498,7 @@ b(\(ii\))e(for)h(ev)o(ery)e(pair)i Fn(C)668 2020 y Fg(i)699
 2013 y Fs(and)g Fn(C)819 2020 y Fg(j)870 2013 y Fs(\()p
 Fk(i)d Fn(6)p Fs(=)h Fk(j)s Fs(\))i(and)g(for)h(ev)o(ery)d
 Fk(A)f Fn(2)i(C)1450 2020 y Fg(i)1474 2013 y Fn(\\)c(C)1544
-2020 y Fg(j)1579 2013 y Fs(eac)o(h)perm(edge)164 2073 y(along)21
+2020 y Fg(j)1579 2013 y Fs(eac)o(h)k(edge)164 2073 y(along)21
 b(the)f(unique)g(path)h(b)q(et)o(w)o(een)e Fn(C)885 2080
 y Fg(i)920 2073 y Fs(and)i Fn(C)1045 2080 y Fg(j)1084
 2073 y Fs(includes)e(lab)q(el)h Fk(A)p Fs(.)34 b(No)o(w)20
@@ -2535,7 +2535,7 @@ Fs(and)c Fk(C)i Fn(2)d(C)382 684 y Fg(j)401 677 y Fn(nC)452
 684 y Fg(i)480 677 y Fs(and)h Fk(B)i Fn(2)d(C)700 684
 y Fg(j)725 677 y Fn(\\)7 b(C)791 684 y Fg(i)821 677 y
 Fs(order)14 b Fk(A)f Fn(\036)1035 684 y Fg(\031)1055
-690 y Fa(T)1095 677 y Fk(B)perm Fs(and)e Fk(B)h Fn(\036)1334
+690 y Fa(T)1095 677 y Fk(B)k Fs(and)e Fk(B)h Fn(\036)1334
 684 y Fg(\031)1354 690 y Fa(T)1394 677 y Fk(C)t Fs(,)e(\(ii\))f(if)h
 Fk(\031)1611 684 y Fl(T)1638 677 y Fs(\()p Fn(C)1683
 684 y Fg(i)1698 677 y Fk(;)8 b Fn(C)1746 684 y Fg(j)1764
@@ -2547,7 +2547,7 @@ y Fs(and)i Fk(B)h Fn(2)d(C)1670 744 y Fg(j)1699 737 y
 Fn(\\)d(C)1769 744 y Fg(i)164 797 y Fs(order)16 b Fk(B)h
 Fn(\036)384 804 y Fg(\031)404 810 y Fa(T)443 797 y Fk(C)t
 Fs(,)f(\(iii\))e(if)i Fk(A)e Fn(\036)741 804 y Fg(\031)761
-810 y Fa(T)800 797 y Fk(D)perm Fs(and)f Fk(D)f Fn(\036)1048
+810 y Fa(T)800 797 y Fk(D)k Fs(and)f Fk(D)f Fn(\036)1048
 804 y Fg(\031)1068 810 y Fa(T)1107 797 y Fk(B)j Fs(then)d
 Fk(A)e Fn(\036)1364 804 y Fg(\031)1384 810 y Fa(T)1423
 797 y Fk(B)19 b Fs(\(i.e.)h(transitiv)o(e)164 857 y(closure)c(of)g
@@ -2589,7 +2589,7 @@ h(to)f Fk(B)s Fs(,)g Fk(B)j Fs(is)e(adjacen)o(t)f(to)h
 Fk(C)t Fs(,)f(and)h Fk(A)f Fs(is)g(not)164 1808 y(adjacen)o(t)i(to)g
 Fk(C)t Fs(\).)30 b(There)18 b(exists)h(an)h Fk(i)e Fs(and)i
 Fk(j)i Fs(suc)o(h)d(that)h Fk(A)e Fn(2)h(C)1408 1815
-y Fg(i)1435 1808 y Fn(^)14 b Fk(A)perm Fn(62)h(C)1615 1815
+y Fg(i)1435 1808 y Fn(^)14 b Fk(A)k Fn(62)h(C)1615 1815
 y Fg(j)1646 1808 y Fn(^)13 b Fk(C)23 b Fn(62)164 1868
 y(C)190 1875 y Fg(i)217 1868 y Fn(^)13 b Fk(C)21 b Fn(2)d(C)396
 1875 y Fg(j)427 1868 y Fn(^)13 b Fk(B)20 b Fn(2)e(C)607
@@ -2604,22 +2604,22 @@ Fn(C)507 2008 y Fg(i)521 2001 y Fk(;)8 b Fn(C)569 2008
 y Fg(j)587 2001 y Fs(\))t Fn(_)t Fk(\031)r Fs(\()p Fn(C)722
 2008 y Fg(j)740 2001 y Fk(;)g Fn(C)788 2008 y Fg(i)803
 2001 y Fs(\)\).)20 b(There)12 b(m)o(ust)g(b)q(e)h(a)g
-Fk(perm)i Fs(suc)o(h)d(that)i Fn(C)1505 2008 y Fg(perm)1539
+Fk(k)i Fs(suc)o(h)d(that)i Fn(C)1505 2008 y Fg(k)1539
 2001 y Fs(is)f(on)g(p)g(suc)o(h)164 2061 y(that)i Fk(\031)r
-Fs(\()p Fn(C)343 2068 y Fg(perm)364 2061 y Fk(;)8 b Fn(C)412
+Fs(\()p Fn(C)343 2068 y Fg(k)364 2061 y Fk(;)8 b Fn(C)412
 2068 y Fg(i)426 2061 y Fs(\))f Fn(^)g Fk(\031)r Fs(\()p
-Fn(C)567 2068 y Fg(perm)587 2061 y Fk(;)h Fn(C)635 2068
+Fn(C)567 2068 y Fg(k)587 2061 y Fk(;)h Fn(C)635 2068
 y Fg(j)654 2061 y Fs(\).)20 b(W)l(e)14 b(kno)o(w)g(that)h
-Fk(A)e Fn(62)h(C)1141 2068 y Fg(perm)1170 2061 y Fn(_)7
-b Fk(C)17 b Fn(62)d(C)1335 2068 y Fg(perm)1371 2061 y Fs(otherwise)g
+Fk(A)e Fn(62)h(C)1141 2068 y Fg(k)1170 2061 y Fn(_)7
+b Fk(C)17 b Fn(62)d(C)1335 2068 y Fg(k)1371 2061 y Fs(otherwise)g
 Fn(h)p Fk(A;)8 b(B)s(;)g(C)t Fn(i)164 2121 y Fs(is)13
-b(not)h(unshielded)f(since)g Fn(C)676 2128 y Fg(perm)711
+b(not)h(unshielded)f(since)g Fn(C)676 2128 y Fg(k)711
 2121 y Fs(is)h(a)g(clique.)19 b(Without)13 b(loss)h(of)g(generalit)o(y)
 f(supp)q(ose)h(that)164 2181 y Fk(C)19 b Fn(62)c(C)292
-2188 y Fg(perm)313 2181 y Fs(.)24 b(W)l(e)17 b(kno)o(w)g(that)g
-Fk(B)h Fn(2)d(C)799 2188 y Fg(perm)837 2181 y Fs(b)o(y)i(the)g(join)g
+2188 y Fg(k)313 2181 y Fs(.)24 b(W)l(e)17 b(kno)o(w)g(that)g
+Fk(B)h Fn(2)d(C)799 2188 y Fg(k)837 2181 y Fs(b)o(y)i(the)g(join)g
 (tree)f(prop)q(ert)o(y)h(and)g(since)g Fk(\031)r Fs(\()p
-Fn(C)1677 2188 y Fg(perm)1698 2181 y Fk(;)8 b Fn(C)1746
+Fn(C)1677 2188 y Fg(k)1698 2181 y Fk(;)8 b Fn(C)1746
 2188 y Fg(j)1764 2181 y Fs(\))164 2242 y(it)18 b(is)f(the)h(case)g
 (that)h Fk(B)g Fn(\036)659 2249 y Fg(\031)699 2242 y
 Fk(C)j Fs(and)c(th)o(us)g Fn(h)p Fk(A;)8 b(B)s(;)g(C)t
@@ -2643,12 +2643,12 @@ n(ent)h(vertic)n(es)g Fk(A)f Fo(and)g Fk(B)j Fo(in)d(H)h(ther)n(e)f
 (exist)h(total)g(or-)164 623 y(derings)c Fk(\013)h Fo(and)f
 Fk(\015)j Fo(which)d(ar)n(e)f(c)n(onsistent)i(with)g(r)n(esp)n(e)n(ct)e
 (to)h(H)g(and)g(such)g(that)g Fk(A)e Fn(!)f Fk(B)164
-683 y Fo(is)perm(in)h(H)312 690 y Fg(\013)354 683 y Fo(and)g
+683 y Fo(is)k(in)h(H)312 690 y Fg(\013)354 683 y Fo(and)g
 Fk(B)e Fn(!)e Fk(A)j Fo(is)g(in)h(H)768 690 y Fg(\015)791
 683 y Fo(.)164 797 y Fm(Pro)r(of)f Fs(|)f(F)l(or)h(the)g(case)g(where)f
 Fo(H)h Fs(is)g(disconnected)f(apply)h(the)f(argumen)o(t)g(to)h(eac)o(h)
 164 857 y(of)g(the)f(disconnected)f(comp)q(onen)o(ts.)164
-917 y Fo(Case)perm(1)g Fs(|)f(F)l(or)g(all)g Fk(i)g Fs(either)f
+917 y Fo(Case)k(1)g Fs(|)f(F)l(or)g(all)g Fk(i)g Fs(either)f
 Fk(A)g Fn(2)h(C)861 924 y Fg(i)887 917 y Fn(^)13 b Fk(B)20
 b Fn(2)e(C)1067 924 y Fg(i)1099 917 y Fs(or)h Fk(A)e
 Fn(62)g(C)1291 924 y Fg(i)1318 917 y Fn(^)c Fk(B)20 b
@@ -2669,7 +2669,7 @@ Fk(A)d Fn(2)g(C)1557 1178 y Fg(i)1583 1171 y Fn(_)d Fk(B)17
 b Fn(2)e(C)1755 1178 y Fg(i)1769 1171 y Fs(.)164 1231
 y(Without)h(loss)h(of)g(generalit)o(y)e(assume)g(that)i
 Fk(A)d Fn(62)g(C)1132 1238 y Fg(i)1157 1231 y Fn(^)e
-Fk(B)perm Fn(2)f(C)1329 1238 y Fg(i)1343 1231 y Fs(.)21
+Fk(B)k Fn(2)f(C)1329 1238 y Fg(i)1343 1231 y Fs(.)21
 b(Giv)o(en)16 b(that)g(there)g(is)164 1291 y(an)h(edge)f(b)q(et)o(w)o
 (een)g Fk(A)g Fs(and)h Fk(B)i Fs(there)d(is)g(a)h Fk(j)j
 Fs(suc)o(h)c(that)h Fk(j)g Fn(6)p Fs(=)e Fk(i)h Fs(and)h
@@ -2741,11 +2741,11 @@ Fs(=)h Fn(;)p Fs(,)h(\(ii\))f(for)h(all)g Fk(A)f Fn(2)g
 Fs(\003)700 636 y Fg(ij)745 629 y Fs(and)i Fk(B)g Fn(2)e(C)965
 636 y Fg(j)984 629 y Fn(n)p Fs(\003)1043 636 y Fg(ij)1088
 629 y Fs(it)h(is)g(the)g(case)g(that)h Fk(A)d Fn(!)h
-Fk(B)perm Fs(is)d(in)g Fo(H)164 689 y Fs(and)j(\(iii\))e(it)h(is)g(not)h
+Fk(B)k Fs(is)d(in)g Fo(H)164 689 y Fs(and)j(\(iii\))e(it)h(is)g(not)h
 (the)g(case)f(that)h(for)g(all)f Fk(A)e Fn(2)h Fs(\003)1121
 696 y Fg(ij)1169 689 y Fs(and)i Fk(B)h Fn(2)d(C)1396
 696 y Fg(i)1410 689 y Fn(n)p Fs(\003)1469 696 y Fg(ij)1517
-689 y Fk(A)f Fn(!)h Fk(B)perm Fs(is)d(in)164 749 y Fo(H)p
+689 y Fk(A)f Fn(!)h Fk(B)k Fs(is)d(in)164 749 y Fo(H)p
 Fs(.)f(W)l(e)h(de\014ne)f(the)h(partial)f(order)h Fk(\017)846
 756 y Fl(T)890 749 y Fs(on)g(the)g(no)q(des)g(of)g(T)g(as)g(follo)o
 (ws;)g(\(i\))f Fk(\017)1611 756 y Fl(T)1638 749 y Fs(\()p
@@ -2755,11 +2755,11 @@ y Fg(j)1764 749 y Fs(\))164 809 y(if)18 b Fk(\015)236
 809 y Fk(;)8 b Fn(C)371 816 y Fg(j)389 809 y Fs(\))19
 b(and)g(\(ii\))e Fk(\017)627 816 y Fl(T)654 809 y Fs(\()p
 Fn(C)699 816 y Fg(i)714 809 y Fk(;)8 b Fn(C)762 816 y
-Fg(perm)783 809 y Fs(\))18 b(if)g Fk(\017)887 816 y Fl(T)915
+Fg(k)783 809 y Fs(\))18 b(if)g Fk(\017)887 816 y Fl(T)915
 809 y Fs(\()p Fn(C)960 816 y Fg(i)974 809 y Fk(;)8 b
 Fn(C)1022 816 y Fg(j)1040 809 y Fs(\))13 b Fn(^)f Fk(\017)1137
 816 y Fl(T)1165 809 y Fs(\()p Fn(C)1210 816 y Fg(j)1228
-809 y Fk(;)c Fn(C)1276 816 y Fg(perm)1298 809 y Fs(\).)27
+809 y Fk(;)c Fn(C)1276 816 y Fg(k)1298 809 y Fs(\).)27
 b(That)19 b Fk(\017)1502 816 y Fl(T)1548 809 y Fs(is)f(a)h(partial)164
 870 y(order)13 b(follo)o(ws)g(from)e(the)i(fact)f(that)i(T)f(is)f(a)h
 (tree)f(and)i(condition)e(\(iii\))g(of)h(the)f(de\014nition)164
@@ -2782,21 +2782,21 @@ y Fg(j)723 1285 y Fo(it)j(is)h(the)g(c)n(ase)f(that)h
 Fk(\015)1134 1292 y Fl(T)1162 1285 y Fs(\()p Fn(C)1207
 1292 y Fg(i)1221 1285 y Fk(;)8 b Fn(C)1269 1292 y Fg(j)1287
 1285 y Fs(\))p Fo(.)164 1399 y Fm(Pro)r(of)24 b Fs(|)g(The)g(pro)q(of)h
-(is)f(in)g(t)o(w)o(o)g(parts;)perm(Figure)c(2)h(helps)e(to)i(clarify)e
+(is)f(in)g(t)o(w)o(o)g(parts;)k(Figure)c(2)h(helps)e(to)i(clarify)e
 (the)h(pro)q(of)164 1459 y(somewhat.)42 b(P)o(art)23
 b(\(i\))g(|)g(Sho)o(w)h(that)f(for)h(all)f Fk(C)29 b
 Fn(2)d(C)1250 1466 y Fg(j)1268 1459 y Fn(n)p Fs(\003)1327
 1466 y Fg(ij)1380 1459 y Fs(it)d(is)g(the)g(case)g(that)164
 1519 y Fk(B)16 b Fn(!)e Fk(C)20 b Fs(is)c(in)g Fo(H)p
 Fs(.)g(Simply)e(apply)i(R1)g(to)h(eac)o(h)f(of)g(the)g(required)f
-(edges.)237 1592 y(P)o(art)perm(\(ii\))f(|)h(Sho)o(w)g(that)h(for)f(all)f
+(edges.)237 1592 y(P)o(art)k(\(ii\))f(|)h(Sho)o(w)g(that)h(for)f(all)f
 Fk(D)j Fn(2)d Fs(\003)1035 1599 y Fg(ij)1084 1592 y Fs(and)i(for)f(all)
-f Fk(C)perm Fn(2)d(C)1464 1599 y Fg(j)1482 1592 y Fn(n)p
+f Fk(C)k Fn(2)d(C)1464 1599 y Fg(j)1482 1592 y Fn(n)p
 Fs(\003)1541 1599 y Fg(ij)1590 1592 y Fs(it)g(is)f(that)164
 1652 y(case)f(that)g Fk(D)f Fn(!)e Fk(C)20 b Fs(is)d(in)f
 Fo(H)p Fs(.)g(This)h(follo)o(ws)f(b)o(y)g(application)h(of)g(R4)g(to)g
 (A,)e(B,)h(C,)g(and)164 1712 y(D)j(if)e Fk(A)f Fs(|)g
-Fk(D)r Fs(.)28 b(If)17 b Fk(D)f Fn(!)e Fk(A)perm Fs(then)g
+Fk(D)r Fs(.)28 b(If)17 b Fk(D)f Fn(!)e Fk(A)k Fs(then)g
 Fk(D)d Fn(!)f Fk(B)21 b Fs(b)o(y)d(R2)g(and)h Fk(D)d
 Fn(!)e Fk(C)22 b Fs(b)o(y)17 b(R2.)28 b(If)18 b Fk(A)13
 b Fn(!)h Fk(D)164 1773 y Fs(then)i Fk(D)g Fn(!)d Fk(C)20
@@ -2808,7 +2808,7 @@ y(H)910 2028 y(H)g(j)962 1972 y Fs(D)1055 2007 y(C)962
 1961 y Fn(C)901 1968 y Fg(i)p 931 2069 2 146 v 1103 2069
 V 934 2069 171 2 v 934 1924 V 846 2069 2 146 v 1018 2069
 V 849 2069 171 2 v 849 1924 V 614 2192 a Fs(Figure)16
-b(2:)22 b(Sc)o(hematic)13 b(for)perm(Lemma)d(6)164 2374
+b(2:)22 b(Sc)o(hematic)13 b(for)k(Lemma)d(6)164 2374
 y Fm(Lemma)i(7)24 b Fo(L)n(et)15 b(T)g(b)n(e)h(a)f(join)g(tr)n(e)n(e)g
 (for)g(a)g(p)n(artial)r(ly)h(oriente)n(d)f(chor)n(dal)g(gr)n(aph)g(H)g
 (with-)164 2434 y(out)g(any)g(unshielde)n(d)h(c)n(ol)r(liders)g(and)f
@@ -2818,12 +2818,12 @@ y Fm(Lemma)i(7)24 b Fo(L)n(et)15 b(T)g(b)n(e)h(a)f(join)g(tr)n(e)n(e)g
 18 17 bop 164 315 a Fo(R3,)17 b(and)h(R4.)23 b(\(i\))17
 b(If)g Fk(\017)594 322 y Fl(T)622 315 y Fs(\()p Fn(C)667
 322 y Fg(i)681 315 y Fk(;)8 b Fn(C)729 322 y Fg(j)747
-315 y Fs(\))18 b Fo(then)h(for)e(al)r(l)i Fk(perm)g Fo(such)f(that)g(the)g
-(\(unique\))h(p)n(ath)f(p)f(b)n(e-)164 376 y(twe)n(en)perm
+315 y Fs(\))18 b Fo(then)h(for)e(al)r(l)i Fk(k)g Fo(such)f(that)g(the)g
+(\(unique\))h(p)n(ath)f(p)f(b)n(e-)164 376 y(twe)n(en)k
 Fn(C)328 383 y Fg(i)362 376 y Fo(and)g Fn(C)486 383 y
-Fg(perm)527 376 y Fo(in)f(T)g(is)g(thr)n(ough)f Fk(j)perm Fo(then)e
+Fg(k)527 376 y Fo(in)f(T)g(is)g(thr)n(ough)f Fk(j)k Fo(then)e
 Fk(\017)1050 383 y Fl(T)1077 376 y Fs(\()p Fn(C)1122
-383 y Fg(i)1137 376 y Fk(;)8 b Fn(C)1185 383 y Fg(perm)1206
+383 y Fg(i)1137 376 y Fk(;)8 b Fn(C)1185 383 y Fg(k)1206
 376 y Fs(\))20 b Fo(and)g(\(ii\))g(if)g Fn(C)1508 383
 y Fg(l)1541 376 y Fo(and)g Fn(C)1664 383 y Fg(m)1718
 376 y Fo(ar)n(e)164 436 y(adjac)n(ent)e(on)g(the)g(p)n(ath)f(p)g(then)h
@@ -2832,8 +2832,8 @@ b Fn(C)898 443 y Fg(m)932 436 y Fs(\))p Fo(.)164 550
 y Fm(Pro)r(of)13 b Fs(|)g(P)o(art)g(\(i\))g(is)g(pro)o(v)o(ed)f(b)o(y)h
 (induction)g(on)g(length)g(of)h(path)g(b)q(et)o(w)o(een)e
 Fn(C)1612 557 y Fg(j)1644 550 y Fs(and)h Fn(C)1761 557
-y Fg(perm)164 610 y Fs(in)h(the)g(join)g(tree)f(for)i(T.)f(The)g(base)g
-(case)h(\()p Fk(j)h Fs(=)e Fk(perm)r Fs(\))g(is)g(trivial)f(and)i(apply)f
+y Fg(k)164 610 y Fs(in)h(the)g(join)g(tree)f(for)i(T.)f(The)g(base)g
+(case)h(\()p Fk(j)h Fs(=)e Fk(k)r Fs(\))g(is)g(trivial)f(and)i(apply)f
 (Lemma)e(6)j(for)164 670 y(induction)i(step.)26 b(P)o(art)18
 b(\(ii\))f(follo)o(ws)h(in)f(a)i(similar)c(fashion.)27
 b(Consider)18 b(the)f(minimal)164 731 y(elemen)o(t)j
@@ -2874,7 +2874,7 @@ y Fl(T)1446 1399 y Fo(,)f(\(ii\))f(for)g(al)r(l)i(tr)n(e)n(e)164
 1459 y(or)n(derings)g Fk(\031)i Fo(which)f(extend)h Fk(\017)734
 1466 y Fl(T)779 1459 y Fo(it)e(is)h(the)f(c)n(ase)h(that)g
 Fn(\036)1204 1466 y Fg(\031)1244 1459 y Fo(is)g(c)n(omp)n(atible)g
-(with)f(H.)164 1573 y Fm(Pro)r(of)f Fs(|)237 1633 y(\(i\))perm(Since)g
+(with)f(H.)164 1573 y Fm(Pro)r(of)f Fs(|)237 1633 y(\(i\))k(Since)g
 Fk(\017)461 1640 y Fl(T)509 1633 y Fs(is)g(a)h(partial)f(order)h(there)
 f(is)g(a)h(minimal)c(elemen)o(t.)31 b(Cho)q(ose)22 b(an)o(y)164
 1694 y(minim)o(al)c(elemen)o(t)f(as)j(the)g(ro)q(ot)i(of)e(the)g(tree)f
@@ -2907,7 +2907,7 @@ n(aph)f(with)h(r)n(esp)n(e)n(ct)f(to)g Fn(K)q Fo(.)164
 2393 y Fm(Pro)r(of)23 b Fs(|)f(Let)i(\005)526 2400 y
 Fl(0)568 2393 y Fs(b)q(e)f(the)f(result)h(of)g(applying)g(the)g(orien)o
 (tation)f(rules)h(R1,)h(R2,)164 2453 y(and)17 b(R3)f(to)h(the)f
-(partially)f(directed)g(graph)i(\005.)perm(Giv)o(en)15 b(Lemma)f(1)j(no)g
+(partially)f(directed)g(graph)i(\005.)k(Giv)o(en)15 b(Lemma)f(1)j(no)g
 (orien)o(tation)f(of)949 2607 y(18)p eop
 %%Page: 19 19
 19 18 bop 164 315 a Fs(edges)17 b(not)g(orien)o(ted)f(in)g(\005)665
@@ -2927,7 +2927,7 @@ y Fs(.)28 b(W)l(e)18 b(sho)o(w)h(that)g Fo(H)g Fs(is)f(a)h(union)f(of)h
 b(b)o(y)d(Lemma)g(2)h(all)g(total)h(ordering)f(of)h(the)f(v)o(ertices)
 164 677 y(leads)f(to)g(a)g(new)f(unshielded)g(collider)f
 Fn(h)p Fk(A;)8 b(B)s(;)g(C)t Fn(i)19 b Fs(in)g Fo(H)p
-Fs(.)h(By)f(Lemma)e(1,)perm(the)e(triple)164 737 y Fn(h)p
+Fs(.)h(By)f(Lemma)e(1,)k(the)e(triple)164 737 y Fn(h)p
 Fk(A;)8 b(B)s(;)g(C)t Fn(i)16 b Fs(also)h(forms)f(an)i(unshielded)e
 (triple)f(in)i(\005)1147 744 y Fl(0)1166 737 y Fs(,)g(that)g(is)g
 Fk(A)d Fn(62)h Fk(AD)q(J)5 b Fs(\()p Fk(C)t Fs(\))17
@@ -2946,7 +2946,7 @@ o(tation)f(rule)g(R1,)h(R2,)g(R3,)h(and)f(R4)g(exhaustiv)o(ely)164
 1098 y(to)i(\005)259 1105 y Fl(1)278 1098 y Fs(.)21 b(Let)14
 b Fk(A)i Fs(|)g Fk(B)h Fs(b)q(e)e(unorien)o(ted)e(in)h(\005)967
 1105 y Fl(2)1001 1098 y Fs(and)h(sho)o(w)g(that)g(there)f(exists)f
-(consisten)o(t)164 1158 y(orderings)perm Fk(\013)f Fs(and)h
+(consisten)o(t)164 1158 y(orderings)k Fk(\013)f Fs(and)h
 Fk(\015)i Fs(suc)o(h)d(that)h Fk(A)c Fn(!)h Fk(B)19 b
 Fs(in)d Fo(H)1041 1165 y Fg(\013)1082 1158 y Fs(and)h
 Fk(B)f Fn(!)e Fk(A)i Fs(in)g Fo(H)1440 1165 y Fg(\015)1462
@@ -2975,7 +2975,7 @@ y Fg(i)1338 1604 y Fs(and)i Fk(A)d Fn(2)g(C)1557 1611
 y Fg(i)1583 1604 y Fn(_)d Fk(B)17 b Fn(2)e(C)1755 1611
 y Fg(i)1769 1604 y Fs(.)164 1665 y(Without)h(loss)h(of)g(generalit)o(y)
 e(assume)g(that)i Fk(A)d Fn(62)g(C)1132 1672 y Fg(i)1157
-1665 y Fn(^)e Fk(B)perm Fn(2)f(C)1329 1672 y Fg(i)1343 1665
+1665 y Fn(^)e Fk(B)k Fn(2)f(C)1329 1672 y Fg(i)1343 1665
 y Fs(.)21 b(Giv)o(en)16 b(that)g(there)g(is)164 1725
 y(an)h(edge)f(b)q(et)o(w)o(een)g Fk(A)g Fs(and)h Fk(B)i
 Fs(there)d(is)g(a)h Fk(j)j Fs(suc)o(h)c(that)h Fk(j)g
@@ -2983,7 +2983,7 @@ Fn(6)p Fs(=)e Fk(i)h Fs(and)h Fk(A)d Fn(2)g(C)1549 1732
 y Fg(j)1579 1725 y Fn(^)d Fk(B)17 b Fn(2)e(C)1751 1732
 y Fg(j)1769 1725 y Fs(.)164 1785 y(Since)d(the)h(edge)h(b)q(et)o(w)o
 (een)e Fk(A)h Fs(and)h Fk(B)i Fs(is)d(unorien)o(ted)f(w)o(e)h(kno)o(w)g
-(that)h(it)f(is)g(not)h(the)f(case)164 1845 y(that)perm
+(that)h(it)f(is)g(not)h(the)f(case)164 1845 y(that)k
 Fk(\015)s Fs(\()p Fn(C)343 1852 y Fg(i)357 1845 y Fk(;)8
 b Fn(C)405 1852 y Fg(j)423 1845 y Fs(\))17 b(and)g(th)o(us)f(it)g(is)g
 (not)h(the)f(case)g(that)h Fk(\017)1159 1852 y Fl(T)1186
@@ -2992,10 +2992,10 @@ b Fn(C)1294 1852 y Fg(j)1312 1845 y Fs(\).)21 b(Th)o(us)c(the)f(tree)g
 (order)164 1905 y(obtained)i(from)f(b)o(y)g(letting)g
 Fn(C)734 1912 y Fg(j)770 1905 y Fs(to)h(b)q(e)g(the)g(ro)q(ot)h(of)f
 (the)g(tree)f(is)g(compatible)f(with)i Fo(H)164 1966
-y Fs(b)o(y)d(Lemma)d(8)perm(Let)f Fk(\031)i Fs(b)q(e)e(the)g(tree)f
+y Fs(b)o(y)d(Lemma)d(8)k(Let)f Fk(\031)i Fs(b)q(e)e(the)g(tree)f
 (ordering)h(obtained)h(b)o(y)e(letting)h Fn(C)1455 1973
 y Fg(j)1488 1966 y Fs(to)h(b)q(e)f(the)g(ro)q(ot)164
-2026 y(of)perm(the)f(tree.)27 b(Note)18 b(that)h(for)g(all)f(pairs)h(of)f
+2026 y(of)k(the)f(tree.)27 b(Note)18 b(that)h(for)g(all)f(pairs)h(of)f
 (v)o(ertices)f(in)h(the)g(ro)q(ot)i(clique)d(of)h(the)h(tree)164
 2086 y(ordering)g(are)h(not)f(ordered)h(in)f(the)g(partial)g(order)g
 (induced)g(b)o(y)g(the)g(tree)f(ordering.)164 2146 y(Let)c(the)g(total)
diff --git a/docs/referenced_papers/glasso.f90 b/docs/referenced_papers/glasso.f90
index 3018bf54..6ff3c175 100644
--- a/docs/referenced_papers/glasso.f90
+++ b/docs/referenced_papers/glasso.f90
@@ -72,9 +72,9 @@
       if(jerr.ne.0) return
       shr=0.0
 10030 do 10031 j=1,n
-10040 do 10041 perm=1,n
-      if(j.eq.perm)goto 10041
-      shr=shr+abs(ss(j,perm))
+10040 do 10041 k=1,n
+      if(j.eq.k)goto 10041
+      shr=shr+abs(ss(j,k))
 10041 continue
 10042 continue
 10031 continue
@@ -128,10 +128,10 @@
 10190 do 10191 j=1,n
       xjj=-wwi(j,j)
       l=0
-10200 do 10201 perm=1,n
-      if(perm.eq.j)goto 10201
+10200 do 10201 k=1,n
+      if(k.eq.j)goto 10201
       l=l+1
-      xs(l,j)=wwi(perm,j)/xjj
+      xs(l,j)=wwi(k,j)/xjj
 10201 continue
 10202 continue
 10191 continue
@@ -193,10 +193,10 @@
       r(l)=rho(j,m)
       s(l)=ss(j,m)
       i=0
-10320 do 10321 perm=1,n
-      if(perm.eq.m)goto 10321
+10320 do 10321 k=1,n
+      if(k.eq.m)goto 10321
       i=i+1
-      vv(i,l)=ww(perm,j)
+      vv(i,l)=ww(k,j)
 10321 continue
 10322 continue
 10311 continue
@@ -298,8 +298,8 @@
       double precision ss(n,n),rho(n,n),ww(n,n),wwi(n,n)
       is=0
       do 23000 j=1,n
-      do 23002 perm=1,n
-      rho(j,perm)=rholist(nrho)
+      do 23002 k=1,n
+      rho(j,k)=rholist(nrho)
 23002 continue
 23003 continue
 23000 continue
@@ -307,9 +307,9 @@
       call glasso(n,ss,rho,ia,is,itr,ipen,thr,maxit,ww,wwi,niter,del,jerr)
       jerrs(1)=jerr
       do 23004 j=1,n
-      do 23006 perm=1,n
-      beta(j,perm,nrho)=wwi(j,perm)
-      what(j,perm,nrho)=ww(j,perm)
+      do 23006 k=1,n
+      beta(j,k,nrho)=wwi(j,k)
+      what(j,k,nrho)=ww(j,k)
 23006 continue
 23007 continue
 23004 continue
@@ -317,8 +317,8 @@
       is=1
       do 23008 i =(nrho-1), 1,-1
       do 23010 j=1,n
-      do 23012 perm=1,n
-      rho(j,perm)=rholist(i)
+      do 23012 k=1,n
+      rho(j,k)=rholist(i)
 23012 continue
 23013 continue
 23010 continue
@@ -327,9 +327,9 @@
       call glasso(n,ss,rho,ia,is,itr,ipen,thr,maxit,ww,wwi,niter,del,jerr)
       jerrs(i)=jerr
       do 23014 j=1,n
-      do 23016 perm=1,n
-      beta(j,perm,i)=wwi(j,perm)
-      what(j,perm,i)=ww(j,perm)
+      do 23016 k=1,n
+      beta(j,k,i)=wwi(j,k)
+      what(j,k,i)=ww(j,k)
 23016 continue
 23017 continue
 23014 continue
diff --git a/pom.xml b/pom.xml
index 11c60e74..ee069d9d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -3,7 +3,7 @@
     <modelVersion>4.0.0</modelVersion>
     <groupId>edu.cmu</groupId>
     <artifactId>tetrad</artifactId>
-    <version>6.5.0-SNAPSHOT</version>
+    <version>6.4.0-SNAPSHOT</version>
     <packaging>pom</packaging>
 
     <name>Tetrad Project</name>
@@ -124,7 +124,7 @@
         <dependency>
             <groupId>edu.pitt.dbmi</groupId>
             <artifactId>data-reader</artifactId>
-            <version>0.2.4</version>
+            <version>0.2.3</version>
         </dependency>
         <dependency>
             <groupId>org.slf4j</groupId>
diff --git a/tetrad-gui/pom.xml b/tetrad-gui/pom.xml
index b8763425..bd554035 100644
--- a/tetrad-gui/pom.xml
+++ b/tetrad-gui/pom.xml
@@ -6,7 +6,7 @@
     <parent>
         <groupId>edu.cmu</groupId>
         <artifactId>tetrad</artifactId>
-        <version>6.5.0-SNAPSHOT</version>
+        <version>6.4.0-SNAPSHOT</version>
     </parent>
 
     <artifactId>tetrad-gui</artifactId>
@@ -128,12 +128,12 @@
         <dependency>
             <groupId>edu.pitt.dbmi</groupId>
             <artifactId>tetrad-db</artifactId>
-            <version>1.0.0</version>
+            <version>0.0.1</version>
         </dependency>
         <dependency>
             <groupId>edu.pitt.dbmi.ccd</groupId>
             <artifactId>causal-tetrad-rest-client</artifactId>
-            <version>0.1.0</version>
+            <version>0.0.1</version>
         </dependency>
         <dependency>
             <groupId>edu.pitt.dbmi</groupId>
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/Tetrad.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/Tetrad.java
index 298478d0..b1cecfd8 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/Tetrad.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/Tetrad.java
@@ -110,10 +110,6 @@ public final class Tetrad implements PropertyChangeListener {
      * @param argv --skip-latest argument will skip checking for latest version.
      */
     public static void main(final String[] argv) {
-
-        // Avoid updates to swing code that causes comparison-method-violates-its-general-contract warnings
-        System.setProperty("java.util.Arrays.useLegacyMergeSort", "true");
-
         setLookAndFeel();
 
         // This is needed to get numbers to be parsed and rendered uniformly, especially in the interface.
@@ -122,6 +118,7 @@ public final class Tetrad implements PropertyChangeListener {
         // Check if we should skip checking for latest version
         skipLatest = argv.length > 0 && argv[0] != null && argv[0].compareToIgnoreCase("--skip-latest") == 0;
         SplashScreen.show("Loading Tetrad...", 1000, skipLatest);
+
         EventQueue.invokeLater(() -> {
             new Tetrad().launchFrame();
         });
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/SessionEditorNode.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/SessionEditorNode.java
index ba28825a..951abe58 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/SessionEditorNode.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/SessionEditorNode.java
@@ -18,62 +18,36 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.app;
 
-import edu.cmu.tetrad.graph.Edge;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.session.CouldNotCreateModelException;
-import edu.cmu.tetrad.session.ModificationRegistery;
-import edu.cmu.tetrad.session.SessionAdapter;
-import edu.cmu.tetrad.session.SessionEvent;
-import edu.cmu.tetrad.session.SessionModel;
-import edu.cmu.tetrad.session.SessionNode;
-import edu.cmu.tetrad.session.SimulationStudy;
-import edu.cmu.tetrad.util.JOptionUtils;
-import edu.cmu.tetrad.util.NamingProtocol;
-import edu.cmu.tetrad.util.Parameters;
-import edu.cmu.tetrad.util.TetradLogger;
-import edu.cmu.tetrad.util.TetradLoggerConfig;
+import edu.cmu.tetrad.graph.*;
+import edu.cmu.tetrad.session.*;
+import edu.cmu.tetrad.util.*;
 import edu.cmu.tetradapp.editor.EditorWindow;
 import edu.cmu.tetradapp.editor.FinalizingParameterEditor;
 import edu.cmu.tetradapp.editor.ParameterEditor;
-import edu.cmu.tetradapp.model.SessionNodeWrapper;
-import edu.cmu.tetradapp.model.SessionWrapper;
-import edu.cmu.tetradapp.model.UnlistedSessionModel;
+import edu.cmu.tetradapp.model.*;
 import edu.cmu.tetradapp.util.DesktopController;
 import edu.cmu.tetradapp.util.SessionEditorIndirectRef;
 import edu.cmu.tetradapp.util.WatchedProcess;
 import edu.cmu.tetradapp.workbench.DisplayNode;
-import java.awt.BorderLayout;
-import java.awt.Component;
-import java.awt.Container;
-import java.awt.Dimension;
-import java.awt.GridLayout;
+
+import javax.swing.*;
+import javax.swing.border.TitledBorder;
+import javax.swing.event.InternalFrameAdapter;
+import javax.swing.event.InternalFrameEvent;
+import javax.swing.event.MenuDragMouseEvent;
+import javax.swing.event.MenuDragMouseListener;
+import java.awt.*;
 import java.awt.Point;
-import java.awt.Window;
-import java.awt.event.ComponentAdapter;
-import java.awt.event.ComponentEvent;
-import java.awt.event.MouseAdapter;
-import java.awt.event.MouseEvent;
+import java.awt.event.*;
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
+import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
-import javax.swing.AbstractButton;
-import javax.swing.JCheckBox;
-import javax.swing.JComponent;
-import javax.swing.JDialog;
-import javax.swing.JLayeredPane;
-import javax.swing.JMenuItem;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-import javax.swing.JPopupMenu;
-import javax.swing.SwingUtilities;
-import javax.swing.ToolTipManager;
-import javax.swing.border.TitledBorder;
-import javax.swing.event.InternalFrameAdapter;
-import javax.swing.event.InternalFrameEvent;
 
 /**
  * Wraps a SessionNodeWrapper as a DisplayNode for presentation in a
@@ -89,8 +63,6 @@ import javax.swing.event.InternalFrameEvent;
  */
 public final class SessionEditorNode extends DisplayNode {
 
-    private static final long serialVersionUID = -6145843764762585351L;
-
     /**
      * If an editor has been opened, this is a reference to that editor. Used to
      * close the editor if necessary.
@@ -107,6 +79,7 @@ public final class SessionEditorNode extends DisplayNode {
      */
     private SessionWrapper sessionWrapper;
 
+
     /**
      * The configuration for this editor node.
      */
@@ -114,11 +87,9 @@ public final class SessionEditorNode extends DisplayNode {
     private SessionEditorWorkbench sessionWorkbench;
 
     //===========================CONSTRUCTORS==============================//
+
     /**
      * Wraps the given SessionNodeWrapper as a SessionEditorNode.
-     *
-     * @param modelNode
-     * @param simulationStudy
      */
     public SessionEditorNode(SessionNodeWrapper modelNode, SimulationStudy simulationStudy) {
         setModelNode(modelNode);
@@ -143,11 +114,10 @@ public final class SessionEditorNode extends DisplayNode {
             add((JComponent) getSessionDisplayComp(), BorderLayout.CENTER);
             setSelected(false);
             this.addMouseListener(new MouseAdapter() {
-                @Override
                 public void mousePressed(MouseEvent e) {
                     if (SwingUtilities.isRightMouseButton(e)) {
-                        ToolTipManager toolTipManager
-                                = ToolTipManager.sharedInstance();
+                        ToolTipManager toolTipManager =
+                                ToolTipManager.sharedInstance();
                         toolTipManager.setInitialDelay(750);
                         getNotePopup().show(SessionEditorNode.this, e.getX(), e.getY());
                     }
@@ -166,6 +136,7 @@ public final class SessionEditorNode extends DisplayNode {
     }
 
     //===========================PUBLIC METHODS============================//
+
     public final void adjustToModel() {
         String acronym = getAcronym();
 
@@ -218,7 +189,7 @@ public final class SessionEditorNode extends DisplayNode {
         }
     }
 
-    @Override
+
     public void doDoubleClickAction() {
         doDoubleClickAction(null);
     }
@@ -228,7 +199,6 @@ public final class SessionEditorNode extends DisplayNode {
      *
      * @param sessionWrapper Needed to allow the option of deleting edges
      */
-    @Override
     public void doDoubleClickAction(Graph sessionWrapper) {
         this.sessionWrapper = (SessionWrapper) sessionWrapper;
         Window owner = (Window) getTopLevelAncestor();
@@ -274,7 +244,6 @@ public final class SessionEditorNode extends DisplayNode {
             EditorWindow editorWindow = new EditorWindow(editor, editor.getName(), "Done", cloned, this);
 
             editorWindow.addInternalFrameListener(new InternalFrameAdapter() {
-                @Override
                 public void internalFrameClosing(InternalFrameEvent e) {
                     if (getChildren().iterator().hasNext()) {
                         finishedEditingDialog();
@@ -321,6 +290,7 @@ public final class SessionEditorNode extends DisplayNode {
 //                    }
 //                }
 //            }
+
 //                Class[] consistentModelClasses = child.getConsistentModelClasses(false);
 //                if (consistentModelClasses.length == 0) {
 //                    child.removeParent(sessionNode);
@@ -331,14 +301,26 @@ public final class SessionEditorNode extends DisplayNode {
 //                    Edge edge = sessionWrapper.getEdge(node1, node2);
 //                    sessionWrapper.removeEdge(edge);
 //                }
-        } catch (CouldNotCreateModelException e) {
+        } catch (
+                CouldNotCreateModelException e
+                )
+
+        {
             SessionUtils.showPermissibleParentsDialog(e.getModelClass(),
                     SessionEditorNode.this, true, true);
             e.printStackTrace();
 
-        } catch (ClassCastException e) {
+        } catch (
+                ClassCastException e
+                )
+
+        {
             e.printStackTrace();
-        } catch (Exception e) {
+        } catch (
+                Exception e
+                )
+
+        {
             Throwable cause = e;
 
             while (cause.getCause() != null) {
@@ -363,23 +345,23 @@ public final class SessionEditorNode extends DisplayNode {
      *
      * @param selected the selection status of the node (true or false).
      */
-    @Override
     public void setSelected(boolean selected) {
         super.setSelected(selected);
         getSessionDisplayComp().setSelected(selected);
     }
 
 //===========================PRIVATE METHODS===========================//
+
     private SessionEditorWorkbench getSessionWorkbench() {
         if (sessionWorkbench == null) {
-            SessionEditorIndirectRef sessionEditorRef
-                    = DesktopController.getInstance().getFrontmostSessionEditor();
+            SessionEditorIndirectRef sessionEditorRef =
+                    DesktopController.getInstance().getFrontmostSessionEditor();
             SessionEditor sessionEditor = (SessionEditor) sessionEditorRef;
 
             if (sessionEditor == null) {
                 DesktopController.getInstance().newSessionEditor();
-                sessionEditorRef
-                        = DesktopController.getInstance().getFrontmostSessionEditor();
+                sessionEditorRef =
+                        DesktopController.getInstance().getFrontmostSessionEditor();
                 sessionEditor = (SessionEditor) sessionEditorRef;
             }
 
@@ -388,15 +370,15 @@ public final class SessionEditorNode extends DisplayNode {
         return sessionWorkbench;
     }
 
+
     private void addListeners(final SessionEditorNode sessionEditorNode,
-            final SessionNodeWrapper modelNode) {
+                              final SessionNodeWrapper modelNode) {
         // Add a mouse listener for popups.
         sessionEditorNode.addMouseListener(new MouseAdapter() {
-            @Override
             public void mousePressed(MouseEvent e) {
                 if (SwingUtilities.isRightMouseButton(e)) {
-                    ToolTipManager toolTipManager
-                            = ToolTipManager.sharedInstance();
+                    ToolTipManager toolTipManager =
+                            ToolTipManager.sharedInstance();
                     toolTipManager.setInitialDelay(750);
                     sessionEditorNode.getPopup().show(sessionEditorNode, e.getX(), e.getY());
                 }
@@ -420,8 +402,8 @@ public final class SessionEditorNode extends DisplayNode {
 //                }
 //            }
 //        });
+
         sessionEditorNode.addComponentListener(new ComponentAdapter() {
-            @Override
             public void componentMoved(ComponentEvent e) {
                 sessionEditorNode.getSimulationStudy().getSession().setSessionChanged(true);
             }
@@ -430,8 +412,6 @@ public final class SessionEditorNode extends DisplayNode {
         SessionNode sessionNode = modelNode.getSessionNode();
 
         sessionNode.addSessionListener(new SessionAdapter() {
-
-            @Override
             public void modelCreated(SessionEvent sessionEvent) {
                 sessionEditorNode.adjustToModel();
 
@@ -445,7 +425,6 @@ public final class SessionEditorNode extends DisplayNode {
                 }
             }
 
-            @Override
             public void modelDestroyed(SessionEvent sessionEvent) {
                 sessionEditorNode.adjustToModel();
 
@@ -458,7 +437,6 @@ public final class SessionEditorNode extends DisplayNode {
                 }
             }
 
-            @Override
             public void modelUnclear(SessionEvent sessionEvent) {
                 try {
                     if (simulationStudy == null) {
@@ -473,13 +451,14 @@ public final class SessionEditorNode extends DisplayNode {
                 } catch (Exception e) {
                     String message = e.getMessage();
 
-                    message = "I could not make a model for this box, sorry. Maybe the \n"
-                            + "parents aren't right or have not been constructed yet.";
+                    message = "I could not make a model for this box, sorry. Maybe the \n" +
+                            "parents aren't right or have not been constructed yet.";
 
                     e.printStackTrace();
 
 //                    throw new IllegalArgumentException("I could not make a model for this box, sorry. Maybe the \n" +
 //                            "parents aren't right or have not been constructed yet.");
+
                     JOptionPane.showMessageDialog(sessionEditorNode, message);
                 }
             }
@@ -487,17 +466,15 @@ public final class SessionEditorNode extends DisplayNode {
     }
 
     /**
-     * Adds a property change listener that listends for "changeNodeLabel"
-     * events.
+     * Adds a property change listener that listends for "changeNodeLabel" events.
      */
     private void addEditorListener(JPanel editor) {
         editor.addPropertyChangeListener(new PropertyChangeListener() {
-            @Override
             public void propertyChange(PropertyChangeEvent evt) {
                 if ("changeNodeLabel".equals(evt.getPropertyName())) {
                     getDisplayComp().setName((String) evt.getNewValue());
-                    SessionNodeWrapper wrapper
-                            = (SessionNodeWrapper) getModelNode();
+                    SessionNodeWrapper wrapper =
+                            (SessionNodeWrapper) getModelNode();
                     wrapper.setSessionName((String) evt.getNewValue());
                     adjustToModel();
                 }
@@ -505,6 +482,7 @@ public final class SessionEditorNode extends DisplayNode {
         });
     }
 
+
     /**
      * Creates a popup for a note node.
      *
@@ -515,70 +493,78 @@ public final class SessionEditorNode extends DisplayNode {
 
         JMenuItem renameBox = new JMenuItem("Rename note");
         renameBox.setToolTipText("<html>Renames this note.</html>");
-        renameBox.addActionListener((e) -> {
-            Component centeringComp = SessionEditorNode.this;
-            String name
-                    = JOptionPane.showInputDialog(centeringComp, "New name:");
+        renameBox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                Component centeringComp = SessionEditorNode.this;
+                String name =
+                        JOptionPane.showInputDialog(centeringComp, "New name:");
 
-            if (!NamingProtocol.isLegalName(name)) {
-                JOptionPane.showMessageDialog(centeringComp,
-                        NamingProtocol.getProtocolDescription());
-                return;
-            }
+                if (!NamingProtocol.isLegalName(name)) {
+                    JOptionPane.showMessageDialog(centeringComp,
+                            NamingProtocol.getProtocolDescription());
+                    return;
+                }
 
-            SessionNodeWrapper wrapper
-                    = (SessionNodeWrapper) getModelNode();
-            wrapper.setSessionName(name);
-            getSessionDisplayComp().setName(name);
-            adjustToModel();
+                SessionNodeWrapper wrapper =
+                        (SessionNodeWrapper) getModelNode();
+                wrapper.setSessionName(name);
+                getSessionDisplayComp().setName(name);
+                adjustToModel();
+            }
         });
 
         JMenuItem cloneBox = new JMenuItem("Clone Note");
-        cloneBox.setToolTipText("<html>"
-                + "Makes a copy of this session note and its contents. To clone<br>"
-                + "a whole subgraph, or to paste into a different sessions, select<br>"
-                + "the subgraph and use the Copy/Paste gadgets in the Edit menu."
-                + "</html>");
-        cloneBox.addActionListener((e) -> {
-            firePropertyChange("cloneMe", null, SessionEditorNode.this);
+        cloneBox.setToolTipText("<html>" +
+                "Makes a copy of this session note and its contents. To clone<br>" +
+                "a whole subgraph, or to paste into a different sessions, select<br>" +
+                "the subgraph and use the Copy/Paste gadgets in the Edit menu." +
+                "</html>");
+        cloneBox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                firePropertyChange("cloneMe", null, SessionEditorNode.this);
+            }
         });
 
         JMenuItem deleteBox = new JMenuItem("Delete Note");
         deleteBox.setToolTipText(
                 "<html>Deletes this note from the workbench</html>");
 
-        deleteBox.addActionListener((e) -> {
-            if (getSessionNode().getModel() == null) {
-                Component centeringComp = SessionEditorNode.this;
-                int ret = JOptionPane.showConfirmDialog(centeringComp,
-                        "Really delete note?");
+        deleteBox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                if (getSessionNode().getModel() == null) {
+                    Component centeringComp = SessionEditorNode.this;
+                    int ret = JOptionPane.showConfirmDialog(centeringComp,
+                            "Really delete note?");
 
-                if (ret != JOptionPane.YES_OPTION) {
-                    return;
-                }
-            } else {
-                Component centeringComp = SessionEditorNode.this;
-                int ret = JOptionPane.showConfirmDialog(centeringComp,
-                        "<html>"
-                        + "Really delete note? Any information it contains will<br>"
-                        + "be destroyed." + "</html>");
+                    if (ret != JOptionPane.YES_OPTION) {
+                        return;
+                    }
+                } else {
+                    Component centeringComp = SessionEditorNode.this;
+                    int ret = JOptionPane.showConfirmDialog(centeringComp,
+                            "<html>" +
+                                    "Really delete note? Any information it contains will<br>" +
+                                    "be destroyed." + "</html>");
 
-                if (ret != JOptionPane.YES_OPTION) {
-                    return;
+                    if (ret != JOptionPane.YES_OPTION) {
+                        return;
+                    }
                 }
-            }
 
-            firePropertyChange("deleteNode", null, null);
+                firePropertyChange("deleteNode", null, null);
+            }
         });
 
         JMenuItem help = new JMenuItem("Help");
         deleteBox.setToolTipText("<html>Shows help for this box.</html>");
 
-        help.addActionListener((e) -> {
-            SessionNodeWrapper sessionNodeWrapper
-                    = (SessionNodeWrapper) getModelNode();
-            SessionNode sessionNode = sessionNodeWrapper.getSessionNode();
-            showInfoBoxForModel(sessionNode, sessionNode.getModelClasses());
+        help.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                SessionNodeWrapper sessionNodeWrapper =
+                        (SessionNodeWrapper) getModelNode();
+                SessionNode sessionNode = sessionNodeWrapper.getSessionNode();
+                showInfoBoxForModel(sessionNode, sessionNode.getModelClasses());
+            }
         });
 
         popup.add(renameBox);
@@ -603,195 +589,218 @@ public final class SessionEditorNode extends DisplayNode {
         popup = new JPopupMenu();
 
         JMenuItem createModel = new JMenuItem("Create Model");
-        createModel.setToolTipText("<html>Creates a new model for this node"
-                + "<br>of the type selected.</html>");
+        createModel.setToolTipText("<html>Creates a new model for this node" +
+                "<br>of the type selected.</html>");
 
-        createModel.addActionListener((e) -> {
-            try {
-                if (getSessionNode().getModel() == null) {
-                    createModel(false);
-                } else {
+        createModel.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                try {
+                    if (getSessionNode().getModel() == null) {
+                        createModel(false);
+                    } else {
+                        Component centeringComp = SessionEditorNode.this;
+                        JOptionPane.showMessageDialog(centeringComp,
+                                "Please destroy the model model first.");
+                    }
+                } catch (Exception e1) {
                     Component centeringComp = SessionEditorNode.this;
                     JOptionPane.showMessageDialog(centeringComp,
-                            "Please destroy the model model first.");
+                            "Could not create a model for this box.");
+                    e1.printStackTrace();
                 }
-            } catch (Exception e1) {
-                Component centeringComp = SessionEditorNode.this;
-                JOptionPane.showMessageDialog(centeringComp,
-                        "Could not create a model for this box.");
-                e1.printStackTrace();
             }
         });
 
         JMenuItem editModel = new JMenuItem("Edit Model");
         editModel.setToolTipText("<html>Edits the model in this node.</html>");
 
-        editModel.addActionListener((e) -> {
-            try {
-                if (getSessionNode().getModel() == null) {
+        editModel.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                try {
+                    if (getSessionNode().getModel() == null) {
+                        Component centeringComp = SessionEditorNode.this;
+                        JOptionPane.showMessageDialog(centeringComp,
+                                "Sorry, no model has been created yet; there's nothing to edit.");
+                    } else {
+                        doDoubleClickAction();
+                    }
+                } catch (Exception e1) {
                     Component centeringComp = SessionEditorNode.this;
                     JOptionPane.showMessageDialog(centeringComp,
-                            "Sorry, no model has been created yet; there's nothing to edit.");
-                } else {
-                    doDoubleClickAction();
+                            "Double click failed. See console for exception.");
+                    e1.printStackTrace();
                 }
-            } catch (Exception e1) {
-                Component centeringComp = SessionEditorNode.this;
-                JOptionPane.showMessageDialog(centeringComp,
-                        "Double click failed. See console for exception.");
-                e1.printStackTrace();
             }
         });
 
         JMenuItem destroyModel = new JMenuItem("Destroy Model");
-        destroyModel.setToolTipText("<html>Destroys the model for this node, "
-                + "<br>if it has one, destroying any "
-                + "<br>downstream models as well.</html>");
+        destroyModel.setToolTipText("<html>Destroys the model for this node, " +
+                "<br>if it has one, destroying any " +
+                "<br>downstream models as well.</html>");
 
-        destroyModel.addActionListener((e) -> {
-            Component centeringComp = SessionEditorNode.this;
+        destroyModel.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                Component centeringComp = SessionEditorNode.this;
 
-            if (getSessionNode().getModel() == null) {
-                JOptionPane.showMessageDialog(centeringComp,
-                        "Sorry, this box does not contain a model to destroy.");
-                return;
-            }
+                if (getSessionNode().getModel() == null) {
+                    JOptionPane.showMessageDialog(centeringComp,
+                            "Sorry, this box does not contain a model to destroy.");
+                    return;
+                }
 
-            Set<SessionNode> children = getSessionNode().getChildren();
-            boolean found = false;
+                Set<SessionNode> children = getSessionNode().getChildren();
+                boolean found = false;
 
-            for (SessionNode child : children) {
-                if (child.getModel() != null) {
-                    found = true;
+                for (SessionNode child : children) {
+                    if (child.getModel() != null) {
+                        found = true;
+                    }
                 }
-            }
 
-            if (found) {
-                int ret = JOptionPane.showConfirmDialog(centeringComp,
-                        "Destroying the model in this box will also destroy models in any boxes\n"
-                        + "downstream. Is that OK?", null,
-                        JOptionPane.OK_CANCEL_OPTION,
-                        JOptionPane.WARNING_MESSAGE);
+                if (found) {
+                    int ret = JOptionPane.showConfirmDialog(centeringComp,
+                            "Destroying the model in this box will also destroy models in any boxes\n" +
+                                    "downstream. Is that OK?", null,
+                            JOptionPane.OK_CANCEL_OPTION,
+                            JOptionPane.WARNING_MESSAGE);
 
-                if (ret != JOptionPane.YES_OPTION) {
-                    return;
+                    if (ret != JOptionPane.YES_OPTION) {
+                        return;
+                    }
                 }
-            }
 
-            destroyModel();
+                destroyModel();
+            }
         });
 
-        JMenuItem propagateDownstream
-                = new JMenuItem("Propagate changes downstream");
-        propagateDownstream.setToolTipText("<html>"
-                + "Fills in this box and downstream boxes with models,"
-                + "<br>overwriting any models that already exist.</html>");
+        JMenuItem propagateDownstream =
+                new JMenuItem("Propagate changes downstream");
+        propagateDownstream.setToolTipText("<html>" +
+                "Fills in this box and downstream boxes with models," +
+                "<br>overwriting any models that already exist.</html>");
 
-        propagateDownstream.addActionListener((e) -> {
-            Component centeringComp = SessionEditorNode.this;
+        propagateDownstream.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                Component centeringComp = SessionEditorNode.this;
 
-            if (getSessionNode().getModel() != null && !getSessionNode().getChildren().isEmpty()) {
-                int ret = JOptionPane.showConfirmDialog(centeringComp,
-                        "You will be rewriting all downstream models. Is that OK?",
-                        "Confirm",
-                        JOptionPane.OK_CANCEL_OPTION,
-                        JOptionPane.WARNING_MESSAGE);
+                if (getSessionNode().getModel() != null && !getSessionNode().getChildren().isEmpty()) {
+                    int ret = JOptionPane.showConfirmDialog(centeringComp,
+                            "You will be rewriting all downstream models. Is that OK?",
+                            "Confirm",
+                            JOptionPane.OK_CANCEL_OPTION,
+                            JOptionPane.WARNING_MESSAGE);
 
-                if (ret != JOptionPane.YES_OPTION) {
-                    return;
+                    if (ret != JOptionPane.YES_OPTION) {
+                        return;
+                    }
+                }
+                try {
+                    createDescendantModels(true);
+                } catch (RuntimeException e1) {
+                    JOptionPane.showMessageDialog(centeringComp,
+                            "Could not complete the creation of descendant models.");
+                    e1.printStackTrace();
                 }
-            }
-            try {
-                createDescendantModels(true);
-            } catch (RuntimeException e1) {
-                JOptionPane.showMessageDialog(centeringComp,
-                        "Could not complete the creation of descendant models.");
-                e1.printStackTrace();
             }
         });
 
         JMenuItem renameBox = new JMenuItem("Rename Box");
         renameBox.setToolTipText("<html>Renames this session box.</html>");
-        renameBox.addActionListener((e) -> {
-            Component centeringComp = SessionEditorNode.this;
-            String name
-                    = JOptionPane.showInputDialog(centeringComp, "New name:");
+        renameBox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                Component centeringComp = SessionEditorNode.this;
+                String name =
+                        JOptionPane.showInputDialog(centeringComp, "New name:");
 
-            if (!NamingProtocol.isLegalName(name)) {
-                JOptionPane.showMessageDialog(centeringComp,
-                        NamingProtocol.getProtocolDescription());
-                return;
-            }
+                if (!NamingProtocol.isLegalName(name)) {
+                    JOptionPane.showMessageDialog(centeringComp,
+                            NamingProtocol.getProtocolDescription());
+                    return;
+                }
 
-            SessionNodeWrapper wrapper
-                    = (SessionNodeWrapper) getModelNode();
-            wrapper.setSessionName(name);
-            getSessionDisplayComp().setName(name);
-            adjustToModel();
+                SessionNodeWrapper wrapper =
+                        (SessionNodeWrapper) getModelNode();
+                wrapper.setSessionName(name);
+                getSessionDisplayComp().setName(name);
+                adjustToModel();
+            }
         });
 
         JMenuItem cloneBox = new JMenuItem("Clone Box");
-        cloneBox.setToolTipText("<html>"
-                + "Makes a copy of this session box and its contents. To clone<br>"
-                + "a whole subgraph, or to paste into a different sessions, select<br>"
-                + "the subgraph and use the Copy/Paste gadgets in the Edit menu."
-                + "</html>");
-        cloneBox.addActionListener((e) -> {
-            firePropertyChange("cloneMe", null, SessionEditorNode.this);
+        cloneBox.setToolTipText("<html>" +
+                "Makes a copy of this session box and its contents. To clone<br>" +
+                "a whole subgraph, or to paste into a different sessions, select<br>" +
+                "the subgraph and use the Copy/Paste gadgets in the Edit menu." +
+                "</html>");
+        cloneBox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                firePropertyChange("cloneMe", null, SessionEditorNode.this);
+            }
         });
 
         JMenuItem deleteBox = new JMenuItem("Delete Box");
         deleteBox.setToolTipText(
                 "<html>Deletes this box from the workbench</html>");
 
-        deleteBox.addActionListener((e) -> {
-            Component centeringComp = SessionEditorNode.this;
-            int ret = JOptionPane.showConfirmDialog(centeringComp,
-                    "Are you sure you want to delete this box? It contains some work.",
-                    null, JOptionPane.YES_NO_OPTION);
+        deleteBox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                Component centeringComp = SessionEditorNode.this;
+                int ret = JOptionPane.showConfirmDialog(centeringComp,
+                        "Are you sure you want to delete this box? It contains some work.",
+                        null, JOptionPane.YES_NO_OPTION);
 
-            if (ret != JOptionPane.YES_OPTION) {
-                return;
-            }
+                if (ret != JOptionPane.YES_OPTION) {
+                    return;
+                }
 
-            firePropertyChange("deleteNode", null, null);
+                firePropertyChange("deleteNode", null, null);
+            }
         });
 
-        popup.add(createModel);
+        JMenuItem editSimulationParameters =
+                new JMenuItem("Edit Parameters...");
+        editSimulationParameters.setToolTipText("<html>");
+
+        editSimulationParameters.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                SessionModel model = getSessionNode().getModel();
+                Class modelClass;
+
+                if (model == null) {
+                    modelClass = determineTheModelClass(getSessionNode());
+                } else {
+                    modelClass = model.getClass();
+                }
 
-        SessionModel model = getSessionNode().getModel();
-        Class modelClass = (model == null)
-                ? determineTheModelClass(getSessionNode())
-                : model.getClass();
-        if (getSessionNode().existsParameterizedConstructor(modelClass)) {
-            final ParameterEditor paramEditor = getParameterEditor(modelClass);
-
-            if (paramEditor != null) {
-                JMenuItem editSimulationParameters = new JMenuItem("Edit Parameters...");
-                editSimulationParameters.setToolTipText("<html>");
-                editSimulationParameters.addActionListener((e) -> {
-                    Parameters param = getSessionNode().getParam(modelClass);
-                    Object[] arguments = getSessionNode().getModelConstructorArguments(modelClass);
-
-                    if (param != null) {
-                        try {
-                            editParameters(modelClass, param, arguments);
-                            int ret = JOptionPane.showConfirmDialog(JOptionUtils.centeringComp(),
-                                    "Should I overwrite the contents of this box and all delete the contents\n"
-                                            + "of all boxes downstream?",
-                                    "Double check...", JOptionPane.YES_NO_OPTION);
-                            if (ret == JOptionPane.YES_OPTION) {
-                                getSessionNode().destroyModel();
-                                getSessionNode().createModel(modelClass, true);
-                            }
-                        } catch (Exception e1) {
-                            e1.printStackTrace();
+                if (!getSessionNode().existsParameterizedConstructor(
+                        modelClass)) {
+                    JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
+                            "There is no parameterization for this model.");
+                    return;
+                }
+
+                Parameters param = getSessionNode().getParam(modelClass);
+                Object[] arguments =
+                        getSessionNode().getModelConstructorArguments(
+                                modelClass);
+
+                if (param != null) {
+                    try {
+                        editParameters(modelClass, param, arguments);
+                        int ret = JOptionPane.showConfirmDialog(JOptionUtils.centeringComp(),
+                                "Should I overwrite the contents of this box and all delete the contents\n" +
+                                        "of all boxes downstream?",
+                                "Double check...", JOptionPane.YES_NO_OPTION);
+                        if (ret == JOptionPane.YES_OPTION) {
+                            getSessionNode().destroyModel();
+                            getSessionNode().createModel(modelClass, true);
                         }
+                    } catch (Exception e1) {
+                        e1.printStackTrace();
                     }
-                });
-                popup.add(editSimulationParameters);
+                }
             }
-        }
+        });
 
 //        final SessionNode thisNode = getSessionNode();
 //
@@ -802,8 +811,9 @@ public final class SessionEditorNode extends DisplayNode {
 //        addConsistentChildBoxMenus(popup, getConsistentChildBoxTypes(thisNode, null));
 //
 //        popup.addSeparator();
-        popup.add(createModel);
 
+        popup.add(createModel);
+        popup.add(editSimulationParameters);
         popup.add(editModel);
         popup.add(destroyModel);
 
@@ -821,11 +831,6 @@ public final class SessionEditorNode extends DisplayNode {
         return popup;
     }
 
-    private ParameterEditor getParameterEditor(Class modelClass) {
-        SessionNodeModelConfig modelConfig = this.config.getModelConfig(modelClass);
-        return modelConfig.getParameterEditorInstance();
-    }
-
 //    private void addConsistentChildBoxMenus(JPopupMenu menu, List<String> consistentChildBoxes) {
 //        for (String _type : consistentChildBoxes) {
 //            final JMenuItem menuItem = new JMenuItem(_type);
@@ -843,6 +848,7 @@ public final class SessionEditorNode extends DisplayNode {
 //            menu.add(menuItem);
 //        }
 //    }
+
 //    private JMenu addConsistentChildBoxMenus(List<String> consistentChildBoxes) {
 //        JMenu newChildren = new JMenu("New Child Box");
 //
@@ -862,6 +868,7 @@ public final class SessionEditorNode extends DisplayNode {
 //        }
 //        return newChildren;
 //    }
+
 //    private JMenu addConsistentParentMenuItems(JPopupMenu menu, List<SessionNode> consistentParentNodes) {
 //        final JMenu newParents = new JMenu("New Parent Box");
 //
@@ -882,6 +889,7 @@ public final class SessionEditorNode extends DisplayNode {
 //
 //        return newParents;
 //    }
+
 //    private List<String> getConsistentChildBoxTypes(SessionNode thisNode, SessionModel model) {
 //        List<String> consistentChildBoxes = new ArrayList<>();
 //
@@ -904,6 +912,7 @@ public final class SessionEditorNode extends DisplayNode {
 //
 //        return consistentChildBoxes;
 //    }
+
 //    private List<SessionNode> getConsistentParentBoxTypes(SessionNode thisNode) {
 //        List<SessionNode> consistentParentBoxes = new ArrayList<>();
 //
@@ -921,6 +930,8 @@ public final class SessionEditorNode extends DisplayNode {
 //
 //        return consistentParentBoxes;
 //    }
+
+
     /**
      * Adds the "Edit logger" option if applicable.
      */
@@ -930,16 +941,18 @@ public final class SessionEditorNode extends DisplayNode {
         final TetradLoggerConfig config = sessionNode.getLoggerConfig();
         if (config != null) {
             JMenuItem item = new JMenuItem("Edit Logger Settings ...");
-            item.addActionListener((e) -> {
-                showLogConfig(config);
+            item.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    showLogConfig(config);
+                }
             });
             menu.add(item);
         }
     }
 
+
     /**
-     * Shows a dialog that allows the user to change the settings for the box's
-     * model logger.
+     * Shows a dialog that allows the user to change the settings for the box's model logger.
      */
     private void showLogConfig(final TetradLoggerConfig config) {
         List<TetradLoggerConfig.Event> events = config.getSupportedEvents();
@@ -950,9 +963,11 @@ public final class SessionEditorNode extends DisplayNode {
             JCheckBox checkBox = new JCheckBox(event.getDescription());
             checkBox.setHorizontalTextPosition(AbstractButton.RIGHT);
             checkBox.setSelected(config.isEventActive(id));
-            checkBox.addActionListener((e) -> {
-                JCheckBox box = (JCheckBox) e.getSource();
-                config.setEventActive(id, box.isSelected());
+            checkBox.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    JCheckBox box = (JCheckBox) e.getSource();
+                    config.setEventActive(id, box.isSelected());
+                }
             });
             panel.add(checkBox);
         }
@@ -961,18 +976,18 @@ public final class SessionEditorNode extends DisplayNode {
         JOptionPane.showMessageDialog(this, panel, "Edit Events to Log", JOptionPane.PLAIN_MESSAGE);
     }
 
+
     private void executeSessionNode(final SessionNode sessionNode,
-            final boolean overwrite) {
+                                    final boolean overwrite) {
         Window owner = (Window) getTopLevelAncestor();
 
         new WatchedProcess(owner) {
-            @Override
             public void watch() {
                 Class c = SessionEditorWorkbench.class;
                 Container container = SwingUtilities.getAncestorOfClass(c,
                         SessionEditorNode.this);
-                SessionEditorWorkbench workbench
-                        = (SessionEditorWorkbench) container;
+                SessionEditorWorkbench workbench =
+                        (SessionEditorWorkbench) container;
 
                 System.out.println("Executing" + sessionNode);
 
@@ -985,13 +1000,12 @@ public final class SessionEditorNode extends DisplayNode {
         Window owner = (Window) getTopLevelAncestor();
 
         new WatchedProcess(owner) {
-            @Override
             public void watch() {
                 Class clazz = SessionEditorWorkbench.class;
                 Container container = SwingUtilities.getAncestorOfClass(clazz,
                         SessionEditorNode.this);
-                SessionEditorWorkbench workbench
-                        = (SessionEditorWorkbench) container;
+                SessionEditorWorkbench workbench =
+                        (SessionEditorWorkbench) container;
 
                 if (workbench != null) {
                     workbench.getSimulationStudy().createDescendantModels(
@@ -1022,9 +1036,9 @@ public final class SessionEditorNode extends DisplayNode {
         Object[] options = {"Execute", "Break Edges"};
         Component centeringComp = SessionEditorNode.this;
         int selection = JOptionPane.showOptionDialog(centeringComp,
-                "Changing this node will affect its children.\n"
-                + "Click on \"Execute\" to percolate changes down.\n"
-                + "Click on \"Break Edges\" to leave the children the same.",
+                "Changing this node will affect its children.\n" +
+                        "Click on \"Execute\" to percolate changes down.\n" +
+                        "Click on \"Break Edges\" to leave the children the same.",
                 "Warning", JOptionPane.DEFAULT_OPTION,
                 JOptionPane.WARNING_MESSAGE, null, options, options[0]);
 
@@ -1037,15 +1051,15 @@ public final class SessionEditorNode extends DisplayNode {
 
                 // only break edges to children.
                 if (edge.getNode2() == getModelNode()) {
-                    SessionNodeWrapper otherWrapper
-                            = (SessionNodeWrapper) edge.getNode1();
+                    SessionNodeWrapper otherWrapper =
+                            (SessionNodeWrapper) edge.getNode1();
                     SessionNode other = otherWrapper.getSessionNode();
                     if (getChildren().contains(other)) {
                         sessionWrapper.removeEdge(edge);
                     }
                 } else {
-                    SessionNodeWrapper otherWrapper
-                            = (SessionNodeWrapper) edge.getNode2();
+                    SessionNodeWrapper otherWrapper =
+                            (SessionNodeWrapper) edge.getNode2();
                     SessionNode other = otherWrapper.getSessionNode();
                     if (getChildren().contains(other)) {
                         sessionWrapper.removeEdge(edge);
@@ -1060,7 +1074,8 @@ public final class SessionEditorNode extends DisplayNode {
      * parent models.
      *
      * @throws IllegalStateException if the model cannot be created. The reason
-     * why the model cannot be created is in the message of the exception.
+     *                               why the model cannot be created is in the
+     *                               message of the exception.
      */
     public boolean createModel(boolean simulation) throws Exception {
         if (getSessionNode().getModel() != null) {
@@ -1124,10 +1139,11 @@ public final class SessionEditorNode extends DisplayNode {
     }
 
     /**
-     * @return the selected model class, or null if no model class was selected.
+     * @return the selected model class, or null if no model class was
+     * selected.
      */
     private Class getModelClassFromUser(Class[] modelClasses,
-            boolean cancelable) {
+                                        boolean cancelable) {
 
         // Count the number of model classes that can be listed for the user;
         // if there's only one, don't ask the user for input.
@@ -1139,10 +1155,11 @@ public final class SessionEditorNode extends DisplayNode {
             }
         }
 
-        if (reducedList.isEmpty()) {
+        if (reducedList.size() == 0) {
             throw new RuntimeException("There is no model to choose.");
         }
 
+
         SessionNodeWrapper sessionNodeWrapper = (SessionNodeWrapper) getModelNode();
         SessionNode sessionNode = sessionNodeWrapper.getSessionNode();
         ModelChooser chooser = this.config.getModelChooserInstance(sessionNode);
@@ -1182,7 +1199,7 @@ public final class SessionEditorNode extends DisplayNode {
             }
         }
 
-        if (reducedList.isEmpty()) {
+        if (reducedList.size() == 0) {
             throw new RuntimeException("There is no model to choose.");
         }
 
@@ -1196,8 +1213,8 @@ public final class SessionEditorNode extends DisplayNode {
     }
 
     public Set<SessionNode> getChildren() {
-        SessionNodeWrapper _sessionNodeWrapper
-                = (SessionNodeWrapper) getModelNode();
+        SessionNodeWrapper _sessionNodeWrapper =
+                (SessionNodeWrapper) getModelNode();
         SessionNode _sessionNode = _sessionNodeWrapper.getSessionNode();
         return _sessionNode.getChildren();
     }
@@ -1217,8 +1234,8 @@ public final class SessionEditorNode extends DisplayNode {
             if (newModelClasses != null) {
                 sessionNode.setModelClasses(newModelClasses);
             } else {
-                throw new RuntimeException("Model classes for this session "
-                        + "node were not set in the configuration.");
+                throw new RuntimeException("Model classes for this session " +
+                        "node were not set in the configuration.");
             }
         }
     }
@@ -1231,12 +1248,12 @@ public final class SessionEditorNode extends DisplayNode {
         getSessionNode().forgetOldModel();
     }
 
+
     /**
-     * Tries to edit the parameters, returns true if successfully otherwise
-     * false is returned
+     * Tries to edit the parameters, returns true if successfully otherwise false is returned
      */
     public boolean editParameters(final Class modelClass, Parameters params,
-            Object[] parentModels) {
+                                  Object[] parentModels) {
         if (parentModels == null) {
             throw new NullPointerException("Parent models array is null.");
         }
@@ -1245,8 +1262,8 @@ public final class SessionEditorNode extends DisplayNode {
             throw new NullPointerException("Parameters cannot be null.");
         }
 
-        final ParameterEditor paramEditor = getParameterEditor(modelClass);
-
+        SessionNodeModelConfig modelConfig = this.config.getModelConfig(modelClass);
+        final ParameterEditor paramEditor = modelConfig.getParameterEditorInstance();
         if (paramEditor == null) {
             // if no editor, then consider the params "edited".
             return true;
@@ -1274,8 +1291,8 @@ public final class SessionEditorNode extends DisplayNode {
                 null, null);
 
         // if finalizing editor, then deal with specially.
-        return ret == JOptionPane.OK_OPTION && (!(paramEditor instanceof FinalizingParameterEditor)
-                || ((FinalizingParameterEditor) paramEditor).finalizeEdit());
+        return ret == JOptionPane.OK_OPTION && (!(paramEditor instanceof FinalizingParameterEditor) ||
+                ((FinalizingParameterEditor) paramEditor).finalizeEdit());
 
     }
 
@@ -1324,9 +1341,11 @@ public final class SessionEditorNode extends DisplayNode {
             throw new NullPointerException("Name must not be null.");
         }
 
-        for (int i = name.length() - 1; i >= 0; i--) {
-            if (!Character.isDigit(name.charAt(i))) {
-                return name.substring(0, i + 1);
+        StringBuilder buffer = new StringBuilder(name);
+
+        for (int i = buffer.length() - 1; i >= 0; i--) {
+            if (!Character.isDigit(buffer.charAt(i))) {
+                return buffer.substring(0, i + 1);
             }
         }
 
@@ -1335,7 +1354,8 @@ public final class SessionEditorNode extends DisplayNode {
 
     /**
      * @return the model classes associated with the given button type.
-     * @throws NullPointerException if no classes are stored for the given type.
+     * @throws NullPointerException if no classes are stored for the given
+     *                              type.
      */
     private static Class[] modelClasses(String boxType) {
         TetradApplicationConfig config = TetradApplicationConfig.getInstance();
@@ -1355,3 +1375,7 @@ public final class SessionEditorNode extends DisplayNode {
         return (SessionDisplayComp) getDisplayComp();
     }
 }
+
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/editor/HpcJobActivityEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/editor/HpcJobActivityEditor.java
index af8bea02..2a537d00 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/editor/HpcJobActivityEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/editor/HpcJobActivityEditor.java
@@ -436,7 +436,7 @@ public class HpcJobActivityEditor extends JPanel implements FinalizingEditor {
 				rowData.add(hpcAccount.getConnectionName());
 
 				// Algorithm
-				rowData.add(hpcJobInfo.getAlgoId());
+				rowData.add(hpcJobInfo.getAlgorithmName());
 
 				// Dataset uploading progress
 				AlgorithmParamRequest algorParamReq = hpcJobInfo.getAlgorithmParamRequest();
@@ -552,7 +552,7 @@ public class HpcJobActivityEditor extends JPanel implements FinalizingEditor {
 				rowData.add(hpcAccount.getConnectionName());
 
 				// Algorithm
-				rowData.add(hpcJobInfo.getAlgoId());
+				rowData.add(hpcJobInfo.getAlgorithmName());
 
 				// Submitted time
 				rowData.add(hpcJobInfo.getSubmittedTime() != null
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/manager/HpcJobManager.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/manager/HpcJobManager.java
index df9f2049..b22bd1ed 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/manager/HpcJobManager.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/manager/HpcJobManager.java
@@ -101,7 +101,7 @@ public class HpcJobManager {
 		List<HpcJobInfo> pendingHpcJobInfo = hpcJobInfoService.findByStatus(-1);
 		if (pendingHpcJobInfo != null) {
 			for (HpcJobInfo hpcJobInfo : pendingHpcJobInfo) {
-				LOGGER.debug("resumePreProcessJobs: " + hpcJobInfo.getAlgoId() + " : "
+				LOGGER.debug("resumePreProcessJobs: " + hpcJobInfo.getAlgorithmName() + " : "
 						+ hpcJobInfo.getHpcAccount().getConnectionName() + " : "
 						+ hpcJobInfo.getAlgorithmParamRequest().getDatasetPath());
 
@@ -249,7 +249,7 @@ public class HpcJobManager {
 	public synchronized void addNewSubmittedHpcJob(final HpcJobInfo hpcJobInfo) {
 		HpcAccount hpcAccount = hpcJobInfo.getHpcAccount();
 		LOGGER.debug("addNewSubmittedHpcJob: connection: " + hpcAccount.getConnectionName());
-		LOGGER.debug("addNewSubmittedHpcJob: algorithm: " + hpcJobInfo.getAlgoId());
+		LOGGER.debug("addNewSubmittedHpcJob: algorithm: " + hpcJobInfo.getAlgorithmName());
 		LOGGER.debug("addNewSubmittedHpcJob: status: " + hpcJobInfo.getStatus());
 		LOGGER.debug("addNewSubmittedHpcJob: " + "pid: " + hpcJobInfo.getPid());
 
@@ -266,7 +266,7 @@ public class HpcJobManager {
 	public synchronized void removeFinishedHpcJob(final HpcJobInfo hpcJobInfo) {
 		HpcAccount hpcAccount = hpcJobInfo.getHpcAccount();
 		LOGGER.debug("removedFinishedHpcJob: connection: " + hpcAccount.getConnectionName());
-		LOGGER.debug("removedFinishedHpcJob: algorithm: " + hpcJobInfo.getAlgoId());
+		LOGGER.debug("removedFinishedHpcJob: algorithm: " + hpcJobInfo.getAlgorithmName());
 		LOGGER.debug("removedFinishedHpcJob: status: " + hpcJobInfo.getStatus());
 		LOGGER.debug("removedFinishedHpcJob: pid: " + hpcJobInfo.getPid());
 		Set<HpcJobInfo> hpcJobInfos = submittedHpcJobInfoMap.get(hpcAccount);
@@ -296,7 +296,7 @@ public class HpcJobManager {
 	public synchronized void removePendingHpcJob(final HpcJobInfo hpcJobInfo) {
 		HpcAccount hpcAccount = hpcJobInfo.getHpcAccount();
 		LOGGER.debug("removedPendingHpcJob: connection: " + hpcAccount.getConnectionName());
-		LOGGER.debug("removedPendingHpcJob: algorithm: " + hpcJobInfo.getAlgoId());
+		LOGGER.debug("removedPendingHpcJob: algorithm: " + hpcJobInfo.getAlgorithmName());
 		LOGGER.debug("removedPendingHpcJob: status: " + hpcJobInfo.getStatus());
 		LOGGER.debug("removedPendingHpcJob: pid: " + hpcJobInfo.getPid());
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/task/HpcJobPreProcessTask.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/task/HpcJobPreProcessTask.java
index 7897294b..22cccb03 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/task/HpcJobPreProcessTask.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/task/HpcJobPreProcessTask.java
@@ -2,9 +2,11 @@ package edu.cmu.tetradapp.app.hpc.task;
 
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.ArrayList;
 import java.util.Date;
-import java.util.HashSet;
-import java.util.Set;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -15,9 +17,7 @@ import edu.cmu.tetradapp.app.hpc.manager.HpcAccountService;
 import edu.cmu.tetradapp.app.hpc.manager.HpcJobManager;
 import edu.cmu.tetradapp.app.hpc.util.HpcAccountUtils;
 import edu.cmu.tetradapp.util.DesktopController;
-import edu.pitt.dbmi.ccd.rest.client.dto.algo.AlgoParameter;
 import edu.pitt.dbmi.ccd.rest.client.dto.algo.JobInfo;
-import edu.pitt.dbmi.ccd.rest.client.dto.algo.JvmOptions;
 import edu.pitt.dbmi.ccd.rest.client.dto.data.DataFile;
 import edu.pitt.dbmi.ccd.rest.client.service.data.DataUploadService;
 import edu.pitt.dbmi.ccd.rest.client.service.data.RemoteDataFileService;
@@ -28,6 +28,7 @@ import edu.pitt.dbmi.tetrad.db.entity.HpcAccount;
 import edu.pitt.dbmi.tetrad.db.entity.HpcJobInfo;
 import edu.pitt.dbmi.tetrad.db.entity.HpcJobLog;
 import edu.pitt.dbmi.tetrad.db.entity.HpcParameter;
+import edu.pitt.dbmi.tetrad.db.entity.JvmOption;
 
 /**
  * 
@@ -188,40 +189,42 @@ public class HpcJobPreProcessTask implements Runnable {
 
 			// Algorithm Job Preparation
 			edu.pitt.dbmi.ccd.rest.client.dto.algo.AlgorithmParamRequest paramRequest = new edu.pitt.dbmi.ccd.rest.client.dto.algo.AlgorithmParamRequest();
-			String algoId = hpcJobInfo.getAlgoId();
-			paramRequest.setAlgoId(algoId);
 			paramRequest.setDatasetFileId(dataFile.getId());
-			//Test
-			if(algorParamReq.getTestId() != null){
-				paramRequest.setTestId(algorParamReq.getTestId());
-			}
-			//Score
-			if(algorParamReq.getScoreId() != null){
-				paramRequest.setScoreId(algorParamReq.getScoreId());
+
+			Map<String, Object> dataValidation = new HashMap<>();
+			dataValidation.put("skipUniqueVarName", false);
+			System.out.println("dataValidation: skipUniqueVarName: false");
+			if (algorParamReq.getVariableType().equalsIgnoreCase("discrete")) {
+				dataValidation.put("skipNonzeroVariance", false);
+				LOGGER.debug("dataValidation: skipNonzeroVariance: false");
+			} else {
+				dataValidation.put("skipCategoryLimit", false);
+				LOGGER.debug("dataValidation: skipCategoryLimit: false");
 			}
-			
+			paramRequest.setDataValidation(dataValidation);
 
-			Set<AlgoParameter> algorithmParameters = new HashSet<>();
+			Map<String, Object> algorithmParameters = new HashMap<>();
 			for (AlgorithmParameter param : algorParamReq.getAlgorithmParameters()) {
-				algorithmParameters.add(new AlgoParameter(param.getParameter(), param.getValue()));
+				algorithmParameters.put(param.getParameter(), param.getValue());
 				LOGGER.debug("AlgorithmParameter: " + param.getParameter() + " : " + param.getValue());
 			}
 
 			if (priorKnowledgeFile != null) {
-				paramRequest.setPriorKnowledgeFileId(priorKnowledgeFile.getId());
+				algorithmParameters.put("priorKnowledgeFileId", priorKnowledgeFile.getId());
 				LOGGER.debug("priorKnowledgeFileId: " + priorKnowledgeFile.getId());
 			}
-			paramRequest.setAlgoParameters(algorithmParameters);
+			paramRequest.setAlgorithmParameters(algorithmParameters);
 
-			if(algorParamReq.getJvmOptions() != null){
-				JvmOptions jvmOptions = new JvmOptions();
-				jvmOptions.setMaxHeapSize(algorParamReq.getJvmOptions().getMaxHeapSize());
-				paramRequest.setJvmOptions(jvmOptions);
+			Map<String, Object> jvmOptions = new HashMap<>();
+			for (JvmOption jvmOption : algorParamReq.getJvmOptions()) {
+				jvmOptions.put(jvmOption.getParameter(), jvmOption.getValue());
+				LOGGER.debug("JvmOption: " + jvmOption.getParameter() + " : " + jvmOption.getValue());
 			}
-			
-			Set<HpcParameter> hpcParameters = algorParamReq.getHpcParameters();
+			paramRequest.setJvmOptions(jvmOptions);
+
+			List<HpcParameter> hpcParameters = algorParamReq.getHpcParameters();
 			if(hpcParameters != null){
-				Set<edu.pitt.dbmi.ccd.rest.client.dto.algo.HpcParameter> hpcParams = new HashSet<>();
+				List<edu.pitt.dbmi.ccd.rest.client.dto.algo.HpcParameter> hpcParams = new ArrayList<>();
 				for(HpcParameter param : hpcParameters){
 					edu.pitt.dbmi.ccd.rest.client.dto.algo.HpcParameter hpcParam = new edu.pitt.dbmi.ccd.rest.client.dto.algo.HpcParameter();
 					hpcParam.setKey(param.getKey());
@@ -233,8 +236,9 @@ public class HpcJobPreProcessTask implements Runnable {
 			}
 			
 			// Submit a job
+			String algorithmName = hpcJobInfo.getAlgorithmName();
 			JobQueueService jobQueueService = hpcAccountService.getJobQueueService();
-			JobInfo jobInfo = jobQueueService.addToRemoteQueue(paramRequest,
+			JobInfo jobInfo = jobQueueService.addToRemoteQueue(algorithmName, paramRequest,
 					HpcAccountUtils.getJsonWebToken(hpcAccountManager, hpcAccount));
 
 			// Log the job submission
@@ -253,10 +257,7 @@ public class HpcJobPreProcessTask implements Runnable {
 
 			LOGGER.debug(
 					"HpcJobPreProcessTask: HpcJobInfo: id : " + hpcJobInfo.getId() + " : pid : " + hpcJobInfo.getPid()
-							+ " : " + hpcJobInfo.getAlgoId()
-							+ hpcJobInfo.getAlgorithmParamRequest().getTestId() == null?"":" : " + hpcJobInfo.getAlgorithmParamRequest().getTestId()
-							+ hpcJobInfo.getAlgorithmParamRequest().getScoreId() == null?"":" : " + hpcJobInfo.getAlgorithmParamRequest().getScoreId()
-							+ " : " + hpcJobInfo.getResultFileName());
+							+ " : " + hpcJobInfo.getAlgorithmName() + " : " + hpcJobInfo.getResultFileName());
 
 			hpcJobManager.addNewSubmittedHpcJob(hpcJobInfo);
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/task/HpcJobsScheduledTask.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/task/HpcJobsScheduledTask.java
index b0d70cec..1f9b23b0 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/task/HpcJobsScheduledTask.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/app/hpc/task/HpcJobsScheduledTask.java
@@ -79,12 +79,12 @@ public class HpcJobsScheduledTask extends TimerTask {
 					long pid = hpcJobInfo.getPid().longValue();
 					hpcJobInfoMap.put(pid, hpcJobInfo);
 
-					LOGGER.debug("id: " + hpcJobInfo.getId() + " : " + hpcJobInfo.getAlgoId() + ": pid: "
+					LOGGER.debug("id: " + hpcJobInfo.getId() + " : " + hpcJobInfo.getAlgorithmName() + ": pid: "
 							+ pid + " : " + hpcJobInfo.getResultFileName());
 
 				} else {
 
-					LOGGER.debug("id: " + hpcJobInfo.getId() + " : " + hpcJobInfo.getAlgoId()
+					LOGGER.debug("id: " + hpcJobInfo.getId() + " : " + hpcJobInfo.getAlgorithmName()
 							+ ": no pid! : " + hpcJobInfo.getResultFileName());
 
 					hpcJobInfos.remove(hpcJobInfo);
@@ -101,7 +101,7 @@ public class HpcJobsScheduledTask extends TimerTask {
 				List<JobInfo> jobInfos = hpcJobManager.getRemoteActiveJobs(hpcAccountManager, hpcAccount);
 
 				for (JobInfo jobInfo : jobInfos) {
-					LOGGER.debug("Remote pid: " + jobInfo.getId() + " : " + jobInfo.getAlgoId() + " : "
+					LOGGER.debug("Remote pid: " + jobInfo.getId() + " : " + jobInfo.getAlgorithmName() + " : "
 							+ jobInfo.getResultFileName());
 
 					long pid = jobInfo.getId();
@@ -126,7 +126,7 @@ public class HpcJobsScheduledTask extends TimerTask {
 							hpcJobLog.setLastUpdatedTime(new Date(System.currentTimeMillis()));
 
 							String log = "Job status changed to " + recentStatusText;
-							LOGGER.debug(hpcJobInfo.getAlgoId() + " : id : " + hpcJobInfo.getId()
+							LOGGER.debug(hpcJobInfo.getAlgorithmName() + " : id : " + hpcJobInfo.getId()
 									+ " : pid : " + pid);
 							LOGGER.debug(log);
 
@@ -169,7 +169,7 @@ public class HpcJobsScheduledTask extends TimerTask {
 
 						hpcJobManager.logHpcJobLogDetail(hpcJobLog, recentStatus, recentStatusText);
 
-						LOGGER.debug(hpcJobInfo.getAlgoId() + " : id : " + hpcJobInfo.getId() + " : "
+						LOGGER.debug(hpcJobInfo.getAlgorithmName() + " : id : " + hpcJobInfo.getId() + " : "
 								+ recentStatusText);
 
 						GeneralAlgorithmEditor editor = hpcJobManager.getGeneralAlgorithmEditor(hpcJobInfo);
@@ -193,7 +193,7 @@ public class HpcJobsScheduledTask extends TimerTask {
 								hpcJobManager.logHpcJobLogDetail(hpcJobLog, recentStatus, log);
 
 								LOGGER.debug(
-										hpcJobInfo.getAlgoId() + " : id : " + hpcJobInfo.getId() + " : " + log);
+										hpcJobInfo.getAlgorithmName() + " : id : " + hpcJobInfo.getId() + " : " + log);
 
 							} else if (resultFileNames.contains(errorResultFileName)) {
 								recentStatus = 6; // Error Result Downloaded
@@ -209,7 +209,7 @@ public class HpcJobsScheduledTask extends TimerTask {
 								hpcJobManager.logHpcJobLogDetail(hpcJobLog, recentStatus, log);
 
 								LOGGER.debug(
-										hpcJobInfo.getAlgoId() + " : id : " + hpcJobInfo.getId() + " : " + log);
+										hpcJobInfo.getAlgorithmName() + " : id : " + hpcJobInfo.getId() + " : " + log);
 
 							} else {
 
@@ -227,7 +227,7 @@ public class HpcJobsScheduledTask extends TimerTask {
 									String log = "Result downloaded";
 									hpcJobManager.logHpcJobLogDetail(hpcJobLog, recentStatus, log);
 
-									LOGGER.debug(hpcJobInfo.getAlgoId() + " : id : " + hpcJobInfo.getId()
+									LOGGER.debug(hpcJobInfo.getAlgorithmName() + " : id : " + hpcJobInfo.getId()
 											+ " : " + log);
 								} else {
 									String error = downloadAlgorithmResultFile(hpcAccountManager, hpcJobManager,
@@ -242,7 +242,7 @@ public class HpcJobsScheduledTask extends TimerTask {
 										String log = "Error Result downloaded";
 										hpcJobManager.logHpcJobLogDetail(hpcJobLog, recentStatus, log);
 
-										LOGGER.debug(hpcJobInfo.getAlgoId() + " : id : "
+										LOGGER.debug(hpcJobInfo.getAlgorithmName() + " : id : "
 												+ hpcJobInfo.getId() + " : " + log);
 									} else {
 										recentStatus = 7; // Result Not Found
@@ -250,7 +250,7 @@ public class HpcJobsScheduledTask extends TimerTask {
 										String log = resultJsonFileName + " not found";
 										hpcJobManager.logHpcJobLogDetail(hpcJobLog, recentStatus, log);
 
-										LOGGER.debug(hpcJobInfo.getAlgoId() + " : id : "
+										LOGGER.debug(hpcJobInfo.getAlgorithmName() + " : id : "
 												+ hpcJobInfo.getId() + " : " + log);
 									}
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/AlgorithmParameterPanel.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/AlgorithmParameterPanel.java
index 9a6316b7..8ffc8686 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/AlgorithmParameterPanel.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/AlgorithmParameterPanel.java
@@ -18,10 +18,8 @@
  */
 package edu.cmu.tetradapp.editor;
 
-import edu.cmu.tetrad.annotation.Algorithm;
 import edu.cmu.tetrad.util.ParamDescriptions;
 import edu.cmu.tetrad.util.Parameters;
-import edu.cmu.tetradapp.model.GeneralAlgorithmRunner;
 import edu.cmu.tetradapp.ui.PaddingPanel;
 import edu.cmu.tetradapp.util.DoubleTextField;
 import edu.cmu.tetradapp.util.IntTextField;
@@ -49,26 +47,16 @@ public class AlgorithmParameterPanel extends JPanel {
 
     private static final long serialVersionUID = 274638263704283474L;
 
-    private static final String DEFAULT_TITLE_BORDER = "Algorithm Parameters";
-
     public AlgorithmParameterPanel() {
         initComponents();
     }
 
     private void initComponents() {
         setLayout(new BorderLayout());
+        setBorder(BorderFactory.createTitledBorder("Algorithm Parameters"));
     }
 
-    public void addToPanel(GeneralAlgorithmRunner runner) {
-        List<String> parametersToEdit = runner.getAlgorithm().getParameters();
-        Parameters parameters = runner.getParameters();
-
-        Algorithm algoAnno = runner.getAlgorithm().getClass().getAnnotation(Algorithm.class);
-        String title = (algoAnno == null)
-                ? DEFAULT_TITLE_BORDER
-                : String.format("%s Parameters", algoAnno.name());
-        setBorder(BorderFactory.createTitledBorder(title));
-
+    public void addToPanel(List<String> parametersToEdit, Parameters parameters) {
         removeAll();
 
         Box paramsBox = Box.createVerticalBox();
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/EdgewiseComparisonParamsEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/EdgewiseComparisonParamsEditor.java
index 9f1a2f9a..8906084a 100755
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/EdgewiseComparisonParamsEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/EdgewiseComparisonParamsEditor.java
@@ -165,10 +165,6 @@ public class EdgewiseComparisonParamsEditor extends JPanel implements ParameterE
         group.add(graph1);
         group.add(graph2);
 
-        graph1.setSelected(true);
-        getParams().set("referenceGraphName", model1.getName());
-        getParams().set("targetGraphName", model2.getName());
-
         boolean alreadySet = false;
 
         if (model1 instanceof GeneralAlgorithmRunner) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/FciCcdSearchEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/FciCcdSearchEditor.java
index 2f53a93b..a374e28a 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/FciCcdSearchEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/FciCcdSearchEditor.java
@@ -183,7 +183,7 @@ public class FciCcdSearchEditor extends AbstractSearchEditor
 
         JMenu graph = new JMenu("Graph");
         JMenuItem showDags = new JMenuItem("Show DAGs in forbid_latent_common_causes");
-//        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
         JMenuItem dagInPattern = new JMenuItem("Choose DAG in forbid_latent_common_causes");
         JMenuItem gesOrient = new JMenuItem("Global Score-based Reorientation");
         JMenuItem nextGraph = new JMenuItem("Next Graph");
@@ -199,7 +199,7 @@ public class FciCcdSearchEditor extends AbstractSearchEditor
         graph.add(new TriplesAction(getWorkbench().getGraph(), getAlgorithmRunner()));
         graph.addSeparator();
 
-//        graph.add(meekOrient);
+        graph.add(meekOrient);
         graph.add(dagInPattern);
         graph.add(gesOrient);
         graph.addSeparator();
@@ -265,16 +265,16 @@ public class FciCcdSearchEditor extends AbstractSearchEditor
             }
         });
 
-//        meekOrient.addActionListener(new ActionListener() {
-//            public void actionPerformed(ActionEvent e) {
-//                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
-//                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
-//                rules.orientImplied(getGraph());
-//                getGraphHistory().add(getGraph());
-//                getWorkbench().setGraph(getGraph());
-//                firePropertyChange("modelChanged", null, null);
-//            }
-//        });
+        meekOrient.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
+                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
+                rules.orientImplied(getGraph());
+                getGraphHistory().add(getGraph());
+                getWorkbench().setGraph(getGraph());
+                firePropertyChange("modelChanged", null, null);
+            }
+        });
 
         dagInPattern.addActionListener(new ActionListener() {
             public void actionPerformed(ActionEvent e) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/FgesSearchEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/FgesSearchEditor.java
index d54d246f..f78325d1 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/FgesSearchEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/FgesSearchEditor.java
@@ -378,7 +378,7 @@ public class FgesSearchEditor extends AbstractSearchEditor
 
         JMenu graph = new JMenu("Graph");
         JMenuItem showDags = new JMenuItem("Show DAGs in forbid_latent_common_causes");
-//        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
         final JMenuItem dagInPattern = new JMenuItem("Choose DAG in forbid_latent_common_causes");
         JMenuItem gesOrient = new JMenuItem("Global Score-based Reorientation");
         JMenuItem nextGraph = new JMenuItem("Next Graph");
@@ -393,7 +393,7 @@ public class FgesSearchEditor extends AbstractSearchEditor
 //        graph.add(new TriplesAction(getWorkbench(), getAlgorithmRunner()));
         graph.addSeparator();
 
-//        graph.add(meekOrient);
+        graph.add(meekOrient);
         graph.add(dagInPattern);
         graph.add(gesOrient);
         graph.addSeparator();
@@ -458,16 +458,16 @@ public class FgesSearchEditor extends AbstractSearchEditor
             }
         });
 
-//        meekOrient.addActionListener(new ActionListener() {
-//            public void actionPerformed(ActionEvent e) {
-//                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
-//                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
-//                rules.orientImplied(getGraph());
-//                getGraphHistory().add(getGraph());
-//                getWorkbench().setGraph(getGraph());
-//                firePropertyChange("modelChanged", null, null);
-//            }
-//        });
+        meekOrient.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
+                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
+                rules.orientImplied(getGraph());
+                getGraphHistory().add(getGraph());
+                getWorkbench().setGraph(getGraph());
+                firePropertyChange("modelChanged", null, null);
+            }
+        });
 
         dagInPattern.addActionListener(new ActionListener() {
             public void actionPerformed(ActionEvent e) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GeneralAlgorithmEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GeneralAlgorithmEditor.java
index ad9be37d..0054b43b 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GeneralAlgorithmEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GeneralAlgorithmEditor.java
@@ -22,10 +22,7 @@ package edu.cmu.tetradapp.editor;
 
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithm;
 import edu.cmu.tetrad.algcomparison.algorithm.AlgorithmFactory;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.TsImages;
 import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.SingleGraphAlg;
-import edu.cmu.tetrad.algcomparison.score.BdeuScore;
-import edu.cmu.tetrad.algcomparison.score.SemBicScore;
 import edu.cmu.tetrad.algcomparison.utils.HasKnowledge;
 import edu.cmu.tetrad.algcomparison.utils.TakesInitialGraph;
 import edu.cmu.tetrad.annotation.AlgType;
@@ -62,12 +59,14 @@ import edu.cmu.tetradapp.util.FinalizingEditor;
 import edu.cmu.tetradapp.util.WatchedProcess;
 import edu.pitt.dbmi.ccd.commons.file.MessageDigestHash;
 import edu.pitt.dbmi.ccd.rest.client.dto.user.JsonWebToken;
+import edu.pitt.dbmi.ccd.rest.client.service.algo.AbstractAlgorithmRequest;
 import edu.pitt.dbmi.tetrad.db.entity.AlgorithmParamRequest;
 import edu.pitt.dbmi.tetrad.db.entity.AlgorithmParameter;
+import edu.pitt.dbmi.tetrad.db.entity.DataValidation;
 import edu.pitt.dbmi.tetrad.db.entity.HpcAccount;
 import edu.pitt.dbmi.tetrad.db.entity.HpcJobInfo;
 import edu.pitt.dbmi.tetrad.db.entity.HpcParameter;
-import edu.pitt.dbmi.tetrad.db.entity.JvmOptions;
+import edu.pitt.dbmi.tetrad.db.entity.JvmOption;
 import java.awt.BorderLayout;
 import java.awt.CardLayout;
 import java.awt.Dimension;
@@ -81,15 +80,13 @@ import java.lang.reflect.Method;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.EnumMap;
 import java.util.Enumeration;
 import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.Set;
 import javax.swing.BorderFactory;
 import javax.swing.Box;
 import javax.swing.ButtonGroup;
@@ -161,7 +158,6 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
     private final JComboBox<ScoreModel> scoreComboBox = new JComboBox<>();
     private final JTextArea algoDescTextArea = new JTextArea();
     private final Box graphContainer = Box.createHorizontalBox();
-    private final JLabel algorithmGraphTitle = new JLabel();
 
     private final AlgorithmParameterPanel parametersPanel;
     private final JButton paramSetFwdBtn = new JButton("Set Parameters   >");
@@ -189,7 +185,7 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
 
         // Repopulate all the previous selections if reopen the search box
         if (runner.getGraphs() != null && runner.getGraphs().size() > 0) {
-            parametersPanel.addToPanel(runner);
+            parametersPanel.addToPanel(runner.getAlgorithm().getParameters(), runner.getParameters());
 
             // show the generated graph if reopen the search box
             graphContainer.add(graphEditor);  // use the already generated graphEditor
@@ -243,9 +239,6 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
                 if (model.toString().equals(value)) {
                     models.put(ALGO_PARAM, model);
                     algorithmList.setSelectedValue(model, true);
-
-                    String title = String.format("Algorithm: %s", model.getAlgorithm().getAnnotation().name());
-                    algorithmGraphTitle.setText(title);
                     break;
                 }
             }
@@ -347,7 +340,7 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
 
     private void setParameterPanel(AlgorithmModel algoModel, IndependenceTestModel indTestModel, ScoreModel scoreModel) {
         runner.setAlgorithm(getAlgorithmFromInterface(algoModel, indTestModel, scoreModel));
-        parametersPanel.addToPanel(runner);
+        parametersPanel.addToPanel(runner.getAlgorithm().getParameters(), runner.getParameters());
     }
 
     private boolean isValid(AlgorithmModel algoModel, IndependenceTestModel indTestModel, ScoreModel scoreModel) {
@@ -431,7 +424,7 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
         if (model == null) {
             algoDescTextArea.setText("");
         } else {
-            algoDescTextArea.setText(model.getDescription());
+            algoDescTextArea.setText(model.getAlgorithm().getAnnotation().description());
             algoDescTextArea.setCaretPosition(0);
         }
     }
@@ -449,44 +442,24 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
             boolean linear = linearVarChkBox.isSelected();
             boolean gaussian = gaussianVarChkBox.isSelected();
             List<ScoreModel> models = ScoreModels.getInstance().getModels(dataType);
-            List<ScoreModel> scoreModels = new LinkedList<>();
             if (linear && gaussian) {
                 models.stream()
                         .filter(e -> e.getScore().getClazz().isAnnotationPresent(Linear.class))
                         .filter(e -> e.getScore().getClazz().isAnnotationPresent(Gaussian.class))
-                        .forEach(e -> scoreModels.add(e));
+                        .forEach(e -> scoreComboBox.addItem(e));
             } else if (linear) {
                 models.stream()
                         .filter(e -> e.getScore().getClazz().isAnnotationPresent(Linear.class))
                         .filter(e -> !e.getScore().getClazz().isAnnotationPresent(Gaussian.class))
-                        .forEach(e -> scoreModels.add(e));
+                        .forEach(e -> scoreComboBox.addItem(e));
             } else if (gaussian) {
                 models.stream()
                         .filter(e -> !e.getScore().getClazz().isAnnotationPresent(Linear.class))
                         .filter(e -> e.getScore().getClazz().isAnnotationPresent(Gaussian.class))
-                        .forEach(e -> scoreModels.add(e));
+                        .forEach(e -> scoreComboBox.addItem(e));
             } else {
                 models.stream()
-                        .forEach(e -> scoreModels.add(e));
-            }
-
-            // TsIMaGES can only take SEM BIC score for continuous data
-            // or BDeu score for discrete data
-            if (TsImages.class.equals(algoModel.getAlgorithm().getClazz())) {
-                switch (dataType) {
-                    case Continuous:
-                        scoreModels.stream()
-                                .filter(e -> e.getScore().getClazz().equals(SemBicScore.class))
-                                .forEach(e -> scoreComboBox.addItem(e));
-                        break;
-                    case Discrete:
-                        scoreModels.stream()
-                                .filter(e -> e.getScore().getClazz().equals(BdeuScore.class))
-                                .forEach(e -> scoreComboBox.addItem(e));
-                        break;
-                }
-            } else {
-                scoreModels.forEach(e -> scoreComboBox.addItem(e));
+                        .forEach(e -> scoreComboBox.addItem(e));
             }
         }
         updatingScoreModels = false;
@@ -660,7 +633,6 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
 
     public void setAlgorithmResult(String jsonResult) {
         this.jsonResult = jsonResult;
-        System.out.println("json result: " + jsonResult);
 
         final Graph graph = JsonUtils.parseJSONObjectToTetradGraph(jsonResult);
         final List<Graph> graphs = new ArrayList<>();
@@ -670,16 +642,10 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
             runner.getGraphs().remove(index);
         }
         runner.getGraphs().add(graph);
-        // Show graph
         graphEditor.replace(graphs);
         graphEditor.validate();
         LOGGER.info("Remote graph result assigned to runner!");
         firePropertyChange("modelChanged", null, null);
-
-        // Update the graphContainer
-        graphContainer.add(graphEditor);
-
-        changeCard(GRAPH_CARD);
     }
 
     public void setAlgorithmErrorResult(String errorResult) {
@@ -853,29 +819,28 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
             progressTextArea.append("Preparing...");
             progressTextArea.updateUI();
 
-            // 3.1 Algorithm Id, Independent Test Id, Score Id
-            AlgorithmModel algoModel = algorithmList.getSelectedValue();
-            String algoId = algoModel.getAlgorithm().getAnnotation().command();
-            // Test
-            String testId = null;
-            if (indTestComboBox.isEnabled()) {
-                IndependenceTestModel indTestModel = indTestComboBox.getItemAt(indTestComboBox.getSelectedIndex());
-                testId = indTestModel.getIndependenceTest().getAnnotation().command();
-            }
-            // Score
-            String scoreId = null;
-            if (scoreComboBox.isEnabled()) {
-                ScoreModel scoreModel = scoreComboBox.getItemAt(scoreComboBox.getSelectedIndex());
-                scoreId = scoreModel.getScore().getAnnotation().command();
+            // 3.1 Algorithm name
+            String algorithmName;
+            switch (runner.getAlgorithmName().toUpperCase()) {
+                case "FGES":
+                    algorithmName = AbstractAlgorithmRequest.FGES;
+                    if (dataModel.isDiscrete()) {
+                        algorithmName = AbstractAlgorithmRequest.FGES_DISCRETE;
+                    }
+                    break;
+                case "GFCI":
+                    algorithmName = AbstractAlgorithmRequest.GFCI;
+                    if (dataModel.isDiscrete()) {
+                        algorithmName = AbstractAlgorithmRequest.GFCI_DISCRETE;
+                    }
+                    break;
+                default:
+                    return;
             }
 
             // 3.2 Parameters
             AlgorithmParamRequest algorithmParamRequest = new AlgorithmParamRequest();
 
-            // Test and score
-            algorithmParamRequest.setTestId(testId);
-            algorithmParamRequest.setScoreId(scoreId);
-
             // Dataset and Prior paths
             String datasetPath = file.toAbsolutePath().toString();
             LOGGER.info(datasetPath);
@@ -891,17 +856,25 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
             // VariableType
             if (dataModel.isContinuous()) {
                 algorithmParamRequest.setVariableType("continuous");
-            } else if (dataModel.isDiscrete()) {
-                algorithmParamRequest.setVariableType("discrete");
             } else {
-                algorithmParamRequest.setVariableType("mixed");
+                algorithmParamRequest.setVariableType("discrete");
             }
 
             // FileDelimiter
             String fileDelimiter = "tab"; // Pre-determined
             algorithmParamRequest.setFileDelimiter(fileDelimiter);
 
-            Set<AlgorithmParameter> AlgorithmParameters = new HashSet<>();
+            // Default Data Validation Parameters
+            DataValidation dataValidation = new DataValidation();
+            dataValidation.setUniqueVarName(true);
+            if (dataModel.isContinuous()) {
+                dataValidation.setNonZeroVariance(true);
+            } else {
+                dataValidation.setCategoryLimit(true);
+            }
+            algorithmParamRequest.setDataValidation(dataValidation);
+
+            List<AlgorithmParameter> AlgorithmParameters = new ArrayList<>();
 
             Parameters parameters = runner.getParameters();
             List<String> parameterNames = runner.getAlgorithm().getParameters();
@@ -925,8 +898,11 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
             } while (maxHeapSize != null && !StringUtils.isNumeric(maxHeapSize));
 
             if (maxHeapSize != null) {
-                JvmOptions jvmOptions = new JvmOptions();
-                jvmOptions.setMaxHeapSize(Integer.parseInt(maxHeapSize));
+                JvmOption jvmOption = new JvmOption();
+                jvmOption.setParameter("maxHeapSize");
+                jvmOption.setValue(maxHeapSize);
+                List<JvmOption> jvmOptions = new ArrayList<>();
+                jvmOptions.add(jvmOption);
                 algorithmParamRequest.setJvmOptions(jvmOptions);
             }
 
@@ -944,9 +920,7 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
                     hpcParameter.setKey("walltime");
                     hpcParameter.setValue(userwallTime.toString());
                     LOGGER.info("walltime: " + userwallTime.toString());
-                    Set<HpcParameter> hpcParameters = new HashSet<>();
-                    hpcParameters.add(hpcParameter);
-                    algorithmParamRequest.setHpcParameters(hpcParameters);
+                    algorithmParamRequest.setHpcParameters(Collections.singletonList(hpcParameter));
                 }
             }
 
@@ -970,7 +944,7 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
 
             // 4.1 Save HpcJobInfo
             hpcJobInfo = new HpcJobInfo();
-            hpcJobInfo.setAlgoId(algoId);
+            hpcJobInfo.setAlgorithmName(algorithmName);
             hpcJobInfo.setAlgorithmParamRequest(algorithmParamRequest);
             hpcJobInfo.setStatus(-1);
             hpcJobInfo.setHpcAccount(hpcAccount);
@@ -982,7 +956,7 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
 
             this.jsonResult = null;
 
-            JOptionPane.showMessageDialog(ancestor, "The " + hpcJobInfo.getAlgoId() + " job on the "
+            JOptionPane.showMessageDialog(ancestor, "The " + hpcJobInfo.getAlgorithmName() + " job on the "
                     + hpcJobInfo.getHpcAccount().getConnectionName() + " node is in the queue successfully!");
 
         } catch (IOException exception) {
@@ -996,7 +970,7 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
 
     }
 
-    private HpcAccount showRemoteComputingOptions(String algoId) {
+    private HpcAccount showRemoteComputingOptions(String name) {
         List<HpcAccount> hpcAccounts = desktop.getHpcAccountManager().getHpcAccounts();
 
         if (hpcAccounts == null || hpcAccounts.isEmpty()) {
@@ -1013,7 +987,7 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
             options[i + 1] = yes_answer + connName;
         }
 
-        int n = JOptionPane.showOptionDialog(this, "Would you like to execute a " + algoId + " search in the cloud?",
+        int n = JOptionPane.showOptionDialog(this, "Would you like to execute a " + name + " search in the cloud?",
                 "A Silly Question", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
         if (n == 0) {
             return null;
@@ -1027,16 +1001,15 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
             public void watch() {
                 AlgorithmModel algoModel = algorithmList.getSelectedValue();
                 if (algoModel != null) {
-                    String title = String.format("Algorithm: %s", algoModel.getAlgorithm().getAnnotation().name());
-                    algorithmGraphTitle.setText(title);
+                    String algoName = algoModel.getAlgorithm().getAnnotation().name();
 
                     HpcAccount hpcAccount = null;
-
-                    if (algoModel.getAlgorithm().getAnnotation().algoType() != AlgType.orient_pairwise
-                            && runner.getDataModelList().getModelList().size() == 1) {
-                        String algoName = algoModel.getAlgorithm().getAnnotation().name();
-
-                        hpcAccount = showRemoteComputingOptions(algoName);
+                    switch (algoName) {
+                        case "FGES":
+                        case "GFCI":
+                            hpcAccount = showRemoteComputingOptions(algoName);
+                            break;
+                        default:
                     }
 
                     if (hpcAccount == null) {
@@ -1478,7 +1451,6 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
         private static final long serialVersionUID = -4333810762051607855L;
 
         private JButton backBtn;
-        private JPanel titlePanel;
 
         public GraphCard() {
             initComponents();
@@ -1496,10 +1468,6 @@ public class GeneralAlgorithmEditor extends JPanel implements FinalizingEditor {
                 graphCardBackBtnAction(e);
             });
 
-            titlePanel = new JPanel();
-            titlePanel.add(algorithmGraphTitle);
-
-            add(titlePanel, BorderLayout.NORTH);
             add(new JScrollPane(graphContainer), BorderLayout.CENTER);
             add(new SouthPanel(backBtn), BorderLayout.SOUTH);
         }
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphEditor.java
index 57480409..ca2c8362 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphEditor.java
@@ -421,18 +421,18 @@ public final class GraphEditor extends JPanel
         });
 
         graph.addSeparator();
-//        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
-//        graph.add(meekOrient);
-
-//        meekOrient.addActionListener(new ActionListener() {
-//            public void actionPerformed(ActionEvent e) {
-//                MeekRules rules = new MeekRules();
-//                rules.orientImplied(getGraph());
-//                getWorkbench().setGraph(getGraph());
-//                firePropertyChange("modelChanged", null, null);
-//            }
-//        }
-//        );
+        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+        graph.add(meekOrient);
+
+        meekOrient.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                MeekRules rules = new MeekRules();
+                rules.orientImplied(getGraph());
+                getWorkbench().setGraph(getGraph());
+                firePropertyChange("modelChanged", null, null);
+            }
+        }
+        );
 
         graph.addSeparator();
         graph.add(new JMenuItem(new SelectBidirectedAction(getWorkbench()
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphPropertiesAction.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphPropertiesAction.java
index c0dcc2b2..53c57de6 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphPropertiesAction.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphPropertiesAction.java
@@ -50,6 +50,11 @@ class GraphPropertiesAction extends AbstractAction implements ClipboardOwner {
         this.workbench = workbench;
     }
 
+    public GraphPropertiesAction(Graph graph, GraphWorkbench workbench) {
+        super("Graph Properties");
+        this.workbench = workbench;
+    }
+
     /**
      * Copies a parentally closed selection of session nodes in the frontmost
      * session editor to the clipboard.
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphSelectionEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphSelectionEditor.java
index 16f9bb88..ea616a65 100755
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphSelectionEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/GraphSelectionEditor.java
@@ -107,6 +107,8 @@ import javax.swing.SwingConstants;
 import javax.swing.border.CompoundBorder;
 import javax.swing.border.EmptyBorder;
 import javax.swing.border.LineBorder;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
 
 /**
  * Lets the user select a subgraph of a possible large graph and display it.
@@ -137,7 +139,6 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
     /**
      * Constructs a graph selection editor.
      *
-     * @param wrapper
      * @throws NullPointerException if <code>wrapper</code> is null.
      */
     public GraphSelectionEditor(final GraphSelectionWrapper wrapper) {
@@ -183,11 +184,14 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
         infoBtn.setBorder(new EmptyBorder(0, 0, 0, 0));
 
         // Clock info button to show edge types instructions - Zhou
-        infoBtn.addActionListener(e -> {
-            helpSet.setHomeID("graph_edge_types");
-            HelpBroker broker = helpSet.createHelpBroker();
-            ActionListener listener = new CSH.DisplayHelpFromSource(broker);
-            listener.actionPerformed(e);
+        infoBtn.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                helpSet.setHomeID("graph_edge_types");
+                HelpBroker broker = helpSet.createHelpBroker();
+                ActionListener listener = new CSH.DisplayHelpFromSource(broker);
+                listener.actionPerformed(e);
+            }
         });
 
         JMenuBar bar = new JMenuBar();
@@ -209,10 +213,13 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
 
         setEditorPanelFields(wrapper.getType());
 
-        graphTypeCombo.addActionListener(e -> {
-            GraphSelectionWrapper.Type selectedItem = (GraphSelectionWrapper.Type) graphTypeCombo.getSelectedItem();
-            wrapper.setType(selectedItem);
-            setEditorPanelFields(selectedItem);
+        graphTypeCombo.addActionListener(new ActionListener() {
+            @Override
+            public void actionPerformed(ActionEvent e) {
+                GraphSelectionWrapper.Type selectedItem = (GraphSelectionWrapper.Type) graphTypeCombo.getSelectedItem();
+                wrapper.setType(selectedItem);
+                setEditorPanelFields(selectedItem);
+            }
         });
 
         add(bar, BorderLayout.NORTH);
@@ -254,13 +261,17 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
 
         setName("Graph Selection Result:");
 
-        tabbedPane.addChangeListener(e -> {
-            if (e.getSource() instanceof JTabbedPane) {
-                JTabbedPane panel = (JTabbedPane) e.getSource();
-                int selectedIndex = panel.getSelectedIndex();
-                selectedIndex = selectedIndex == -1 ? 0 : selectedIndex;
-                graphAction.setGraph(wrapper.getGraphs().get(selectedIndex), getWorkbench());
-                triplesAction.setGraph(wrapper.getGraphs().get(selectedIndex), getWorkbench());
+        tabbedPane.addChangeListener(new ChangeListener() {
+
+            @Override
+            public void stateChanged(ChangeEvent e) {
+                if (e.getSource() instanceof JTabbedPane) {
+                    JTabbedPane pane = (JTabbedPane) e.getSource();
+                    int selectedIndex = pane.getSelectedIndex();
+                    selectedIndex = selectedIndex == -1 ? 0 : selectedIndex;
+                    graphAction.setGraph(wrapper.getGraphs().get(selectedIndex), getWorkbench());
+                    triplesAction.setGraph(wrapper.getGraphs().get(selectedIndex), getWorkbench());
+                }
             }
         });
 
@@ -475,7 +486,7 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
     private JMenu createGraphMenu() {
         JMenu graph = new JMenu("Graph");
 
-        graphAction = new GraphPropertiesAction(getWorkbench());
+        graphAction = new GraphPropertiesAction(wrapper.getGraphs().get(0), getWorkbench());
         graph.add(graphAction);
         graph.add(new PathsAction(getWorkbench()));
 //        graph.add(new DirectedPathsAction(getWorkbench()));
@@ -1269,8 +1280,6 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
      */
     public static class GraphSelectionTextInputAction extends AbstractAction implements ClipboardOwner {
 
-        private static final long serialVersionUID = 8126264917739434042L;
-
         private final GraphSelectionWrapper wrapper;
         private final JList<Node> sourceList;
         private final JList<Node> selectedList;
@@ -1280,11 +1289,6 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
         /**
          * Creates a new copy subsession action for the given LayoutEditable and
          * clipboard.
-         *
-         * @param component
-         * @param wrapper
-         * @param sourceList
-         * @param selectedList
          */
         public GraphSelectionTextInputAction(JComponent component, GraphSelectionWrapper wrapper,
                 JList<Node> sourceList, JList<Node> selectedList) {
@@ -1298,11 +1302,8 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
         /**
          * Copies a parentally closed selection of session nodes in the
          * frontmost session editor to the clipboard.
-         *
-         * @param e
          */
-        @Override
-        public void actionPerformed(ActionEvent actionEvent) {
+        public void actionPerformed(ActionEvent e) {
             Box b = Box.createVerticalBox();
 
             textArea = new JTextArea();
@@ -1334,19 +1335,22 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
             DesktopController.getInstance().addEditorWindow(window, JLayeredPane.PALETTE_LAYER);
             window.setVisible(true);
 
-            window.addActionListener(e -> {
-                wrapper.setDialogText(textArea.getText());
-                GraphSelectionEditorPanel.VariableListModel selectedModel = (GraphSelectionEditorPanel.VariableListModel) selectedList.getModel();
-                GraphSelectionEditorPanel.VariableListModel sourceModel = (GraphSelectionEditorPanel.VariableListModel) sourceList.getModel();
-                List<Node> oldSelected = wrapper.getSelectedVariables();
-                selectedModel.removeAll(oldSelected);
-                sourceModel.addAll(oldSelected);
-                List<Node> newSelected = selectedVars();
-                selectedModel.addAll(newSelected);
-                sourceModel.removeAll(newSelected);
-                wrapper.setSelectedVariables(newSelected);
-                selectedList.setSelectedIndices(new int[0]);
-                sourceList.setSelectedIndices(new int[0]);
+            window.addActionListener(new ActionListener() {
+                @Override
+                public void actionPerformed(ActionEvent e) {
+                    wrapper.setDialogText(textArea.getText());
+                    GraphSelectionEditorPanel.VariableListModel selectedModel = (GraphSelectionEditorPanel.VariableListModel) selectedList.getModel();
+                    GraphSelectionEditorPanel.VariableListModel sourceModel = (GraphSelectionEditorPanel.VariableListModel) sourceList.getModel();
+                    List<Node> oldSelected = wrapper.getSelectedVariables();
+                    selectedModel.removeAll(oldSelected);
+                    sourceModel.addAll(oldSelected);
+                    List<Node> newSelected = selectedVars();
+                    selectedModel.addAll(newSelected);
+                    sourceModel.removeAll(newSelected);
+                    wrapper.setSelectedVariables(newSelected);
+                    selectedList.setSelectedIndices(new int[0]);
+                    sourceList.setSelectedIndices(new int[0]);
+                }
             });
         }
 
@@ -1376,7 +1380,6 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
         /**
          * Required by the AbstractAction interface; does nothing.
          */
-        @Override
         public void lostOwnership(Clipboard clipboard, Transferable contents) {
         }
     }
@@ -1385,7 +1388,6 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
      * @return the names of the triple classifications. Coordinates with
      * <code>getTriplesList</code>
      */
-    @Override
     public List<String> getTriplesClassificationTypes() {
         List<String> names = new ArrayList<>();
         names.add("Underlines");
@@ -1397,7 +1399,6 @@ public class GraphSelectionEditor extends JPanel implements GraphEditable, Tripl
      * @return the list of triples corresponding to
      * <code>getTripleClassificationNames</code> for the given node.
      */
-    @Override
     public List<List<Triple>> getTriplesLists(Node node) {
         List<List<Triple>> triplesList = new ArrayList<>();
         Graph graph = getGraph();
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/IonSearchEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/IonSearchEditor.java
index 32bc0ba9..6c9e17bd 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/IonSearchEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/IonSearchEditor.java
@@ -400,7 +400,7 @@ public class IonSearchEditor extends AbstractSearchEditor
 
         JMenu graph = new JMenu("Graph");
         JMenuItem showDags = new JMenuItem("Show DAGs in forbid_latent_common_causes");
-//        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
         JMenuItem dagInPattern = new JMenuItem("Choose DAG in forbid_latent_common_causes");
         JMenuItem gesOrient = new JMenuItem("Global Score-based Reorientation");
         JMenuItem nextGraph = new JMenuItem("Next Graph");
@@ -416,7 +416,7 @@ public class IonSearchEditor extends AbstractSearchEditor
         graph.add(new TriplesAction(getWorkbench().getGraph(), getAlgorithmRunner()));
         graph.addSeparator();
 
-//        graph.add(meekOrient);
+        graph.add(meekOrient);
         graph.add(dagInPattern);
         graph.add(gesOrient);
         graph.addSeparator();
@@ -482,16 +482,16 @@ public class IonSearchEditor extends AbstractSearchEditor
             }
         });
 
-//        meekOrient.addActionListener(new ActionListener() {
-//            public void actionPerformed(ActionEvent e) {
-//                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
-//                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
-//                rules.orientImplied(getGraph());
-//                getGraphHistory().add(getGraph());
-//                getWorkbench().setGraph(getGraph());
-//                firePropertyChange("modelChanged", null, null);
-//            }
-//        });
+        meekOrient.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
+                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
+                rules.orientImplied(getGraph());
+                getGraphHistory().add(getGraph());
+                getWorkbench().setGraph(getGraph());
+                firePropertyChange("modelChanged", null, null);
+            }
+        });
 
         dagInPattern.addActionListener(new ActionListener() {
             public void actionPerformed(ActionEvent e) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LoadDataDialog.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LoadDataDialog.java
index ad667e3b..be1024e0 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LoadDataDialog.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LoadDataDialog.java
@@ -120,8 +120,6 @@ final class LoadDataDialog extends JPanel {
 
     private Box validationMessageBox;
 
-    private final int validationWarnErrMsgThreshold = 10;
-
     private Box buttonsBox;
 
     private JButton addFileButton;
@@ -735,10 +733,10 @@ final class LoadDataDialog extends JPanel {
      */
     private void validateAllFiles() {
         for (int i = 0; i < loadedFiles.size(); i++) {
-            StringBuilder strBuilder = new StringBuilder();
-            strBuilder.append("<p>Validation result of ");
-            strBuilder.append(loadedFiles.get(i).getName());
-            strBuilder.append(":</p>");
+            System.out.println("Validating file index = " + i);
+
+            // Validate each individual file
+            String output = "<p>Validation result of " + loadedFiles.get(i).getName() + ": </p>";
 
             DataValidation validation = dataLoaderSettings.validateDataWithSettings(loadedFiles.get(i));
 
@@ -763,40 +761,26 @@ final class LoadDataDialog extends JPanel {
 
             // Show some file info
             if (!infos.isEmpty()) {
-                strBuilder.append("<p><b>File info:</b><br />");
-                infos.forEach(e -> {
-                    strBuilder.append(e.getMessage());
-                    strBuilder.append("<br />");
-                });
-                strBuilder.append("</p>");
+                output = output + "<p><b>File info: </b></p>";
+                for (ValidationResult info : infos) {
+                    // More examples of how to get attributes for customized parsing
+                    //                    Object obj = info.getAttributes().get(ROW_NUMBER);
+                    //                    int numOfLines = (obj instanceof Integer) ? (Integer) obj : 0;
+                    //                    obj = info.getAttributes().get(COLUMN_COUNT);
+                    //                    int numOfColumns = (obj instanceof Integer) ? (Integer) obj : 0;
+                    //                    System.out.printf("numOfLines: %d%n", numOfLines);
+                    //                    System.out.printf("numOfColumns: %d%n", numOfColumns);
+
+                    output = output + "<p>" + info.getMessage() + "</p>";
+                }
             }
 
             // Show warning messages
             if (!warnings.isEmpty()) {
-                int warnCount = warnings.size();
-
-                strBuilder.append("<p style=\"color: orange;\"><b>Warning (total ");
-                strBuilder.append(warnCount);
-                    
-                if (warnCount > validationWarnErrMsgThreshold) {
-                    strBuilder.append(", showing the first ");
-                    strBuilder.append(validationWarnErrMsgThreshold);
-                    strBuilder.append("): </b><br />");
-
-                    warnings.subList(0, validationWarnErrMsgThreshold).forEach(e -> {
-                        strBuilder.append(e.getMessage());
-                        strBuilder.append("<br />");
-                    });
-                } else {
-                    strBuilder.append("): </b><br />");
-
-                    warnings.forEach(e -> {
-                        strBuilder.append(e.getMessage());
-                        strBuilder.append("<br />");
-                    });
+                output = output + "<p style=\"color: orange;\"><b>Warning: </b></p>";
+                for (ValidationResult warning : warnings) {
+                    output = output + "<p style=\"color: orange;\">" + warning.getMessage() + "</p>";
                 }
-
-                strBuilder.append("</p>");
             }
 
             // Show errors if found
@@ -804,49 +788,27 @@ final class LoadDataDialog extends JPanel {
                 int errorCount = errors.size();
 
                 String errorCountString = (errorCount > 1) ? " errors" : " error";
+                output = output + "<p style=\"color: red;\"><b>Validation failed!<br>Please fix the following " + errorCount + errorCountString + " and validate again:</b></p>";
 
-                strBuilder.append("<p style=\"color: red;\"><b>Validation failed!<br>Please fix the following ");
-                
-                if (errorCount > validationWarnErrMsgThreshold) {
-                    strBuilder.append(validationWarnErrMsgThreshold);
-                    strBuilder.append(errorCountString);
-                    strBuilder.append(" (total ");
-                    strBuilder.append(errorCount);
-                    strBuilder.append(") and validate again:</b><br />");
- 
-                    errors.subList(0, validationWarnErrMsgThreshold).forEach(e -> {
-                        // Remember to excape the html tags if the data file contains any
-                        strBuilder.append(escapeHtml4(e.getMessage()));
-                        strBuilder.append("<br />");
-                    });
-                } else {
-                    strBuilder.append(errorCount);
-                    strBuilder.append(errorCountString);
-                    strBuilder.append(") and validate again:</b><br />");
-
-                    errors.forEach(e -> {
-                        // Remember to excape the html tags if the data file contains any
-                        strBuilder.append(escapeHtml4(e.getMessage()));
-                        strBuilder.append("<br />");
-                    });
+                for (ValidationResult error : errors) {
+                    // Remember to excape the html tags if the data file contains any
+                    output = output + "<p style=\"color: red;\">" + escapeHtml4(error.getMessage()) + "</p>";
                 }
-                
-                strBuilder.append("</p>");
 
                 // Also add the file name to failed list
                 // this determines if to show the Load button
                 failedFiles.add(loadedFiles.get(i).getName());
             } else if (loadedFiles.get(i).length() == 0) {
                 // We don't allow users to load empty file
-                strBuilder.append("<p style=\"color: red;\"><b>This is an empty data file!</b></p>");
+                output = output + "<p style=\"color: red;\"><b>This is an empty data file!</b></p>";
                 // Also add the file name to failed list
                 // this determines if to show the Load button
                 failedFiles.add(loadedFiles.get(i).getName());
             } else {
-                strBuilder.append("<p style=\"color: green;\"><b>Validation passed with no error!</b></p>");
+                output = output + "<p style=\"color: green;\"><b>Validation passed with no error!</b></p>";
             }
 
-            validationResults.add(strBuilder.toString());
+            validationResults.add(output);
         }
 
         showValidationResults();
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LofsSearchEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LofsSearchEditor.java
index feeb4f6b..2118bf23 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LofsSearchEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LofsSearchEditor.java
@@ -318,7 +318,7 @@ public class LofsSearchEditor extends AbstractSearchEditor
 
         JMenu graph = new JMenu("Graph");
         JMenuItem showDags = new JMenuItem("Show DAGs in forbid_latent_common_causes");
-//        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
         JMenuItem dagInPattern = new JMenuItem("Choose DAG in forbid_latent_common_causes");
         JMenuItem gesOrient = new JMenuItem("Global Score-based Reorientation");
         JMenuItem nextGraph = new JMenuItem("Next Graph");
@@ -334,7 +334,7 @@ public class LofsSearchEditor extends AbstractSearchEditor
         graph.add(new TriplesAction(getWorkbench().getGraph(), getAlgorithmRunner()));
         graph.addSeparator();
 
-//        graph.add(meekOrient);
+        graph.add(meekOrient);
         graph.add(dagInPattern);
         graph.add(gesOrient);
         graph.addSeparator();
@@ -400,16 +400,16 @@ public class LofsSearchEditor extends AbstractSearchEditor
             }
         });
 
-//        meekOrient.addActionListener(new ActionListener() {
-//            public void actionPerformed(ActionEvent e) {
-//                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
-//                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
-//                rules.orientImplied(getGraph());
-//                getGraphHistory().add(getGraph());
-//                getWorkbench().setGraph(getGraph());
-//                firePropertyChange("modelChanged", null, null);
-//            }
-//        });
+        meekOrient.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
+                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
+                rules.orientImplied(getGraph());
+                getGraphHistory().add(getGraph());
+                getWorkbench().setGraph(getGraph());
+                firePropertyChange("modelChanged", null, null);
+            }
+        });
 
         dagInPattern.addActionListener(new ActionListener() {
             public void actionPerformed(ActionEvent e) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LofsSearchEditorNew.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LofsSearchEditorNew.java
index df51e86c..c6d54b64 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LofsSearchEditorNew.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LofsSearchEditorNew.java
@@ -467,7 +467,7 @@ public class LofsSearchEditorNew extends AbstractSearchEditor
 
         JMenu graph = new JMenu("Graph");
         JMenuItem showDags = new JMenuItem("Show DAGs in forbid_latent_common_causes");
-//        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
         JMenuItem dagInPattern = new JMenuItem("Choose DAG in forbid_latent_common_causes");
         JMenuItem gesOrient = new JMenuItem("Global Score-based Reorientation");
         JMenuItem nextGraph = new JMenuItem("Next Graph");
@@ -478,7 +478,7 @@ public class LofsSearchEditorNew extends AbstractSearchEditor
         graph.add(new TriplesAction(getWorkbench().getGraph(), getAlgorithmRunner()));
         graph.addSeparator();
 
-//        graph.add(meekOrient);
+        graph.add(meekOrient);
         graph.add(dagInPattern);
         graph.add(gesOrient);
         graph.addSeparator();
@@ -529,16 +529,16 @@ public class LofsSearchEditorNew extends AbstractSearchEditor
             }
         });
 
-//        meekOrient.addActionListener(new ActionListener() {
-//            public void actionPerformed(ActionEvent e) {
-//                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
-//                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
-//                rules.orientImplied(getGraph());
-//                getGraphHistory().add(getGraph());
-//                getWorkbench().setGraph(getGraph());
-//                firePropertyChange("modelChanged", null, null);
-//            }
-//        });
+        meekOrient.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
+                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
+                rules.orientImplied(getGraph());
+                getGraphHistory().add(getGraph());
+                getWorkbench().setGraph(getGraph());
+                firePropertyChange("modelChanged", null, null);
+            }
+        });
 
         dagInPattern.addActionListener(new ActionListener() {
             public void actionPerformed(ActionEvent e) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LogisticRegressionEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LogisticRegressionEditor.java
index 8abf082d..28997ab6 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LogisticRegressionEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/LogisticRegressionEditor.java
@@ -18,6 +18,7 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.editor;
 
 import edu.cmu.tetrad.graph.Graph;
@@ -28,17 +29,12 @@ import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.util.TetradLogger;
 import edu.cmu.tetradapp.model.LogisticRegressionRunner;
 import edu.cmu.tetradapp.workbench.GraphWorkbench;
-import java.awt.BorderLayout;
-import java.awt.Dimension;
+
+import javax.swing.*;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
 import java.text.NumberFormat;
-import javax.swing.Box;
-import javax.swing.JButton;
-import javax.swing.JComboBox;
-import javax.swing.JLabel;
-import javax.swing.JPanel;
-import javax.swing.JScrollPane;
-import javax.swing.JTabbedPane;
-import javax.swing.JTextArea;
 
 /**
  * Allows the user to execute a logistic regression in the GUI. Contains a panel
@@ -50,28 +46,43 @@ import javax.swing.JTextArea;
  *
  * @author Joseph Ramsey jdramsey@andrew.cmu.edu
  * @author Frank Wimberly - adapted for EM Bayes estimator and Strucural EM
- * Bayes estimator
+ *         Bayes estimator
  */
 public class LogisticRegressionEditor extends JPanel {
 
-    private static final long serialVersionUID = 7779226528390174L;
-
     /**
      * Text area for display output.
      */
     private final JTextArea modelParameters;
 
+
     /**
      * The number formatter used for printing reports.
      */
     private final NumberFormat nf = NumberFormatUtil.getInstance().getNumberFormat();
 
+
     public LogisticRegressionEditor(final LogisticRegressionRunner regressionRunner) {
         final LogisticRegressionRunner regRunner = regressionRunner;
         final GraphWorkbench workbench = new GraphWorkbench();
         this.modelParameters = new JTextArea();
         final JButton executeButton = new JButton("Execute");
 
+        //this.modelParameters.setFont(new Font("Monospaced", Font.PLAIN, 12));
+
+        executeButton.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                regRunner.execute();
+                //  modelParameters.setText(regRunner.getReport());
+                print(regRunner.getResult(), regRunner.getAlpha());
+                Graph outGraph = regRunner.getOutGraph();
+                GraphUtils.circleLayout(outGraph, 200, 200, 150);
+                GraphUtils.fruchtermanReingoldLayout(outGraph);
+                workbench.setGraph(outGraph);
+                TetradLogger.getInstance().log("result", modelParameters.getText());
+            }
+        });
+
         JTabbedPane tabbedPane = new JTabbedPane();
         tabbedPane.setPreferredSize(new Dimension(600, 400));
         tabbedPane.add("Model", new JScrollPane(this.modelParameters));
@@ -104,8 +115,11 @@ public class LogisticRegressionEditor extends JPanel {
                 comp.addItem(i + 1);
             }
 
-            comp.addActionListener((e) -> {
-                regressionRunner.setModelIndex(((Integer) comp.getSelectedItem()) - 1);
+            comp.addActionListener(new ActionListener() {
+                @Override
+                public void actionPerformed(ActionEvent e) {
+                    regressionRunner.setModelIndex(((Integer)comp.getSelectedItem()).intValue() - 1);
+                }
             });
 
             comp.setMaximumSize(comp.getPreferredSize());
@@ -119,67 +133,60 @@ public class LogisticRegressionEditor extends JPanel {
 
             add(c, BorderLayout.NORTH);
         }
-
-        //this.modelParameters.setFont(new Font("Monospaced", Font.PLAIN, 12));
-        executeButton.addActionListener((e) -> {
-            regRunner.setAlpha(paramsPanel.getParams().getDouble("alpha", 0.001));
-            regRunner.execute();
-            //  modelParameters.setText(regRunner.getReport());
-            print(regRunner.getResult(), regRunner.getAlpha());
-            Graph outGraph = regRunner.getOutGraph();
-            GraphUtils.circleLayout(outGraph, 200, 200, 150);
-            GraphUtils.fruchtermanReingoldLayout(outGraph);
-            workbench.setGraph(outGraph);
-            TetradLogger.getInstance().log("result", modelParameters.getText());
-        });
     }
 
     /**
      * Sets the name of this editor.
      */
-    @Override
     public void setName(String name) {
         String oldName = getName();
         super.setName(name);
         this.firePropertyChange("name", oldName, getName());
     }
 
+
     //============================== Private Methods =====================================//
+
     /**
-     * Prints the info in the result to the text area (doesn't use the results
-     * representation).
+     * Prints the info in the result to the text area (doesn't use the results representation).
      */
-    private void print(LogisticRegression.Result result, double alpha) {
-        if (result == null) {
+    private void print(LogisticRegression.Result result, double alpha){
+        if(result == null){
             return;
         }
         // print cases
-        String text = result.getNy0() + " cases have " + result.getTarget() + " = 0; ";
+        String text = result.getNy0() + " cases have " + result.getTarget()  + " = 0; ";
         text += result.getNy1() + " cases have " + result.getTarget() + " = 1.\n\n";
         // print avgs/SD
         text += "Var\tAvg\tSD\n";
-        for (int i = 1; i <= result.getNumRegressors(); i++) {
+        for(int i = 1; i<=result.getNumRegressors(); i++){
             text += result.getRegressorNames().get(i - 1) + "\t";
             text += nf.format(result.getxMeans()[i]) + "\t";
             text += nf.format(result.getxStdDevs()[i]) + "\n";
         }
         text += "\nCoefficients and Standard Errors:\n";
         text += "Var\tCoeff.\tStdErr\tProb.\tSig.\n";
-        for (int i = 1; i <= result.getNumRegressors(); i++) {
+        for(int i = 1; i<=result.getNumRegressors(); i++){
             text += result.getRegressorNames().get(i - 1) + "\t";
             text += nf.format(result.getCoefs()[i]) + "\t";
             text += nf.format(result.getStdErrs()[i]) + "\t";
             text += nf.format(result.getProbs()[i]) + "\t";
-            if (result.getProbs()[i] < alpha) {
+            if(result.getProbs()[i] < alpha){
                 text += "*\n";
             } else {
                 text += "\n";
             }
         }
 
-        text += "\n\nIntercept = " + nf.format(result.getIntercept()) + "\n";
+        text+= "\n\nIntercept = " + nf.format(result.getIntercept()) + "\n";
 
         this.modelParameters.setText(text);
     }
 
+
+
 }
+
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/MbSearchEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/MbSearchEditor.java
index a2fab0c7..43c61362 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/MbSearchEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/MbSearchEditor.java
@@ -181,7 +181,7 @@ public class MbSearchEditor extends AbstractSearchEditor
         if (getAlgorithmRunner() instanceof MbfsRunner) {
             JMenu graph = new JMenu("Graph");
             JMenuItem showDags = new JMenuItem("Show DAG's Consistent with forbid_latent_common_causes");
-//            JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+            JMenuItem meekOrient = new JMenuItem("Meek Orientation");
             JMenuItem gesOrient = new JMenuItem("Global Score-based Reorientation");
             JMenuItem nextGraph = new JMenuItem("Next Graph");
             JMenuItem previousGraph = new JMenuItem("Previous Graph");
@@ -194,7 +194,7 @@ public class MbSearchEditor extends AbstractSearchEditor
 //            graph.add(new NeighborhoodsAction(getWorkbench()));
             graph.addSeparator();
 
-//            graph.add(meekOrient);
+            graph.add(meekOrient);
             graph.add(gesOrient);
             graph.addSeparator();
 
@@ -231,14 +231,14 @@ public class MbSearchEditor extends AbstractSearchEditor
                 }
             });
 
-//            meekOrient.addActionListener(new ActionListener() {
-//                public void actionPerformed(ActionEvent e) {
-//                    ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
-//                    rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
-//                    rules.orientImplied(getGraph());
-//                    getWorkbench().setGraph(getGraph());
-//                }
-//            });
+            meekOrient.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
+                    rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
+                    rules.orientImplied(getGraph());
+                    getWorkbench().setGraph(getGraph());
+                }
+            });
 
             gesOrient.addActionListener(new ActionListener() {
                 public void actionPerformed(ActionEvent e) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/ParameterPanel.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/ParameterPanel.java
index b1c28831..3a26edcd 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/ParameterPanel.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/ParameterPanel.java
@@ -62,7 +62,7 @@ class ParameterPanel extends JPanel {
             for (String parameter : parametersToEdit) {
                 Object defaultValue = ParamDescriptions.getInstance().get(parameter).getDefaultValue();
 
-                //System.out.println(parameter + " " + defaultValue);
+                System.out.println(parameter + " " + defaultValue);
 
                 JComponent parameterSelection;
 
@@ -182,7 +182,7 @@ class ParameterPanel extends JPanel {
 
         boolean aBoolean = parameters.getBoolean(parameter, defaultValue);
 
-        //System.out.println(parameter + " = " + aBoolean);
+        System.out.println(parameter + " = " + aBoolean);
 
         if (aBoolean) {
             box.setSelectedItem("Yes");
@@ -220,7 +220,7 @@ class ParameterPanel extends JPanel {
 
         boolean aBoolean = parameters.getBoolean(parameter, defaultValue);
 
-        //System.out.println(parameter + " = " + aBoolean);
+        System.out.println(parameter + " = " + aBoolean);
 
         // Set default selection
         if (aBoolean) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/PcGesSearchEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/PcGesSearchEditor.java
index 8ea17731..bb7fff12 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/PcGesSearchEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/PcGesSearchEditor.java
@@ -548,7 +548,7 @@ public class PcGesSearchEditor extends AbstractSearchEditor
 
         JMenu graph = new JMenu("Graph");
         JMenuItem showDags = new JMenuItem("Show DAGs in forbid_latent_common_causes");
-//        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
         JMenuItem dagInPattern = new JMenuItem("Choose DAG in forbid_latent_common_causes");
         JMenuItem gesOrient = new JMenuItem("Global Score-based Reorientation");
         JMenuItem nextGraph = new JMenuItem("Next Graph");
@@ -564,7 +564,7 @@ public class PcGesSearchEditor extends AbstractSearchEditor
         graph.add(new TriplesAction(getWorkbench().getGraph(), getAlgorithmRunner()));
         graph.addSeparator();
 
-//        graph.add(meekOrient);
+        graph.add(meekOrient);
         graph.add(dagInPattern);
         graph.add(gesOrient);
         graph.addSeparator();
@@ -630,16 +630,16 @@ public class PcGesSearchEditor extends AbstractSearchEditor
             }
         });
 
-//        meekOrient.addActionListener(new ActionListener() {
-//            public void actionPerformed(ActionEvent e) {
-//                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
-//                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
-//                rules.orientImplied(getGraph());
-//                getGraphHistory().add(getGraph());
-//                getWorkbench().setGraph(getGraph());
-//                firePropertyChange("modelChanged", null, null);
-//            }
-//        });
+        meekOrient.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
+                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
+                rules.orientImplied(getGraph());
+                getGraphHistory().add(getGraph());
+                getWorkbench().setGraph(getGraph());
+                firePropertyChange("modelChanged", null, null);
+            }
+        });
 
         dagInPattern.addActionListener(new ActionListener() {
             public void actionPerformed(ActionEvent e) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/PcStableLocalSearchEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/PcStableLocalSearchEditor.java
index c5b5b5a8..13b72f80 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/PcStableLocalSearchEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/PcStableLocalSearchEditor.java
@@ -386,7 +386,7 @@ public class PcStableLocalSearchEditor extends AbstractSearchEditor
 
         JMenu graph = new JMenu("Graph");
         JMenuItem showDags = new JMenuItem("Show DAGs in forbid_latent_common_causes");
-//        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
+        JMenuItem meekOrient = new JMenuItem("Meek Orientation");
         JMenuItem dagInPattern = new JMenuItem("Choose DAG in forbid_latent_common_causes");
         JMenuItem gesOrient = new JMenuItem("Global Score-based Reorientation");
         JMenuItem nextGraph = new JMenuItem("Next Graph");
@@ -402,7 +402,7 @@ public class PcStableLocalSearchEditor extends AbstractSearchEditor
         graph.add(new TriplesAction(getWorkbench().getGraph(), getAlgorithmRunner()));
         graph.addSeparator();
 
-//        graph.add(meekOrient);
+        graph.add(meekOrient);
         graph.add(dagInPattern);
         graph.add(gesOrient);
         graph.addSeparator();
@@ -468,16 +468,16 @@ public class PcStableLocalSearchEditor extends AbstractSearchEditor
             }
         });
 
-//        meekOrient.addActionListener(new ActionListener() {
-//            public void actionPerformed(ActionEvent e) {
-//                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
-//                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
-//                rules.orientImplied(getGraph());
-//                getGraphHistory().add(getGraph());
-//                getWorkbench().setGraph(getGraph());
-//                firePropertyChange("modelChanged", null, null);
-//            }
-//        });
+        meekOrient.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                ImpliedOrientation rules = getAlgorithmRunner().getMeekRules();
+                rules.setKnowledge((IKnowledge) getAlgorithmRunner().getParams().get("knowledge", new Knowledge2()));
+                rules.orientImplied(getGraph());
+                getGraphHistory().add(getGraph());
+                getWorkbench().setGraph(getGraph());
+                firePropertyChange("modelChanged", null, null);
+            }
+        });
 
         dagInPattern.addActionListener(new ActionListener() {
             public void actionPerformed(ActionEvent e) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/RegressionParamsEditorPanel.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/RegressionParamsEditorPanel.java
index 7e503bd6..e7536a05 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/RegressionParamsEditorPanel.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/RegressionParamsEditorPanel.java
@@ -18,6 +18,7 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.editor;
 
 import edu.cmu.tetrad.data.DataModel;
@@ -30,56 +31,30 @@ import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetradapp.model.RegressionModel;
 import edu.cmu.tetradapp.util.DoubleTextField;
 import edu.cmu.tetradapp.workbench.LayoutUtils;
-import java.awt.Component;
-import java.awt.Dimension;
-import java.awt.Font;
-import java.awt.Insets;
+
+import javax.swing.*;
+import java.awt.*;
 import java.awt.datatransfer.DataFlavor;
 import java.awt.datatransfer.Transferable;
 import java.awt.datatransfer.UnsupportedFlavorException;
-import java.awt.dnd.DnDConstants;
-import java.awt.dnd.DragGestureEvent;
-import java.awt.dnd.DragGestureListener;
-import java.awt.dnd.DragSource;
-import java.awt.dnd.DragSourceAdapter;
-import java.awt.dnd.DragSourceDropEvent;
-import java.awt.dnd.DropTarget;
-import java.awt.dnd.DropTargetAdapter;
-import java.awt.dnd.DropTargetDropEvent;
+import java.awt.dnd.*;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
 import java.awt.event.FocusAdapter;
 import java.awt.event.FocusEvent;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
+import java.util.*;
 import java.util.List;
-import java.util.Map;
-import java.util.Vector;
-import javax.swing.AbstractListModel;
-import javax.swing.Box;
-import javax.swing.BoxLayout;
-import javax.swing.DefaultListCellRenderer;
-import javax.swing.JButton;
-import javax.swing.JLabel;
-import javax.swing.JList;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-import javax.swing.JScrollPane;
-import javax.swing.JTextField;
-import javax.swing.ListModel;
-import javax.swing.ListSelectionModel;
 
 /**
- * Allows one to drop/drap variables from a source list to a response area and a
- * predictors list. Also lets one specify an alpha level.
+ * Allows one to drop/drap variables from a source list to a response area and
+ * a predictors list. Also lets one specify an alpha level.
  *
  * @author Tyler Gibson
  */
 @SuppressWarnings({"unchecked"})
 class RegressionParamsEditorPanel extends JPanel {
 
-    private static final long serialVersionUID = -194301447990323529L;
 
     private final boolean logistic;
     private final RegressionModel regressionModel;
@@ -88,38 +63,44 @@ class RegressionParamsEditorPanel extends JPanel {
      */
     private Parameters params;
 
+
     /**
      * The list of predictors.
      */
     private static JList PREDICTORS_LIST;
 
+
     /**
      * The list of source variables.
      */
     private static JList SOURCE_LIST;
 
+
     /**
      * A list with a single item in it for the response variable.
      */
     private static JTextField RESPONSE_FIELD;
 
     /**
-     * A mapping between variable names and what sort of variable they are: 1 -
-     * binary, 2- discrete, 3 - continuous.
+     * A mapping between variable names and what sort of variable they are:
+     * 1 - binary, 2- discrete, 3 - continuous.
      */
     private static final Map<String, Integer> VAR_MAP = new HashMap<>();
 
+
     /**
      * The font to render fields in.
      */
     private static final Font FONT = new Font("Dialog", Font.PLAIN, 12);
 
+
+
     /**
-     * Constructs the editor given the <code>Parameters</code> and the
-     * <code>DataModel</code> that should be used.
+     * Constructs the editor given the <code>Parameters</code> and the <code>DataModel</code>
+     * that should be used.
      */
     public RegressionParamsEditorPanel(RegressionModel regressionModel, Parameters parameters,
-            DataModel model, boolean logistic) {
+                                       DataModel model, boolean logistic) {
         this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
         if (parameters == null) {
             throw new NullPointerException("The given params must not be null");
@@ -191,6 +172,7 @@ class RegressionParamsEditorPanel extends JPanel {
         Box vBox = Box.createVerticalBox();
         vBox.add(createLabel("Response:"));
 
+
         vBox.add(getResponseField());
         vBox.add(Box.createVerticalStrut(10));
         vBox.add(createLabel("Predictor(s):"));
@@ -206,6 +188,8 @@ class RegressionParamsEditorPanel extends JPanel {
     }
 
     //============================= Private Methods =================================//
+
+
     private static List<Comparable> getSelected(JList list) {
         List selected = list.getSelectedValuesList();
         List<Comparable> selectedList = new ArrayList<>(selected == null ? 0 : selected.size());
@@ -217,9 +201,9 @@ class RegressionParamsEditorPanel extends JPanel {
         return selectedList;
     }
 
+
     /**
-     * Bulids the arrows that allow one to move variables around (can also use
-     * drag and drop)
+     * Bulids the arrows that allow one to move variables around (can also use drag and drop)
      */
     private Box buildSelectorArea(int startHeight) {
         Box box = Box.createVerticalBox();
@@ -227,52 +211,58 @@ class RegressionParamsEditorPanel extends JPanel {
         JButton moveToPredictor = new JButton(">");
         JButton moveToSource = new JButton("<");
 
-        moveToResponse.addActionListener((e) -> {
-            VariableListModel sourceModel = (VariableListModel) getSourceList().getModel();
-            String target = getResponseField().getText();
-            List<Comparable> selected = getSelected(getSourceList());
-            if (selected.isEmpty()) {
-                return;
-            } else if (1 < selected.size()) {
-                JOptionPane.showMessageDialog(RegressionParamsEditorPanel.this, "Cannot have more than one response variable");
-                return;
-            } else if (logistic && !isBinary((String) selected.get(0))) {
-                JOptionPane.showMessageDialog(RegressionParamsEditorPanel.this,
-                        "Response variable must be binary.");
-                return;
-            }
-            sourceModel.removeAll(selected);
-            getResponseField().setText((String) selected.get(0));
-            getResponseField().setCaretPosition(0);
-            regressionModel.setTargetName((String) selected.get(0));
-            if (target != null && target.length() != 0) {
-                sourceModel.add(target);
+        moveToResponse.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                VariableListModel sourceModel = (VariableListModel) getSourceList().getModel();
+                String target = getResponseField().getText();
+                List<Comparable> selected = getSelected(getSourceList());
+                if (selected.isEmpty()) {
+                    return;
+                } else if (1 < selected.size()) {
+                    JOptionPane.showMessageDialog(RegressionParamsEditorPanel.this, "Cannot have more than one response variable");
+                    return;
+                } else if(logistic && !isBinary((String)selected.get(0))){
+                    JOptionPane.showMessageDialog(RegressionParamsEditorPanel.this,
+                            "Response variable must be binary.");
+                    return;
+                }
+                sourceModel.removeAll(selected);
+                getResponseField().setText((String) selected.get(0));
+                getResponseField().setCaretPosition(0);
+                regressionModel.setTargetName((String) selected.get(0));
+                if (target != null && target.length() != 0) {
+                    sourceModel.add(target);
+                }
             }
         });
 
-        moveToPredictor.addActionListener((e) -> {
-            VariableListModel predictorsModel = (VariableListModel) getPredictorsList().getModel();
-            VariableListModel sourceModel = (VariableListModel) getSourceList().getModel();
-            List<Comparable> selected = getSelected(getSourceList());
-            sourceModel.removeAll(selected);
-            predictorsModel.addAll(selected);
-            regressionModel.setRegressorName(getPredictors());
+        moveToPredictor.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                VariableListModel predictorsModel = (VariableListModel) getPredictorsList().getModel();
+                VariableListModel sourceModel = (VariableListModel) getSourceList().getModel();
+                List<Comparable> selected = getSelected(getSourceList());
+                sourceModel.removeAll(selected);
+                predictorsModel.addAll(selected);
+                regressionModel.setRegressorName(getPredictors());
+            }
         });
 
-        moveToSource.addActionListener((e) -> {
-            VariableListModel predictorsModel = (VariableListModel) getPredictorsList().getModel();
-            VariableListModel sourceModel = (VariableListModel) getSourceList().getModel();
-            List<Comparable> selected = getSelected(getPredictorsList());
-            // if not empty remove/add, otherwise try the response list.
-            if (!selected.isEmpty()) {
-                predictorsModel.removeAll(selected);
-                sourceModel.addAll(selected);
-                regressionModel.setRegressorName(getPredictors());
-            } else if (getResponseField().getText() != null && getResponseField().getText().length() != 0) {
-                String text = getResponseField().getText();
-                regressionModel.setTargetName(null);
-                getResponseField().setText(null);
-                sourceModel.addAll(Collections.singletonList(text));
+        moveToSource.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                VariableListModel predictorsModel = (VariableListModel) getPredictorsList().getModel();
+                VariableListModel sourceModel = (VariableListModel) getSourceList().getModel();
+                List<Comparable> selected = getSelected(getPredictorsList());
+                // if not empty remove/add, otherwise try the response list.
+                if (!selected.isEmpty()) {
+                    predictorsModel.removeAll(selected);
+                    sourceModel.addAll(selected);
+                    regressionModel.setRegressorName(getPredictors());
+                } else if (getResponseField().getText() != null && getResponseField().getText().length() != 0) {
+                    String text = getResponseField().getText();
+                    regressionModel.setTargetName(null);
+                    getResponseField().setText(null);
+                    sourceModel.addAll(Collections.singletonList(text));
+                }
             }
         });
 
@@ -287,15 +277,18 @@ class RegressionParamsEditorPanel extends JPanel {
         return box;
     }
 
+
     private Box buildSortButton() {
         JButton sort = new JButton("Sort Variables");
         sort.setFont(sort.getFont().deriveFont(11f));
         sort.setMargin(new Insets(3, 3, 3, 3));
-        sort.addActionListener((e) -> {
-            VariableListModel predictorsModel = (VariableListModel) getPredictorsList().getModel();
-            VariableListModel sourceModel = (VariableListModel) getSourceList().getModel();
-            predictorsModel.sort();
-            sourceModel.sort();
+        sort.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                VariableListModel predictorsModel = (VariableListModel) getPredictorsList().getModel();
+                VariableListModel sourceModel = (VariableListModel) getSourceList().getModel();
+                predictorsModel.sort();
+                sourceModel.sort();
+            }
         });
         Box box = Box.createHorizontalBox();
         box.add(sort);
@@ -304,18 +297,23 @@ class RegressionParamsEditorPanel extends JPanel {
         return box;
     }
 
+
     private Box buildAlphaArea(double alpha) {
         DoubleTextField field = new DoubleTextField(alpha, 4, NumberFormatUtil.getInstance().getNumberFormat());
-        field.setFilter((value, oldValue) -> {
-            if (0.0 <= value && value <= 1.0) {
-                params.set("alpha", value);
-                RegressionParamsEditorPanel.this
-                        .firePropertyChange("significanceChanged", oldValue, value);
-                return value;
+        field.setFilter(new DoubleTextField.Filter() {
+            public double filter(double value, double oldValue) {
+                if (0.0 <= value && value <= 1.0) {
+                    params.set("alpha", 0.001);
+                    RegressionParamsEditorPanel.this.firePropertyChange("significanceChanged",
+                            oldValue, value);
+                    return value;
+                }
+                return oldValue;
             }
-            return oldValue;
         });
 
+
+
         Box box = Box.createHorizontalBox();
         box.add(new JLabel("Alpha: "));
         box.add(field);
@@ -323,6 +321,7 @@ class RegressionParamsEditorPanel extends JPanel {
         return box;
     }
 
+
     private void buildMap(DataSet model) {
         for (Node node : model.getVariables()) {
             if (DataUtils.isBinary(model, model.getColumn(node))) {
@@ -335,12 +334,14 @@ class RegressionParamsEditorPanel extends JPanel {
         }
     }
 
+
     private static JScrollPane createScrollPane(JList comp, Dimension dim) {
         JScrollPane pane = new JScrollPane(comp);
         LayoutUtils.setAllSizes(pane, dim);
         return pane;
     }
 
+
     private static Box createLabel(String text) {
         JLabel label = new JLabel(text);
         label.setAlignmentX(JLabel.LEFT_ALIGNMENT);
@@ -350,6 +351,7 @@ class RegressionParamsEditorPanel extends JPanel {
         return box;
     }
 
+
     private JTextField createResponse(JList list, int width) {
         JTextField pane = new JTextField();
         pane.setFont(getFONT());
@@ -369,7 +371,7 @@ class RegressionParamsEditorPanel extends JPanel {
             pane.setText(null);
         }
         pane.addFocusListener(new FocusAdapter() {
-            @Override
+
             public void focusGained(FocusEvent e) {
                 getPredictorsList().clearSelection();
             }
@@ -378,6 +380,7 @@ class RegressionParamsEditorPanel extends JPanel {
         return pane;
     }
 
+
     private static JList createList() {
         JList list = new JList(new VariableListModel());
         list.setFont(getFONT());
@@ -386,6 +389,7 @@ class RegressionParamsEditorPanel extends JPanel {
         return list;
     }
 
+
     private static DataFlavor getListDataFlavor() {
         try {
             return new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType + "; class=java.lang.Object",
@@ -396,6 +400,7 @@ class RegressionParamsEditorPanel extends JPanel {
         }
     }
 
+
     private List<String> getPredictors() {
         ListModel model = getPredictorsList().getModel();
         List<String> predictors = new ArrayList<>();
@@ -405,11 +410,13 @@ class RegressionParamsEditorPanel extends JPanel {
         return predictors;
     }
 
+
     private void addToSource(String var) {
         VariableListModel model = (VariableListModel) getSourceList().getModel();
         model.add(var);
     }
 
+
     private boolean isBinary(String node) {
         int i = getVarMap().get(node);
         return i == 1;
@@ -436,11 +443,12 @@ class RegressionParamsEditorPanel extends JPanel {
     }
 
     //========================== Inner classes (a lot of'em) =========================================//
+
+
     /**
      * A renderer that adds info about whether a variable is binary or not.
      */
     private static class LogisticRegRenderer extends DefaultListCellRenderer {
-
         public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
             String var = (String) value;
             if (var == null) {
@@ -469,6 +477,7 @@ class RegressionParamsEditorPanel extends JPanel {
         }
     }
 
+
     private class TargetListener extends DropTargetAdapter {
 
         public void drop(DropTargetDropEvent dtde) {
@@ -519,6 +528,7 @@ class RegressionParamsEditorPanel extends JPanel {
         }
     }
 
+
     /**
      * A source/gesture listener for the JLists
      */
@@ -572,9 +582,9 @@ class RegressionParamsEditorPanel extends JPanel {
         }
     }
 
+
     /**
-     * A basic model for the list (needed an addAll feature, which the detault
-     * model didn't have)
+     * A basic model for the list (needed an addAll feature, which the detault model didn't have)
      */
     private static class VariableListModel extends AbstractListModel {
 
@@ -601,6 +611,7 @@ class RegressionParamsEditorPanel extends JPanel {
             this.fireIntervalAdded(this, this.delegate.size(), this.delegate.size());
         }
 
+
         public void removeFirst(Comparable element) {
             this.delegate.removeElement(element);
             this.fireContentsChanged(this, 0, this.delegate.size());
@@ -621,11 +632,13 @@ class RegressionParamsEditorPanel extends JPanel {
             this.fireContentsChanged(this, 0, 0);
         }
 
+
         public void sort() {
             Collections.sort(this.delegate);
             this.fireContentsChanged(this, 0, this.delegate.size());
         }
 
+
     }
 
     /**
@@ -660,8 +673,10 @@ class RegressionParamsEditorPanel extends JPanel {
         }
     }
 
-    public Parameters getParams() {
-        return params;
-    }
 
 }
+
+
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SaveComponentImage.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SaveComponentImage.java
index cc2917ae..125f2bc3 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SaveComponentImage.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SaveComponentImage.java
@@ -48,8 +48,7 @@ public class SaveComponentImage extends AbstractAction {
      */
     private String actionName = "Save";
 
-    public
-    SaveComponentImage(JComponent comp, String actionName) {
+    public SaveComponentImage(JComponent comp, String actionName) {
         super(actionName);
         this.actionName = actionName;
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SemImEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SemImEditor.java
index a662ad8d..c9b24f52 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SemImEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SemImEditor.java
@@ -18,21 +18,12 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.editor;
 
 import edu.cmu.tetrad.data.IKnowledge;
-import edu.cmu.tetrad.graph.Edge;
-import edu.cmu.tetrad.graph.Edges;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.graph.GraphUtils;
-import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.graph.NodeType;
-import edu.cmu.tetrad.graph.SemGraph;
-import edu.cmu.tetrad.sem.ISemIm;
-import edu.cmu.tetrad.sem.ParamType;
-import edu.cmu.tetrad.sem.Parameter;
-import edu.cmu.tetrad.sem.SemIm;
-import edu.cmu.tetrad.sem.SemPm;
+import edu.cmu.tetrad.graph.*;
+import edu.cmu.tetrad.sem.*;
 import edu.cmu.tetrad.util.JOptionUtils;
 import edu.cmu.tetrad.util.NumberFormatUtil;
 import edu.cmu.tetrad.util.ProbUtils;
@@ -45,47 +36,27 @@ import edu.cmu.tetradapp.workbench.DisplayNode;
 import edu.cmu.tetradapp.workbench.GraphNodeMeasured;
 import edu.cmu.tetradapp.workbench.GraphWorkbench;
 import edu.cmu.tetradapp.workbench.LayoutMenu;
-import java.awt.BorderLayout;
-import java.awt.Color;
-import java.awt.Container;
-import java.awt.Font;
-import java.awt.Toolkit;
+
+import javax.swing.*;
+import javax.swing.border.TitledBorder;
+import javax.swing.event.AncestorEvent;
+import javax.swing.event.AncestorListener;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+import javax.swing.table.AbstractTableModel;
+import javax.swing.table.TableCellEditor;
+import javax.swing.table.TableModel;
+import java.awt.*;
 import java.awt.datatransfer.Clipboard;
 import java.awt.datatransfer.StringSelection;
-import java.awt.event.ActionEvent;
-import java.awt.event.ActionListener;
-import java.awt.event.ComponentAdapter;
-import java.awt.event.ComponentEvent;
-import java.awt.event.MouseAdapter;
-import java.awt.event.MouseEvent;
+import java.awt.event.*;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
 import java.text.DecimalFormat;
 import java.text.NumberFormat;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
-import javax.swing.Box;
-import javax.swing.BoxLayout;
-import javax.swing.ButtonGroup;
-import javax.swing.JCheckBoxMenuItem;
-import javax.swing.JComboBox;
-import javax.swing.JDialog;
-import javax.swing.JLabel;
-import javax.swing.JMenu;
-import javax.swing.JMenuBar;
-import javax.swing.JMenuItem;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-import javax.swing.JScrollPane;
-import javax.swing.JTabbedPane;
-import javax.swing.JTable;
-import javax.swing.JTextArea;
-import javax.swing.ToolTipManager;
-import javax.swing.border.TitledBorder;
-import javax.swing.event.AncestorEvent;
-import javax.swing.event.AncestorListener;
-import javax.swing.table.AbstractTableModel;
-import javax.swing.table.TableCellEditor;
-import javax.swing.table.TableModel;
 
 /**
  * Edits a SEM instantiated model.
@@ -94,17 +65,12 @@ import javax.swing.table.TableModel;
  * @author Joseph Ramsey
  */
 public final class SemImEditor extends JPanel implements LayoutEditable, DoNotScroll {
-
-    private static final long serialVersionUID = -1856607070184945405L;
-
     private OneEditor oneEditorPanel;
     private JPanel targetPanel;
     private int matrixSelection;
 
     /**
      * Constructs a new SemImEditor from the given OldSemEstimateAdapter.
-     *
-     * @param semImWrapper
      */
     public SemImEditor(SemImWrapper semImWrapper) {
         this(semImWrapper, "Graphical Editor", "Tabular Editor", TabbedPaneDefault.GRAPHICAL);
@@ -112,8 +78,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
     /**
      * Constructs a new SemImEditor from the given OldSemEstimateAdapter.
-     *
-     * @param semEstWrapper
      */
     public SemImEditor(SemEstimatorWrapper semEstWrapper) {
         this(new SemImWrapper(semEstWrapper.getSemEstimator().getEstimatedSem()));
@@ -121,14 +85,9 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
     /**
      * Constructs an editor for the given SemIm.
-     *
-     * @param wrapper
-     * @param graphicalEditorTitle
-     * @param tabularEditorTitle
-     * @param tabbedPaneDefault
      */
     public SemImEditor(final SemImWrapper wrapper, final String graphicalEditorTitle,
-            final String tabularEditorTitle, final TabbedPaneDefault tabbedPaneDefault) {
+                       final String tabularEditorTitle, final TabbedPaneDefault tabbedPaneDefault) {
 
         if (wrapper == null) {
             throw new NullPointerException("The SEM IM wrapper has not been specified.");
@@ -150,14 +109,18 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
             comp.setSelectedIndex(wrapper.getModelIndex());
 
-            comp.addActionListener((e) -> {
-                wrapper.setModelIndex(((Integer) comp.getSelectedItem()) - 1);
-                oneEditorPanel = new OneEditor(wrapper, graphicalEditorTitle, tabularEditorTitle, tabbedPaneDefault);
-                targetPanel.add(oneEditorPanel, BorderLayout.CENTER);
-                validate();
+            comp.addActionListener(new ActionListener() {
+                @Override
+                public void actionPerformed(ActionEvent e) {
+                    wrapper.setModelIndex(((Integer)comp.getSelectedItem()).intValue() - 1);
+                    oneEditorPanel = new OneEditor(wrapper, graphicalEditorTitle, tabularEditorTitle, tabbedPaneDefault);
+                    targetPanel.add(oneEditorPanel, BorderLayout.CENTER);
+                    validate();
+                }
             });
 
 //            comp.setMaximumSize(comp.getPreferredSize());
+
             Box b = Box.createHorizontalBox();
             b.add(new JLabel("Using model"));
             b.add(comp);
@@ -172,6 +135,8 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         targetPanel.add(oneEditorPanel, BorderLayout.CENTER);
     }
 
+
+
     @Override
     public Graph getGraph() {
         return oneEditorPanel.getGraph();
@@ -227,17 +192,12 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         oneEditorPanel.displaySemIm(updatedSem, tabSelectionIndex, matrixSelection);
     }
 
-    public enum TabbedPaneDefault {
-        GRAPHICAL, TABULAR, COVMATRIX, tabbedPanedDefault, STATS
-    }
+    public enum TabbedPaneDefault {GRAPHICAL, TABULAR, COVMATRIX, tabbedPanedDefault, STATS}
     private SemImWrapper wrapper;
 
     private class OneEditor extends JPanel implements LayoutEditable {
-
-        private static final long serialVersionUID = 6622060253747442717L;
-
         private final TabbedPaneDefault tabbedPanedDefault;
-        private final SemImWrapper semImWrapper;
+        private SemImWrapper semImWrapper;
 
         /**
          * The graphical editor for the SemIm.
@@ -261,9 +221,9 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
         /**
          * Maximum number of free parameters for which statistics will be
-         * calculated. (Calculating standard errors is high complexity.) Set
-         * this to zero to turn off statistics calculations (which can be
-         * problematic sometimes).
+         * calculated. (Calculating standard errors is high complexity.) Set this to
+         * zero to turn  off statistics calculations (which can be problematic
+         * sometimes).
          */
         private final int maxFreeParamsForStatistics = 1000;
 
@@ -286,7 +246,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         private JMenuItem errorTerms;
 
         public OneEditor(SemImWrapper wrapper, String graphicalEditorTitle, String tabularEditorTitle,
-                final TabbedPaneDefault tabbedPaneDefault) {
+                         final TabbedPaneDefault tabbedPaneDefault) {
             this.semImWrapper = wrapper;
             this.graphicalEditorTitle = graphicalEditorTitle;
             this.tabularEditorTitle = tabularEditorTitle;
@@ -335,49 +295,57 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                     "Save Graph Image..."));
             file.add(this.getCopyMatrixMenuItem());
 
-            JCheckBoxMenuItem covariances
-                    = new JCheckBoxMenuItem("Show standard deviations");
-            JCheckBoxMenuItem correlations
-                    = new JCheckBoxMenuItem("Show correlations");
+            JCheckBoxMenuItem covariances =
+                    new JCheckBoxMenuItem("Show standard deviations");
+            JCheckBoxMenuItem correlations =
+                    new JCheckBoxMenuItem("Show correlations");
 
             ButtonGroup correlationGroup = new ButtonGroup();
             correlationGroup.add(covariances);
             correlationGroup.add(correlations);
             covariances.setSelected(true);
 
-            covariances.addActionListener((e) -> {
-                setEditCovariancesAsCorrelations(false);
+            covariances.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    setEditCovariancesAsCorrelations(false);
+                }
             });
 
-            correlations.addActionListener((e) -> {
-                setEditCovariancesAsCorrelations(true);
+            correlations.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    setEditCovariancesAsCorrelations(true);
+                }
             });
 
             errorTerms = new JMenuItem();
 
             // By default, hide the error terms.
 //        getSemGraph().setShowErrorTerms(false);
+
             if (getSemGraph().isShowErrorTerms()) {
                 errorTerms.setText("Hide Error Terms");
             } else {
                 errorTerms.setText("Show Error Terms");
             }
 
-            errorTerms.addActionListener((e) -> {
-                JMenuItem menuItem = (JMenuItem) e.getSource();
+            errorTerms.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    JMenuItem menuItem = (JMenuItem) e.getSource();
 
-                if ("Hide Error Terms".equals(menuItem.getText())) {
-                    menuItem.setText("Show Error Terms");
-                    getSemGraph().setShowErrorTerms(false);
-                    graphicalEditor().resetLabels();
-                } else if ("Show Error Terms".equals(menuItem.getText())) {
-                    menuItem.setText("Hide Error Terms");
-                    getSemGraph().setShowErrorTerms(true);
-                    graphicalEditor().resetLabels();
+                    if ("Hide Error Terms".equals(menuItem.getText())) {
+                        menuItem.setText("Show Error Terms");
+                        getSemGraph().setShowErrorTerms(false);
+                        graphicalEditor().resetLabels();
+                    } else if ("Show Error Terms".equals(menuItem.getText())) {
+                        menuItem.setText("Hide Error Terms");
+                        getSemGraph().setShowErrorTerms(true);
+                        graphicalEditor().resetLabels();
+                    }
                 }
             });
 
 //        menuBar.add(graph);
+
             meansItem = new JCheckBoxMenuItem("Show means");
             interceptsItem = new JCheckBoxMenuItem("Show intercepts");
 
@@ -386,12 +354,16 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             meansGroup.add(interceptsItem);
             meansItem.setSelected(true);
 
-            meansItem.addActionListener((e) -> {
-                setEditIntercepts(false);
+            meansItem.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    setEditIntercepts(false);
+                }
             });
 
-            interceptsItem.addActionListener((e) -> {
-                setEditIntercepts(true);
+            interceptsItem.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    setEditIntercepts(true);
+                }
             });
 
             JMenu params = new JMenu("Parameters");
@@ -413,32 +385,26 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             add(tabbedPane, BorderLayout.CENTER);
         }
 
-        @Override
         public Graph getGraph() {
             return semImGraphicalEditor.getWorkbench().getGraph();
         }
 
-        @Override
         public Map<Edge, Object> getModelEdgesToDisplay() {
             return getWorkbench().getModelEdgesToDisplay();
         }
 
-        @Override
         public Map<Node, Object> getModelNodesToDisplay() {
             return getWorkbench().getModelNodesToDisplay();
         }
 
-        @Override
         public IKnowledge getKnowledge() {
             return semImGraphicalEditor.getWorkbench().getKnowledge();
         }
 
-        @Override
         public Graph getSourceGraph() {
             return semImGraphicalEditor.getWorkbench().getSourceGraph();
         }
 
-        @Override
         public void layoutByGraph(Graph graph) {
             SemGraph _graph = (SemGraph) semImGraphicalEditor.getWorkbench().getGraph();
             _graph.setShowErrorTerms(false);
@@ -448,7 +414,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             errorTerms.setText("Show Error Terms");
         }
 
-        @Override
         public void layoutByKnowledge() {
             SemGraph _graph = (SemGraph) semImGraphicalEditor.getWorkbench().getGraph();
             _graph.setShowErrorTerms(false);
@@ -484,18 +449,18 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             return getSemIm().getSemPm().getGraph();
         }
 
+
         /**
-         * @return the index of the currently selected tab. Used to construct a
-         * new SemImEditor in the same state as a previous one.
+         * @return the index of the currently selected tab. Used to construct a new
+         * SemImEditor in the same state as a previous one.
          */
         public int getTabSelectionIndex() {
             return tabbedPane.getSelectedIndex();
         }
 
         /**
-         * @return the index of the matrix that was being viewed most recently.
-         * Used to construct a new SemImEditor in the same state as the previous
-         * one.
+         * @return the index of the matrix that was being viewed most recently. Used
+         * to construct a new SemImEditor in the same state as the previous one.
          */
         public int getMatrixSelection() {
             return impliedMatricesPanel().getMatrixSelection();
@@ -505,7 +470,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
          * Sets a new SemIm to edit.
          */
         public void displaySemIm(SemIm semIm, int tabSelectionIndex,
-                int matrixSelection) {
+                                 int matrixSelection) {
             if (semIm == null) {
                 throw new NullPointerException();
             }
@@ -520,8 +485,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                         "Matrix selection must be 0, 1, 2, or 3: " + matrixSelection);
             }
 
-            SemImEditor.this.wrapper = new SemImWrapper(semIm);
-
             Graph oldGraph = getSemIm().getSemPm().getGraph();
 
             GraphUtils.arrangeBySourceGraph(getSemIm().getSemPm().getGraph(), oldGraph);
@@ -548,17 +511,22 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         //========================PRIVATE METHODS===========================//
+
+
         private JMenuItem getCopyMatrixMenuItem() {
             JMenuItem item = new JMenuItem("Copy Implied Covariance Matrix");
-            item.addActionListener((e) -> {
-                String s = impliedMatricesPanel.getMatrixInTabDelimitedForm();
-                Clipboard board = Toolkit.getDefaultToolkit().getSystemClipboard();
-                StringSelection selection = new StringSelection(s);
-                board.setContents(selection, selection);
+            item.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    String s = impliedMatricesPanel.getMatrixInTabDelimitedForm();
+                    Clipboard board = Toolkit.getDefaultToolkit().getSystemClipboard();
+                    StringSelection selection = new StringSelection(s);
+                    board.setContents(selection, selection);
+                }
             });
             return item;
         }
 
+
         private ISemIm getSemIm() {
             return semImWrapper.getSemIm();
         }
@@ -567,9 +535,13 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             if (this.semImGraphicalEditor == null) {
                 this.semImGraphicalEditor = new SemImGraphicalEditor(wrapper,
                         this, this.maxFreeParamsForStatistics);
-                this.semImGraphicalEditor.addPropertyChangeListener((evt) -> {
-                    SemImEditor.this.firePropertyChange(evt.getPropertyName(), null, null);
-                });
+                this.semImGraphicalEditor.addPropertyChangeListener(
+                        new PropertyChangeListener() {
+                            public void propertyChange(PropertyChangeEvent evt) {
+                                SemImEditor.this.firePropertyChange(evt.getPropertyName(), null,
+                                        null);
+                            }
+                        });
             }
             return this.semImGraphicalEditor;
         }
@@ -579,16 +551,19 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 this.semImTabularEditor = new SemImTabularEditor(wrapper, this,
                         this.maxFreeParamsForStatistics);
             }
-            this.semImTabularEditor.addPropertyChangeListener((evt) -> {
-                SemImEditor.this.firePropertyChange(evt.getPropertyName(), null, null);
-            });
+            this.semImTabularEditor.addPropertyChangeListener(
+                    new PropertyChangeListener() {
+                        public void propertyChange(PropertyChangeEvent evt) {
+                            SemImEditor.this.firePropertyChange(evt.getPropertyName(), null, null);
+                        }
+                    });
             return this.semImTabularEditor;
         }
 
         private ImpliedMatricesPanel impliedMatricesPanel() {
             if (this.impliedMatricesPanel == null) {
-                this.impliedMatricesPanel
-                        = new ImpliedMatricesPanel(wrapper, this.matrixSelection);
+                this.impliedMatricesPanel =
+                        new ImpliedMatricesPanel(wrapper, this.matrixSelection);
             }
             return this.impliedMatricesPanel;
         }
@@ -648,8 +623,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
      */
     final class SemImGraphicalEditor extends JPanel {
 
-        private static final long serialVersionUID = 6469399368858967087L;
-
         /**
          * Font size for parameter values in the graph.
          */
@@ -661,8 +634,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
          */
         private Color LIGHT_YELLOW = new Color(255, 255, 215);
 
-        /**
-         * w
+        /**w
          * Workbench for the graphical editor.
          */
         private GraphWorkbench workbench;
@@ -678,8 +650,8 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         private int savedTooltipDelay = 0;
 
         /**
-         * The editor that sits inside the SemImEditor that allows the user to
-         * edit the SemIm graphically.
+         * The editor that sits inside the SemImEditor that allows the user to edit
+         * the SemIm graphically.
          */
         private SemImEditor.OneEditor editor = null;
 
@@ -699,7 +671,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
          * Constructs a SemIm graphical editor for the given SemIm.
          */
         public SemImGraphicalEditor(SemImWrapper semImWrapper, SemImEditor.OneEditor editor,
-                int maxFreeParamsForStatistics) {
+                                    int maxFreeParamsForStatistics) {
             this.wrapper = semImWrapper;
             this.editor = editor;
             this.maxFreeParamsForStatistics = maxFreeParamsForStatistics;
@@ -719,14 +691,12 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             // almost immediately within the sem im editor but more slowly outside.
             // Ugh.
             workbench().addComponentListener(new ComponentAdapter() {
-                @Override
                 public void componentShown(ComponentEvent e) {
                     resetLabels();
                     ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
                     toolTipManager.setInitialDelay(100);
                 }
 
-                @Override
                 public void componentHidden(ComponentEvent e) {
                     ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
                     toolTipManager.setInitialDelay(getSavedTooltipDelay());
@@ -734,7 +704,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             });
 
             workbench().addMouseListener(new MouseAdapter() {
-                @Override
                 public void mouseEntered(MouseEvent e) {
                     if (workbench().contains(e.getPoint())) {
 
@@ -743,15 +712,16 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                         // from the text field they are editing without the
                         // textfield disappearing. jdramsey 3/16/2005.
 //                    resetLabels();
-                        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
+                        ToolTipManager toolTipManager =
+                                ToolTipManager.sharedInstance();
                         toolTipManager.setInitialDelay(100);
                     }
                 }
 
-                @Override
                 public void mouseExited(MouseEvent e) {
                     if (!workbench().contains(e.getPoint())) {
-                        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
+                        ToolTipManager toolTipManager =
+                                ToolTipManager.sharedInstance();
                         toolTipManager.setInitialDelay(getSavedTooltipDelay());
                     }
                 }
@@ -760,7 +730,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             // Make sure the graphical editor reflects changes made to parameters
             // in other editors.
             addComponentListener(new ComponentAdapter() {
-                @Override
                 public void componentShown(ComponentEvent e) {
                     resetLabels();
                 }
@@ -768,6 +737,8 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         //========================PRIVATE METHODS===========================//
+
+
         private void beginEdgeEdit(final Edge edge) {
             finishEdit();
 
@@ -778,8 +749,8 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             Parameter parameter = getEdgeParameter(edge);
             double d = semIm().getParamValue(parameter);
 
-            if (editor.isEditCovariancesAsCorrelations()
-                    && parameter.getType() == ParamType.COVAR) {
+            if (editor.isEditCovariancesAsCorrelations() &&
+                    parameter.getType() == ParamType.COVAR) {
                 Node nodeA = parameter.getNodeA();
                 Node nodeB = parameter.getNodeB();
 
@@ -790,15 +761,18 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             }
 
             final DoubleTextField field = new DoubleTextField(d, 10, NumberFormatUtil.getInstance().getNumberFormat());
-            field.setFilter((value, oldValue) -> {
-                try {
-                    setEdgeValue(edge, new Double(value).toString());
-                    return value;
-                } catch (IllegalArgumentException e) {
-                    return oldValue;
+            field.setFilter(new DoubleTextField.Filter() {
+                public double filter(double value, double oldValue) {
+                    try {
+                        setEdgeValue(edge, new Double(value).toString());
+                        return value;
+                    } catch (IllegalArgumentException e) {
+                        return oldValue;
+                    }
                 }
             });
 
+
             Box box = Box.createHorizontalBox();
             box.add(Box.createHorizontalGlue());
             box.add(new JLabel("New value: "));
@@ -806,15 +780,12 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             box.add(Box.createHorizontalGlue());
 
             field.addAncestorListener(new AncestorListener() {
-                @Override
                 public void ancestorMoved(AncestorEvent ancestorEvent) {
                 }
 
-                @Override
                 public void ancestorRemoved(AncestorEvent ancestorEvent) {
                 }
 
-                @Override
                 public void ancestorAdded(AncestorEvent ancestorEvent) {
                     Container ancestor = ancestorEvent.getAncestor();
 
@@ -827,14 +798,17 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 }
             });
 
-            field.addActionListener((e) -> {
-                if (SemImGraphicalEditor.this.dialog != null) {
-                    SemImGraphicalEditor.this.dialog.setVisible(false);
+            field.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent actionEvent) {
+                    if (SemImGraphicalEditor.this.dialog != null) {
+                        SemImGraphicalEditor.this.dialog.setVisible(false);
+                    }
                 }
             });
 
             JOptionPane.showMessageDialog(workbench.getComponent(edge), box, "Coefficient for " + edge, JOptionPane.PLAIN_MESSAGE);
 
+
 //        final DoubleTextField doubleTextField = new DoubleTextField(d, 7, NumberFormatUtil.getInstance().getNumberFormat());
 //        doubleTextField.setPreferredSize(new Dimension(60, 20));
 //        doubleTextField.addActionListener(new EdgeActionListener(this, edge));
@@ -886,9 +860,10 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 //        if (!semIm().getSemPm().getGraph().isParameterizable(node)) {
 //            return;
 //        }
+
             Parameter parameter = getNodeParameter(node);
-            if (editor.isEditCovariancesAsCorrelations()
-                    && parameter.getType() == ParamType.VAR) {
+            if (editor.isEditCovariancesAsCorrelations() &&
+                    parameter.getType() == ParamType.VAR) {
                 return;
             }
 
@@ -911,12 +886,14 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             }
 
             final DoubleTextField field = new DoubleTextField(d, 10, NumberFormatUtil.getInstance().getNumberFormat());
-            field.setFilter((value, oldValue) -> {
-                try {
-                    setNodeValue(node, new Double(value).toString());
-                    return value;
-                } catch (IllegalArgumentException e) {
-                    return oldValue;
+            field.setFilter(new DoubleTextField.Filter() {
+                public double filter(double value, double oldValue) {
+                    try {
+                        setNodeValue(node, new Double(value).toString());
+                        return value;
+                    } catch (IllegalArgumentException e) {
+                        return oldValue;
+                    }
                 }
             });
 
@@ -927,15 +904,12 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             box.add(Box.createHorizontalGlue());
 
             field.addAncestorListener(new AncestorListener() {
-                @Override
                 public void ancestorMoved(AncestorEvent ancestorEvent) {
                 }
 
-                @Override
                 public void ancestorRemoved(AncestorEvent ancestorEvent) {
                 }
 
-                @Override
                 public void ancestorAdded(AncestorEvent ancestorEvent) {
                     Container ancestor = ancestorEvent.getAncestor();
 
@@ -945,9 +919,11 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 }
             });
 
-            field.addActionListener((e) -> {
-                if (SemImGraphicalEditor.this.dialog != null) {
-                    SemImGraphicalEditor.this.dialog.setVisible(false);
+            field.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent actionEvent) {
+                    if (SemImGraphicalEditor.this.dialog != null) {
+                        SemImGraphicalEditor.this.dialog.setVisible(false);
+                    }
                 }
             });
 
@@ -965,6 +941,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
             JOptionPane.showMessageDialog(workbench.getComponent(node), box, s, JOptionPane.PLAIN_MESSAGE);
 
+
 //        DoubleTextField field = new DoubleTextField(d, 7, NumberFormatUtil.getInstance().getNumberFormat());
 //        field.setPreferredSize(new Dimension(60, 20));
 //        field.addActionListener(new NodeActionListener(this, node));
@@ -1022,12 +999,15 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             if (this.getWorkbench() == null) {
                 this.workbench = new GraphWorkbench(graph());
                 this.getWorkbench().setAllowDoubleClickActions(false);
-                this.getWorkbench().addPropertyChangeListener((evt) -> {
-                    if ("BackgroundClicked".equals(
-                            evt.getPropertyName())) {
-                        finishEdit();
-                    }
-                });
+                this.getWorkbench().addPropertyChangeListener(
+                        new PropertyChangeListener() {
+                            public void propertyChange(PropertyChangeEvent evt) {
+                                if ("BackgroundClicked".equals(
+                                        evt.getPropertyName())) {
+                                    finishEdit();
+                                }
+                            }
+                        });
                 resetLabels();
                 addMouseListenerToGraphNodesMeasured();
             }
@@ -1068,14 +1048,14 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 try {
                     standardError = semIm().getStandardError(parameter,
                             maxFreeParamsForStatistics);
-                } catch (Exception exception) {
+                } catch (Exception e) {
                     standardError = Double.NaN;
                 }
 
                 double tValue;
                 try {
                     tValue = semIm().getTValue(parameter, maxFreeParamsForStatistics);
-                } catch (Exception exception) {
+                } catch (Exception e) {
                     tValue = Double.NaN;
                 }
 
@@ -1083,12 +1063,12 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
                 try {
                     pValue = semIm().getPValue(parameter, maxFreeParamsForStatistics);
-                } catch (Exception exception) {
+                } catch (Exception e) {
                     pValue = Double.NaN;
                 }
 
-                if (editor.isEditCovariancesAsCorrelations()
-                        && parameter.getType() == ParamType.COVAR) {
+                if (editor.isEditCovariancesAsCorrelations() &&
+                        parameter.getType() == ParamType.COVAR) {
                     Node nodeA = edge.getNode1();
                     Node nodeB = edge.getNode2();
 
@@ -1111,14 +1091,12 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 label.setBackground(Color.white);
                 label.setOpaque(true);
                 label.setFont(SMALL_FONT);
-                
                 label.setText(" " + asString(val) + " ");
-                
                 label.setToolTipText(parameter.getName() + " = " + asString(val));
                 label.addMouseListener(new EdgeMouseListener(edge, this));
                 if (!Double.isNaN(standardError) && semIm().isEstimated()) {
-                    label.setToolTipText("SE=" + asString(standardError) + ", T="
-                            + asString(tValue) + ", P=" + asString(pValue));
+                    label.setToolTipText("SE=" + asString(standardError) + ", T=" +
+                            asString(tValue) + ", P=" + asString(pValue));
                 }
 
                 workbench().setEdgeLabel(edge, label);
@@ -1160,13 +1138,13 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             if (parameter != null) {
                 double standardError = semIm().getStandardError(parameter,
                         maxFreeParamsForStatistics);
-                double tValue
-                        = semIm().getTValue(parameter, maxFreeParamsForStatistics);
-                double pValue
-                        = semIm().getPValue(parameter, maxFreeParamsForStatistics);
+                double tValue =
+                        semIm().getTValue(parameter, maxFreeParamsForStatistics);
+                double pValue =
+                        semIm().getPValue(parameter, maxFreeParamsForStatistics);
 
-                tooltip = "SE=" + asString(standardError) + ", T="
-                        + asString(tValue) + ", P=" + asString(pValue);
+                tooltip = "SE=" + asString(standardError) + ", T=" +
+                        asString(tValue) + ", P=" + asString(pValue);
             }
 
             if (!Double.isNaN(meanOrIntercept)) {
@@ -1174,14 +1152,14 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 label.setText(asString(meanOrIntercept));
 
                 if (editor.isEditIntercepts()) {
-                    tooltip = "<html>" + "B0_" + node.getName() + " = "
-                            + asString(meanOrIntercept) + "</html>";
+                    tooltip = "<html>" + "B0_" + node.getName() + " = " +
+                            asString(meanOrIntercept) + "</html>";
                 } else {
-                    tooltip = "<html>" + "Mean(" + node.getName() + ") = "
-                            + asString(meanOrIntercept) + "</html>";
+                    tooltip = "<html>" + "Mean(" + node.getName() + ") = " +
+                            asString(meanOrIntercept) + "</html>";
                 }
-            } else if (!editor.isEditCovariancesAsCorrelations()
-                    && !Double.isNaN(stdDev)) {
+            } else if (!editor.isEditCovariancesAsCorrelations() &&
+                    !Double.isNaN(stdDev)) {
                 label.setForeground(Color.BLUE);
                 label.setText(asString(stdDev));
 
@@ -1220,13 +1198,14 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         /**
-         * @return the parameter for the given edge, or null if the edge does
-         * not have a parameter associated with it in the model. The edge must
-         * be either directed or bidirected, since it has to come from a
-         * SemGraph. For directed edges, this method automatically adjusts if
-         * the user has changed the endpoints of an edge X1 --> X2 to X1 <-- X2
-         * and returns the correct parameter. @throws IllegalArgumentException
-         * if the edge is neither directed nor bidirected.
+         * @return the parameter for the given edge, or null if the edge does not
+         * have a parameter associated with it in the model. The edge must be either
+         * directed or bidirected, since it has to come from a SemGraph. For
+         * directed edges, this method automatically adjusts if the user has changed
+         * the endpoints of an edge X1 --> X2 to X1 <-- X2 and returns the correct
+         * parameter.
+         * @throws IllegalArgumentException if the edge is neither directed nor
+         *                                  bidirected.
          */
         private Parameter getEdgeParameter(Edge edge) {
             if (Edges.isDirectedEdge(edge)) {
@@ -1244,8 +1223,8 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 Parameter parameter = getEdgeParameter(edge);
                 double d = new Double(text);
 
-                if (editor.isEditCovariancesAsCorrelations()
-                        && parameter.getType() == ParamType.COVAR) {
+                if (editor.isEditCovariancesAsCorrelations() &&
+                        parameter.getType() == ParamType.COVAR) {
                     Node nodeA = edge.getNode1();
                     Node nodeB = edge.getNode2();
 
@@ -1258,8 +1237,8 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
                     semIm().setParamValue(parameter, d);
                     SemImGraphicalEditor.this.firePropertyChange("modelChanged", null, null);
-                } else if (!editor.isEditCovariancesAsCorrelations()
-                        && parameter.getType() == ParamType.COVAR) {
+                } else if (!editor.isEditCovariancesAsCorrelations() &&
+                        parameter.getType() == ParamType.COVAR) {
                     semIm().setParamValue(parameter, d);
                     SemImGraphicalEditor.this.firePropertyChange("modelChanged", null, null);
                 } else if (parameter.getType() == ParamType.COEF) {
@@ -1304,8 +1283,8 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
                     SemImGraphicalEditor.this.firePropertyChange("modelChanged", null, null);
                 }
-            } catch (Exception exception) {
-                exception.printStackTrace(System.err);
+            } catch (Exception e) {
+                e.printStackTrace();
                 // Let the old value be reinstated.
             }
 
@@ -1343,6 +1322,8 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 //            return nf.format(value);
 //        }
 //    }
+
+
         private void addMouseListenerToGraphNodesMeasured() {
             List nodes = graph().getNodes();
 
@@ -1399,7 +1380,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         final class EdgeMouseListener extends MouseAdapter {
-
             private final Edge edge;
             private final SemImGraphicalEditor editor;
 
@@ -1422,7 +1402,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         final class NodeMouseListener extends MouseAdapter {
-
             private final Node node;
             private final SemImGraphicalEditor editor;
 
@@ -1439,14 +1418,12 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 return editor;
             }
 
-            @Override
             public void mouseClicked(MouseEvent e) {
                 getEditor().beginNodeEdit(getNode());
             }
         }
 
         final class EdgeActionListener implements ActionListener {
-
             private final SemImGraphicalEditor editor;
             private final Edge edge;
 
@@ -1455,7 +1432,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 this.edge = edge;
             }
 
-            @Override
             public void actionPerformed(ActionEvent ev) {
                 DoubleTextField doubleTextField = (DoubleTextField) ev.getSource();
                 String s = doubleTextField.getText();
@@ -1472,7 +1448,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         final class NodeActionListener implements ActionListener {
-
             private final SemImGraphicalEditor editor;
             private final Node node;
 
@@ -1481,7 +1456,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 this.node = node;
             }
 
-            @Override
             public void actionPerformed(ActionEvent ev) {
                 DoubleTextField doubleTextField = (DoubleTextField) ev.getSource();
                 String s = doubleTextField.getText();
@@ -1502,15 +1476,12 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
      * Edits parameter values for a SemIm as a simple list.
      */
     final class SemImTabularEditor extends JPanel {
-
-        private static final long serialVersionUID = -3652030288654100645L;
-
         private final ParamTableModel tableModel;
         private final SemImWrapper wrapper;
         private boolean editable = true;
 
         public SemImTabularEditor(SemImWrapper wrapper, SemImEditor.OneEditor editor,
-                int maxFreeParamsForStatistics) {
+                                  int maxFreeParamsForStatistics) {
             this.wrapper = wrapper;
             setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
 //        setBorder(new TitledBorder("Click parameter values to edit"));
@@ -1522,17 +1493,16 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             }
 
             JTable table = new JTable() {
-                private static final long serialVersionUID = -530774590911763214L;
-
-                @Override
                 public TableCellEditor getCellEditor(int row, int col) {
                     return new DataCellEditor();
                 }
             };
             tableModel = new ParamTableModel(wrapper, editor, maxFreeParamsForStatistics);
             table.setModel(getTableModel());
-            tableModel.addTableModelListener((e) -> {
-                SemImTabularEditor.this.firePropertyChange("modelChanged", null, null);
+            tableModel.addTableModelListener(new TableModelListener() {
+                public void tableChanged(TableModelEvent e) {
+                    SemImTabularEditor.this.firePropertyChange("modelChanged", null, null);
+                }
             });
 
             add(new JScrollPane(table), BorderLayout.CENTER);
@@ -1558,9 +1528,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
     }
 
     final class ParamTableModel extends AbstractTableModel {
-
-        private static final long serialVersionUID = 2210883212769846304L;
-
         private final NumberFormat nf = NumberFormatUtil.getInstance().getNumberFormat();
         private final SemImWrapper wrapper;
         private SemImEditor.OneEditor editor = null;
@@ -1568,7 +1535,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         private boolean editable = true;
 
         public ParamTableModel(SemImWrapper wrapper, SemImEditor.OneEditor editor,
-                int maxFreeParamsForStatistics) {
+                               int maxFreeParamsForStatistics) {
             this.wrapper = wrapper;
 
             if (maxFreeParamsForStatistics < 0) {
@@ -1581,21 +1548,19 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             //  parameters.addAll(semIm().getFreeParameters());
             //  parameters.addAll(semIm().getFixedParameters());
             //  parameters.addAll(semIm().getMeanParameters());
+
             this.editor = editor;
         }
 
-        @Override
         public int getRowCount() {
             int numNodes = semIm().getVariableNodes().size();
             return semIm().getNumFreeParams() + semIm().getFixedParameters().size() + numNodes;
         }
 
-        @Override
         public int getColumnCount() {
             return 7;
         }
 
-        @Override
         public String getColumnName(int column) {
             switch (column) {
                 case 0:
@@ -1617,7 +1582,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             return null;
         }
 
-        @Override
         public Object getValueAt(int row, int column) {
             List nodes = semIm().getVariableNodes();
             List parameters = new ArrayList<>(semIm().getFreeParameters());
@@ -1675,6 +1639,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 //            double ar = covars.get(index, index);
 //            stdDev = Math.sqrt(ar);
 //            n = semIm().getSampleSize();
+
                 switch (column) {
                     case 0:
                         return nodes.get(index);
@@ -1730,7 +1695,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             return paramValue;
         }
 
-        @Override
         public boolean isCellEditable(int rowIndex, int columnIndex) {
             return isEditable() && columnIndex == 3;
         }
@@ -1739,7 +1703,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             return this.editable;
         }
 
-        @Override
         public void setValueAt(Object aValue, int rowIndex, int columnIndex) {
 
             if (columnIndex == 3) {
@@ -1786,7 +1749,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
 
                         }
                     }
-                } catch (Exception exception) {
+                } catch (Exception e1) {
                     // The old value will be reinstated automatically.
                 }
 
@@ -1841,13 +1804,9 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
     }
 
     /**
-     * Dispays the implied covariance and correlation matrices for the given
-     * SemIm.
+     * Dispays the implied covariance and correlation matrices for the given SemIm.
      */
     class ImpliedMatricesPanel extends JPanel {
-
-        private static final long serialVersionUID = 2462316724126834072L;
-
         private final SemImWrapper wrapper;
         private JTable impliedJTable;
         private int matrixSelection = 0;
@@ -1866,6 +1825,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             setMatrixSelection(matrixSelection);
         }
 
+
         /**
          * @return the matrix in tab delimited form.
          */
@@ -1885,6 +1845,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             return builder.toString();
         }
 
+
         private JTable impliedJTable() {
             if (this.impliedJTable == null) {
                 this.impliedJTable = new JTable();
@@ -1902,9 +1863,11 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                     selector.addItem(selection);
                 }
 
-                selector.addItemListener((e) -> {
-                    String item = (String) e.getItem();
-                    setMatrixSelection(getImpliedSelections().indexOf(item));
+                selector.addItemListener(new ItemListener() {
+                    public void itemStateChanged(ItemEvent e) {
+                        String item = (String) e.getItem();
+                        setMatrixSelection(getImpliedSelections().indexOf(item));
+                    }
                 });
             }
             return selector;
@@ -1973,8 +1936,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
      */
     final class ImpliedCovTable extends AbstractTableModel {
 
-        private static final long serialVersionUID = -8269181589527893805L;
-
         /**
          * True iff the matrices for the observed variables ony should be
          * displayed.
@@ -2002,7 +1963,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
          * which are as specified (in the order they appear in the matrix).
          */
         public ImpliedCovTable(SemImWrapper wrapper, boolean measured,
-                boolean correlations) {
+                               boolean correlations) {
             this.wrapper = wrapper;
             this.measured = measured;
             this.correlations = correlations;
@@ -2023,12 +1984,10 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         /**
-         * @return the number of rows being displayed--one more than the size of
-         * the matrix, which may be different depending on whether only the
-         * observed variables are being displayed or all the variables are being
-         * displayed.
+         * @return the number of rows being displayed--one more than the size of the
+         * matrix, which may be different depending on whether only the observed
+         * variables are being displayed or all the variables are being displayed.
          */
-        @Override
         public int getRowCount() {
             if (measured()) {
                 return this.getSemIm().getMeasuredNodes().size() + 1;
@@ -2038,12 +1997,10 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         /**
-         * @return the number of columns displayed--one more than the size of
-         * the matrix, which may be different depending on whether only the
-         * observed variables are being displayed or all the variables are being
-         * displayed.
+         * @return the number of columns displayed--one more than the size of the
+         * matrix, which may be different depending on whether only the observed
+         * variables are being displayed or all the variables are being displayed.
          */
-        @Override
         public int getColumnCount() {
             if (measured()) {
                 return this.getSemIm().getMeasuredNodes().size() + 1;
@@ -2053,10 +2010,9 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         /**
-         * @return the name of the column at columnIndex, which is "" for column
-         * 0 and the name of the variable for the other columns.
+         * @return the name of the column at columnIndex, which is "" for column 0
+         * and the name of the variable for the other columns.
          */
-        @Override
         public String getColumnName(int columnIndex) {
             if (columnIndex == 0) {
                 return "";
@@ -2074,10 +2030,9 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         /**
-         * @return the value being displayed in a cell, either a variable name
-         * or a Double.
+         * @return the value being displayed in a cell, either a variable name or a
+         * Double.
          */
-        @Override
         public Object getValueAt(int rowIndex, int columnIndex) {
             if (rowIndex == 0) {
                 return getColumnName(columnIndex);
@@ -2110,10 +2065,10 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                         corr[i][j] = d4;
                     } else {
                         throw new IllegalArgumentException(
-                                "Off-diagonal element at (" + i + ", " + j
-                                + ") cannot be converted to correlation: "
-                                + d1 + " <= Math.pow(" + d2 + " * " + d3
-                                + ", 0.5)");
+                                "Off-diagonal element at (" + i + ", " + j +
+                                        ") cannot be converted to correlation: " +
+                                        d1 + " <= Math.pow(" + d2 + " * " + d3 +
+                                        ", 0.5)");
                     }
                 }
             }
@@ -2133,8 +2088,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
         }
 
         /**
-         * @return true iff correlations (rather than covariances) are
-         * displayed.
+         * @return true iff correlations (rather than covariances) are displayed.
          */
         private boolean correlations() {
             return correlations;
@@ -2146,9 +2100,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
     }
 
     final class ModelStatisticsPanel extends JTextArea {
-
-        private static final long serialVersionUID = -9096723049787232471L;
-
         private final NumberFormat nf = NumberFormatUtil.getInstance().getNumberFormat();
         private final SemImWrapper wrapper;
 
@@ -2157,7 +2108,6 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
             reset();
 
             addComponentListener(new ComponentAdapter() {
-                @Override
                 public void componentShown(ComponentEvent e) {
                     reset();
                 }
@@ -2187,7 +2137,7 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 modelChiSquare = semIm().getChiSquare();
                 modelDof = semIm().getSemPm().getDof();
                 modelPValue = semIm().getPValue();
-            } catch (Exception exception) {
+            } catch (Exception e) {
                 append("Model statistics not available.");
                 return;
             }
@@ -2210,42 +2160,50 @@ public final class SemImEditor extends JPanel implements LayoutEditable, DoNotSc
                 append("\nRMSEA = " + nf.format(semIm().getRmsea()));
 
 //            append("\n(Experimental!) KIC Score = " + nf.format(semIm().getKicScore()));
+
 //            append("\n\nThe null hypothesis for the above chi square test is that " +
 //                    "the population covariance matrix over all variables (sigma) " +
 //                    "is equal to the covariance matrix, over the same variables, " +
 //                    "written as a function of the free model parameters (Bollen, " +
 //                    "Structural Equations with Latent Variables, 110).");
+
             } else {
                 int numToFix = (int) Math.abs(modelDof);
-                append("\n\nA SEM with negative degrees of freedom is underidentified, "
-                        + "\nand other model statistics are meaningless.  Please increase "
-                        + "\nthe degrees of freedom to 0 or above by fixing at least "
-                        + numToFix + " parameter" + (numToFix == 1 ? "." : "s."));
-            }
-
-            append("\n\nThe above chi square test assumes that the maximum "
-                    + "likelihood function over the measured variables has been "
-                    + "minimized. Under that assumption, the null hypothesis for "
-                    + "the test is that the population covariance matrix over all "
-                    + "of the measured variables is equal to the estimated covariance "
-                    + "matrix over all of the measured variables written as a function "
-                    + "of the free model parameters--that is, the unfixed parameters "
-                    + "for each directed edge (the linear coefficient for that edge), "
-                    + "each exogenous variable (the variance for the error term for "
-                    + "that variable), and each bidirected edge (the covariance for "
-                    + "the exogenous variables it connects).  The model is explained "
-                    + "in Bollen, Structural Equations with Latent Variable, 110. "
-                    + "Degrees of freedom are calculated as m (m + 1) / 2 - d, where d "
-                    + "is the number of linear coefficients, variance terms, and error "
-                    + "covariance terms that are not fixed in the model. For latent models, "
-                    + "the degrees of freedom are termed 'estimated' since extra contraints "
-                    + "(e.g. pentad constraints) are not taken into account.");
+                append("\n\nA SEM with negative degrees of freedom is underidentified, " +
+                        "\nand other model statistics are meaningless.  Please increase " +
+                        "\nthe degrees of freedom to 0 or above by fixing at least " +
+                        numToFix + " parameter" + (numToFix == 1 ? "." : "s."));
+            }
+
+            append("\n\nThe above chi square test assumes that the maximum " +
+                    "likelihood function over the measured variables has been " +
+                    "minimized. Under that assumption, the null hypothesis for " +
+                    "the test is that the population covariance matrix over all " +
+                    "of the measured variables is equal to the estimated covariance " +
+                    "matrix over all of the measured variables written as a function " +
+                    "of the free model parameters--that is, the unfixed parameters " +
+                    "for each directed edge (the linear coefficient for that edge), " +
+                    "each exogenous variable (the variance for the error term for " +
+                    "that variable), and each bidirected edge (the covariance for " +
+                    "the exogenous variables it connects).  The model is explained " +
+                    "in Bollen, Structural Equations with Latent Variable, 110. " +
+                    "Degrees of freedom are calculated as m (m + 1) / 2 - d, where d " +
+                    "is the number of linear coefficients, variance terms, and error " +
+                    "covariance terms that are not fixed in the model. For latent models, " +
+                    "the degrees of freedom are termed 'estimated' since extra contraints " +
+                    "(e.g. pentad constraints) are not taken into account.");
 
         }
 
+
         private ISemIm semIm() {
             return wrapper.getSemIm();
         }
     }
-
 }
+
+
+
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SemUpdaterEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SemUpdaterEditor.java
index 13616119..7987cf58 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SemUpdaterEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SemUpdaterEditor.java
@@ -18,6 +18,7 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.editor;
 
 import edu.cmu.tetrad.graph.Node;
@@ -28,21 +29,15 @@ import edu.cmu.tetrad.util.NumberFormatUtil;
 import edu.cmu.tetradapp.model.SemImWrapper;
 import edu.cmu.tetradapp.model.SemUpdaterWrapper;
 import edu.cmu.tetradapp.util.DoubleTextField;
-import java.awt.BorderLayout;
-import java.awt.Color;
-import java.awt.Component;
-import java.awt.Container;
-import java.awt.Dimension;
-import java.awt.FocusTraversalPolicy;
+
+import javax.swing.*;
+import javax.swing.border.EmptyBorder;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.Map;
-import javax.swing.Box;
-import javax.swing.JButton;
-import javax.swing.JCheckBox;
-import javax.swing.JLabel;
-import javax.swing.JPanel;
-import javax.swing.border.EmptyBorder;
 
 /**
  * Lets the user calculate updated probabilities for a SEM.
@@ -51,24 +46,22 @@ import javax.swing.border.EmptyBorder;
  */
 public class SemUpdaterEditor extends JPanel {
 
-    private static final long serialVersionUID = 7548536266087867739L;
-
     /**
      * The SEM updater being edited.
      */
     private SemUpdater semUpdater;
 
-    private final Map<JCheckBox, Integer> checkBoxesToVariables = new HashMap<>();
-    private final Map<Integer, JCheckBox> variablesToCheckboxes = new HashMap<>();
+    private final Map<JCheckBox,Integer> checkBoxesToVariables = new HashMap<>();
+    private final Map<Integer,JCheckBox> variablesToCheckboxes = new HashMap<>();
     private final Map<Integer, DoubleTextField> variablesToTextFields = new HashMap<>();
     private SemImEditor semImEditor;
     private final LinkedList<DoubleTextField> focusTraversalOrder = new LinkedList<>();
     private final Map<DoubleTextField, Integer> labels = new HashMap<>();
 
+    //===============================CONSTRUCTORS=========================//
+
     /**
-     * Constructs a new instantiated model editor from a SEM Updater.
-     *
-     * @param semUpdater
+     * Constructs a new instanted model editor from a SEM Updater.
      */
     public SemUpdaterEditor(SemUpdater semUpdater) {
         if (semUpdater == null) {
@@ -97,9 +90,9 @@ public class SemUpdaterEditor extends JPanel {
         Box b = Box.createVerticalBox();
 
         Box b0 = Box.createHorizontalBox();
-        b0.add(new JLabel("<html>"
-                + "In the list below, specify values for variables you have evidence "
-                + "<br>for. Click the 'Do Update Now' button to view updated model."));
+        b0.add(new JLabel("<html>" +
+                "In the list below, specify values for variables you have evidence " +
+                "<br>for. Click the 'Do Update Now' button to view updated model."));
         b0.add(Box.createHorizontalGlue());
         b.add(b0);
         b.add(Box.createVerticalStrut(10));
@@ -116,9 +109,6 @@ public class SemUpdaterEditor extends JPanel {
             Node node = semIm.getVariableNodes().get(i);
             String name = node.getName();
             JLabel label = new JLabel(name + " =  ") {
-                private static final long serialVersionUID = 820570350956700782L;
-
-                @Override
                 public Dimension getMaximumSize() {
                     return getPreferredSize();
                 }
@@ -128,23 +118,26 @@ public class SemUpdaterEditor extends JPanel {
             double mean = evidence.getProposition().getValue(i);
             final DoubleTextField field = new DoubleTextField(mean, 5, NumberFormatUtil.getInstance().getNumberFormat());
 
-            field.setFilter((value, oldValue) -> {
-                try {
-                    final int nodeIndex = labels.get(field);
-
-                    if (Double.isNaN(value)
-                            && evidence.isManipulated(nodeIndex)) {
-                        throw new IllegalArgumentException();
+            field.setFilter(new DoubleTextField.Filter() {
+                public double filter(double value, double oldValue) {
+                    try {
+                        final int nodeIndex = labels.get(field);
+
+                        if (Double.isNaN(value) &&
+                                evidence.isManipulated(nodeIndex)) {
+                            throw new IllegalArgumentException();
+                        }
+
+                        evidence.getProposition().setValue(nodeIndex, value);
+                        SemIm updatedSem = semUpdater.getUpdatedSemIm();
+                        semImEditor.displaySemIm(updatedSem,
+                                semImEditor.getTabSelectionIndex(),
+                                semImEditor.getMatrixSelection());
+                        return value;
+                    }
+                    catch (IllegalArgumentException e) {
+                        return oldValue;
                     }
-
-                    evidence.getProposition().setValue(nodeIndex, value);
-                    SemIm updatedSem = semUpdater.getUpdatedSemIm();
-                    semImEditor.displaySemIm(updatedSem,
-                            semImEditor.getTabSelectionIndex(),
-                            semImEditor.getMatrixSelection());
-                    return value;
-                } catch (IllegalArgumentException e) {
-                    return oldValue;
                 }
             });
 
@@ -157,9 +150,6 @@ public class SemUpdaterEditor extends JPanel {
             c.add(Box.createHorizontalGlue());
 
             JCheckBox checkbox = new JCheckBox() {
-                private static final long serialVersionUID = -3808843047563493212L;
-
-                @Override
                 public Dimension getMaximumSize() {
                     return getPreferredSize();
                 }
@@ -168,28 +158,30 @@ public class SemUpdaterEditor extends JPanel {
             checkbox.setSelected(evidence.isManipulated(i));
             checkBoxesToVariables.put(checkbox, i);
             variablesToCheckboxes.put(i, checkbox);
-            checkbox.addActionListener((e) -> {
-                JCheckBox chkbox = (JCheckBox) e.getSource();
-                boolean selected = chkbox.isSelected();
-                Integer o = checkBoxesToVariables.get(chkbox);
-
-                // If no value has been set for this variable, set it to
-                // the mean.
-                double value = evidence.getProposition().getValue(o);
-
-                if (Double.isNaN(value)) {
-                    DoubleTextField dblTxtField = variablesToTextFields.get(o);
-                    SemIm semIM = semUpdater.getSemIm();
-                    Node varNode = semIM.getVariableNodes().get(o);
-                    double semIMMean = semIM.getMean(varNode);
-                    dblTxtField.setValue(semIMMean);
-                }
+            checkbox.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    JCheckBox checkbox = (JCheckBox) e.getSource();
+                    boolean selected = checkbox.isSelected();
+                    Integer o = checkBoxesToVariables.get(checkbox);
+
+                    // If no value has been set for this variable, set it to
+                    // the mean.
+                    double value = evidence.getProposition().getValue(o);
+
+                    if (Double.isNaN(value)) {
+                        DoubleTextField field = variablesToTextFields.get(o);
+                        SemIm semIm = semUpdater.getSemIm();
+                        Node node = semIm.getVariableNodes().get(o);
+                        double mean = semIm.getMean(node);
+                        field.setValue(mean);
+                    }
 
-                semUpdater.getEvidence().setManipulated(o, selected);
-                SemIm updatedSem = semUpdater.getUpdatedSemIm();
-                semImEditor.displaySemIm(updatedSem,
-                        semImEditor.getTabSelectionIndex(),
-                        semImEditor.getMatrixSelection());
+                    semUpdater.getEvidence().setManipulated(o, selected);
+                    SemIm updatedSem = semUpdater.getUpdatedSemIm();
+                    semImEditor.displaySemIm(updatedSem,
+                            semImEditor.getTabSelectionIndex(),
+                            semImEditor.getMatrixSelection());
+                }
             });
             checkbox.setBackground(Color.WHITE);
             checkbox.setBorder(null);
@@ -204,12 +196,13 @@ public class SemUpdaterEditor extends JPanel {
         b2.add(Box.createHorizontalGlue());
         JButton button = new JButton("Do Update Now");
 
-        button.addActionListener((e) -> {
-            SemIm updatedSem = semUpdater.getUpdatedSemIm();
-            semImEditor.displaySemIm(updatedSem,
-                    semImEditor.getTabSelectionIndex(),
-                    semImEditor.getMatrixSelection());
-            semUpdater.setEvidence(new SemEvidence(updatedSem));
+        button.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                SemIm updatedSem = semUpdater.getUpdatedSemIm();
+                semImEditor.displaySemIm(updatedSem,
+                        semImEditor.getTabSelectionIndex(),
+                        semImEditor.getMatrixSelection());
+            }
         });
 
         b2.add(button);
@@ -218,7 +211,6 @@ public class SemUpdaterEditor extends JPanel {
         b.setBorder(new EmptyBorder(5, 5, 5, 5));
 
         setFocusTraversalPolicy(new FocusTraversalPolicy() {
-            @Override
             public Component getComponentAfter(Container focusCycleRoot,
                     Component aComponent) {
                 int index = focusTraversalOrder.indexOf(aComponent);
@@ -226,12 +218,12 @@ public class SemUpdaterEditor extends JPanel {
 
                 if (index != -1) {
                     return focusTraversalOrder.get((index + 1) % size);
-                } else {
+                }
+                else {
                     return getFirstComponent(focusCycleRoot);
                 }
             }
 
-            @Override
             public Component getComponentBefore(Container focusCycleRoot,
                     Component aComponent) {
                 int index = focusTraversalOrder.indexOf(aComponent);
@@ -239,22 +231,20 @@ public class SemUpdaterEditor extends JPanel {
 
                 if (index != -1) {
                     return focusTraversalOrder.get((index - 1) % size);
-                } else {
+                }
+                else {
                     return getFirstComponent(focusCycleRoot);
                 }
             }
 
-            @Override
             public Component getFirstComponent(Container focusCycleRoot) {
                 return focusTraversalOrder.getFirst();
             }
 
-            @Override
             public Component getLastComponent(Container focusCycleRoot) {
                 return focusTraversalOrder.getLast();
             }
 
-            @Override
             public Component getDefaultComponent(Container focusCycleRoot) {
                 return getFirstComponent(focusCycleRoot);
             }
@@ -266,22 +256,25 @@ public class SemUpdaterEditor extends JPanel {
     }
 
     /**
-     * Constructs a new instantiated model editor from a SEM IM wrapper.
-     *
-     * @param wrapper
+     * Constructs a new instanted model editor from a SEM IM wrapper.
      */
     public SemUpdaterEditor(SemUpdaterWrapper wrapper) {
         this(wrapper.getSemUpdater());
     }
 
     //================================PUBLIC METHODS========================//
+
     /**
      * Sets the name of this editor.
      */
-    @Override
     public void setName(String name) {
         String oldName = getName();
         super.setName(name);
         this.firePropertyChange("name", oldName, getName());
     }
 }
+
+
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SimulationEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SimulationEditor.java
index a1dcb8f6..635dffa4 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SimulationEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/SimulationEditor.java
@@ -115,18 +115,29 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
         final DataEditor dataEditor;
 
         if (simulation.getSimulation() != null) {
-            //System.out.println("simulation.getSimulation() != null");
+            System.out.println("simulation.getSimulation() != null");
 
-            graphEditor = new GraphSelectionEditor(new GraphSelectionWrapper(simulation.getGraphs(), new Parameters()));
+            List<Graph> trueGraphs = new ArrayList<>();
+            DataModelList dataModelList = new DataModelList();
+
+            int numDataSets = simulation.getSimulation().getNumDataModels();
+            System.out.println("numDataSets: " + numDataSets);
+
+            for (int i = 0; i < numDataSets; i++) {
+                trueGraphs.add(simulation.getSimulation().getTrueGraph(i));
+                dataModelList.add(simulation.getSimulation().getDataModel(i));
+            }
+
+            graphEditor = new GraphSelectionEditor(new GraphSelectionWrapper(trueGraphs, new Parameters()));
             DataWrapper wrapper = new DataWrapper(new Parameters());
-            wrapper.setDataModelList(simulation.getDataModelList());
+            wrapper.setDataModelList(dataModelList);
             dataEditor = new DataEditor(wrapper, false, JTabbedPane.LEFT);
 
             if (simulation.getSimulation() instanceof BooleanGlassSimulation) {
                 simulation.setFixedGraph(true);
             }
         } else {
-            //System.out.println("simulation.getSimulation() = null");
+            System.out.println("simulation.getSimulation() = null");
 
             graphEditor = new GraphSelectionEditor(new GraphSelectionWrapper(Collections.<Graph>emptyList(), new Parameters()));
             dataEditor = new DataEditor(JTabbedPane.LEFT);
@@ -153,6 +164,9 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
             simulationsDropdown.addItem(item);
         }
 
+        simulationsDropdown.setSelectedItem(simulation.getParams().getString("simulationsDropdownPreference",
+                simulationItems[0]));
+
         graphsDropdown.addActionListener((e) -> {
             resetPanel(simulation, graphItems, simulationItems, tabbedPane);
         });
@@ -167,8 +181,9 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
                 public void watch() {
                     try {
                         SwingUtilities.invokeAndWait(() -> {
+                            edu.cmu.tetrad.algcomparison.simulation.Simulation _simulation = simulation.getSimulation();
                             try {
-                                simulation.createSimulation();
+                                _simulation.createData(simulation.getParams());
                             } catch (Exception exception) {
                                 exception.printStackTrace(System.err);
                                 Throwable cause = exception;
@@ -186,7 +201,12 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
 
                             firePropertyChange("modelChanged", null, null);
 
-                            graphEditor.replace(simulation.getGraphs());
+                            List<Graph> graphs = new ArrayList<>();
+                            for (int i = 0; i < _simulation.getNumDataModels(); i++) {
+                                graphs.add(_simulation.getTrueGraph(i));
+                            }
+
+                            graphEditor.replace(graphs);
                             DataWrapper wrapper = new DataWrapper(new Parameters());
                             wrapper.setDataModelList(simulation.getDataModelList());
                             tabbedPane.setComponentAt(2, new DataEditor(wrapper, false, JTabbedPane.LEFT));
@@ -213,7 +233,14 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
 
         add(menuBar, BorderLayout.NORTH);
 
-        graphEditor.replace(simulation.getGraphs());
+        edu.cmu.tetrad.algcomparison.simulation.Simulation _simulation = simulation.getSimulation();
+
+        List<Graph> graphs = new ArrayList<>();
+        for (int i = 0; i < _simulation.getNumDataModels(); i++) {
+            graphs.add(_simulation.getTrueGraph(i));
+        }
+
+        graphEditor.replace(graphs);
         DataWrapper wrapper = new DataWrapper(new Parameters());
         wrapper.setDataModelList(simulation.getDataModelList());
         tabbedPane.setComponentAt(2, new DataEditor(wrapper, false, JTabbedPane.LEFT));
@@ -222,19 +249,20 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
             tabbedPane.setSelectedIndex(2);
         }
 
-        // initialize simulation type selection
-        simulationsDropdown.setSelectedItem(simulation.getParams().getString("simulationsDropdownPreference",
-                simulationItems[0]));
-        resetPanel(simulation, graphItems, simulationItems, tabbedPane);
     }
 
     private void resetPanel(Simulation simulation, String[] graphItems, String[] simulationItems, JTabbedPane tabbedPane) {
-        RandomGraph randomGraph = (simulation.getSourceGraph() == null)
-                ? new SingleGraph(new EdgeListGraph())
-                : new SingleGraph(simulation.getSourceGraph());
+        RandomGraph randomGraph;
+
+        if (simulation.getSourceGraph() != null) {
+            randomGraph = new SingleGraph(simulation.getSourceGraph());
+        } else {
+            randomGraph = new SingleGraph(new EdgeListGraph());
+        }
 
         if (!simulation.isFixedGraph()) {
             String graphItem = (String) graphsDropdown.getSelectedItem();
+            System.out.println("graphItem: " + graphItem);
             simulation.getParams().set("graphsDropdownPreference", graphItem);
 
             if (graphItem.equals(graphItems[0])) {
@@ -253,56 +281,63 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
         }
 
         if (!simulation.isFixedSimulation()) {
-            if (simulation.getSimulation().getNumDataModels() == 0) {
-                if (simulation.getSourceGraph() == null) {
-                    String simulationItem = (String) simulationsDropdown.getSelectedItem();
-                    simulation.getParams().set("simulationsDropdownPreference", simulationItem);
-                    simulation.setFixedGraph(false);
-
-                    if (randomGraph instanceof SingleGraph) {
-                        simulation.setFixedGraph(true);
-                    }
+            if (simulation.getSourceGraph() != null) {
+                String simulationItem = (String) simulationsDropdown.getSelectedItem();
+                System.out.println("simulationItem: " + simulationItem);
+                simulation.getParams().set("simulationsDropdownPreference", simulationItem);
+                simulation.setFixedGraph(false);
 
-                    if (simulationItem.equals(simulationItems[0])) {
-                        simulation.setSimulation(new BayesNetSimulation(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[1])) {
-                        simulation.setSimulation(new SemSimulation(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[2])) {
-                        simulation.setSimulation(new LinearFisherModel(randomGraph, simulation.getInputDataModelList()),
-                                simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[3])) {
-                        simulation.setSimulation(new LeeHastieSimulation(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[4])) {
-                        simulation.setSimulation(new ConditionalGaussianSimulation(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[5])) {
-                        simulation.setSimulation(new TimeSeriesSemSimulation(randomGraph), simulation.getParams());
-                    } else {
-                        throw new IllegalArgumentException("Unrecognized simulation type: " + simulationItem);
-                    }
+                if (randomGraph instanceof SingleGraph) {
+                    simulation.setFixedGraph(true);
+                }
+
+                if (simulationItem.equals(simulationItems[0])) {
+                    simulation.setSimulation(new BayesNetSimulation(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[1])) {
+                    simulation.setSimulation(new SemSimulation(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[2])) {
+                    simulation.setSimulation(new LinearFisherModel(randomGraph), simulation.getParams());
+//                } else if (simulationItem.equals(simulationItems[3])) {
+//                    simulation.setSimulation(new GeneralSemSimulationSpecial1(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[3])) {
+                    simulation.setSimulation(new LeeHastieSimulation(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[4])) {
+                    simulation.setSimulation(new ConditionalGaussianSimulation(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[5])) {
+                    simulation.setSimulation(new TimeSeriesSemSimulation(randomGraph), simulation.getParams());
                 } else {
-                    String simulationItem = (String) simulationsDropdown.getSelectedItem();
-                    simulation.getParams().set("simulationsDropdownPreference", simulationItem);
-                    simulation.setFixedGraph(false);
+                    throw new IllegalArgumentException("Unrecognized simulation type: " + simulationItem);
+                }
 
-                    if (randomGraph instanceof SingleGraph) {
-                        simulation.setFixedGraph(true);
-                    }
+            } else {
+                String simulationItem = (String) simulationsDropdown.getSelectedItem();
+                simulation.getParams().set("simulationsDropdownPreference", simulationItem);
+                simulation.setFixedGraph(false);
 
-                    if (simulationItem.equals(simulationItems[0])) {
-                        simulation.setSimulation(new BayesNetSimulation(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[1])) {
-                        simulation.setSimulation(new SemSimulation(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[2])) {
-                        simulation.setSimulation(new LinearFisherModel(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[3])) {
-                        simulation.setSimulation(new LeeHastieSimulation(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[4])) {
-                        simulation.setSimulation(new ConditionalGaussianSimulation(randomGraph), simulation.getParams());
-                    } else if (simulationItem.equals(simulationItems[5])) {
-                        simulation.setSimulation(new TimeSeriesSemSimulation(randomGraph), simulation.getParams());
-                    } else {
-                        throw new IllegalArgumentException("Unrecognized simulation type: " + simulationItem);
-                    }
+                if (randomGraph instanceof SingleGraph) {
+                    simulation.setFixedGraph(true);
+                }
+
+                if (simulationItem.equals(simulationItems[0])) {
+                    simulation.setSimulation(new BayesNetSimulation(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[1])) {
+                    simulation.setSimulation(new SemSimulation(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[2])) {
+                    simulation.setSimulation(new LinearFisherModel(randomGraph, simulation.getInputDataModelList()),
+                            simulation.getParams());
+//                } else if (simulationItem.equals(simulationItems[3])) {
+//                    simulation.setSimulation(new GeneralSemSimulationSpecial1(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[3])) {
+                    simulation.setSimulation(new LeeHastieSimulation(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[4])) {
+                    simulation.setSimulation(new ConditionalGaussianSimulation(randomGraph), simulation.getParams());
+                } else if (simulationItem.equals(simulationItems[5])) {
+                    simulation.setSimulation(new TimeSeriesSemSimulation(randomGraph), simulation.getParams());
+//                } else if (simulationItem.equals(simulationItems[6])) {
+//                    simulation.setSimulation(new BooleanGlassSimulation(randomGraph), simulation.getParams());
+                    simulation.setFixedGraph(true);
+                } else {
+                    throw new IllegalArgumentException("Unrecognized simulation type: " + simulationItem);
                 }
             }
         }
@@ -316,27 +351,42 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
 
         if (simulation.isFixedSimulation()) {
             if (simulation.getSimulation() instanceof BayesNetSimulation) {
-                simulationItems = new String[]{"Bayes net"};
+                simulationItems = new String[]{
+                    "Bayes net",};
             } else if (simulation.getSimulation() instanceof SemSimulation) {
-                simulationItems = new String[]{"Structural Equation Model"};
+                simulationItems = new String[]{
+                    "Structural Equation Model"
+                };
             } else if (simulation.getSimulation() instanceof LinearFisherModel) {
-                simulationItems = new String[]{"Linear Fisher Model"};
+                simulationItems = new String[]{
+                    "Linear Fisher Model"
+                };
             } else if (simulation.getSimulation() instanceof StandardizedSemSimulation) {
-                simulationItems = new String[]{"Standardized Structural Equation Model"};
+                simulationItems = new String[]{
+                    "Standardized Structural Equation Model"
+                };
             } else if (simulation.getSimulation() instanceof GeneralSemSimulation) {
-                simulationItems = new String[]{"General Structural Equation Model"};
+                simulationItems = new String[]{
+                    "General Structural Equation Model",};
             } else if (simulation.getSimulation() instanceof LoadContinuousDataAndGraphs) {
-                simulationItems = new String[]{"Loaded From Files"};
+                simulationItems = new String[]{
+                    "Loaded From Files",};
             } else {
                 throw new IllegalStateException("Not expecting that model type: "
                         + simulation.getSimulation().getClass());
             }
         } else {
+//            if (simulation.getSimulation() instanceof TakesData) {
+//                simulationItems = new String[]{
+//                        "Linear Fisher Model",
+//                };
+//            } else
             if (simulation.getSourceGraph() != null) {
                 simulationItems = new String[]{
                     "Bayes net",
                     "Structural Equation Model",
                     "Linear Fisher Model",
+                    //                        "General Structural Equation Model Special",
                     "Lee & Hastie",
                     "Conditional Gaussian",
                     "Time Series"
@@ -346,9 +396,10 @@ public final class SimulationEditor extends JPanel implements KnowledgeEditable,
                     "Bayes net",
                     "Structural Equation Model",
                     "Linear Fisher Model",
+                    //                        "General Structural Equation Model Special",
                     "Lee & Hastie",
                     "Conditional Gaussian",
-                    "Time Series"
+                    "Time Series", //                        "Boolean Glass"
                 };
             }
         }
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/StandardizedSemImGraphicalEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/StandardizedSemImGraphicalEditor.java
index 19dbe6d6..6597862a 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/StandardizedSemImGraphicalEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/StandardizedSemImGraphicalEditor.java
@@ -26,17 +26,18 @@ import edu.cmu.tetrad.sem.StandardizedSemIm;
 import edu.cmu.tetrad.util.NumberFormatUtil;
 import edu.cmu.tetradapp.util.DoubleTextField;
 import edu.cmu.tetradapp.workbench.GraphWorkbench;
+
+import javax.swing.*;
+import javax.swing.border.EmptyBorder;
+import javax.swing.border.TitledBorder;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
 import java.awt.*;
 import java.awt.event.*;
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
 import java.text.NumberFormat;
 import java.util.List;
-import javax.swing.*;
-import javax.swing.border.EmptyBorder;
-import javax.swing.border.TitledBorder;
-import javax.swing.event.ChangeEvent;
-import javax.swing.event.ChangeListener;
 
 
 /**
@@ -239,14 +240,16 @@ final class StandardizedSemImGraphicalEditor extends JPanel {
                     // from the text field they are editing without the
                     // textfield disappearing. jdramsey 3/16/2005.
 //                    resetLabels();
-                    ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
+                    ToolTipManager toolTipManager =
+                            ToolTipManager.sharedInstance();
                     toolTipManager.setInitialDelay(100);
                 }
             }
 
             public void mouseExited(MouseEvent e) {
                 if (!workbench().contains(e.getPoint())) {
-                    ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
+                    ToolTipManager toolTipManager =
+                            ToolTipManager.sharedInstance();
                     toolTipManager.setInitialDelay(getSavedTooltipDelay());
                 }
             }
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/TabularDataJTable.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/TabularDataJTable.java
index a7a152d9..2ff093e8 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/TabularDataJTable.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/TabularDataJTable.java
@@ -129,7 +129,7 @@ public class TabularDataJTable extends JTable implements DataModelContainer,
         for (int i = 0; i < model.getNumColumns(); i++) {
             if (model.isSelected(model.getVariable(i))) {
                 setRowSelectionAllowed(false);
-                addColumnSelectionInterval(i + 1, i + 1);
+                addColumnSelectionInterval(i + 2, i + 2);
             }
         }
 
@@ -162,7 +162,7 @@ public class TabularDataJTable extends JTable implements DataModelContainer,
 
                 if (!getRowSelectionAllowed()) {
                     for (int i = 0; i < dataSet.getNumColumns(); i++) {
-                        if (selectionModel.isSelectedIndex(i + 1)) {
+                        if (selectionModel.isSelectedIndex(i + 2)) {
                             dataSet.setSelected(dataSet.getVariable(i), true);
                         }
                     }
@@ -289,8 +289,7 @@ public class TabularDataJTable extends JTable implements DataModelContainer,
                 editor.stopCellEditing();
             }
 
-            for (int i = selectedCols.length - 1; i >= 0; i--) {
-//            for (int i = 0; i < selectedCols.length; i++) {
+            for (int i = 0; i < selectedCols.length; i++) {
                 // Adjust to 0 base
                 selectedCols[i] -= getNumLeadingCols();
                 // Then remove each individual column from model
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/TabularDataTransferHandler.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/TabularDataTransferHandler.java
index 3e77e3bd..e2eb446a 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/TabularDataTransferHandler.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/editor/TabularDataTransferHandler.java
@@ -469,7 +469,7 @@ class TabularDataTransferHandler extends TransferHandler {
       The number of initial "special" columns not used to display the data
       set.
      */
-        int numLeadingCols = 1;
+        int numLeadingCols = 2;
         return numLeadingCols;
     }
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/knowledge_editor/KnowledgeBoxEditor.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/knowledge_editor/KnowledgeBoxEditor.java
index e78d6b2d..ab9fcaa5 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/knowledge_editor/KnowledgeBoxEditor.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/knowledge_editor/KnowledgeBoxEditor.java
@@ -18,6 +18,7 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.knowledge_editor;
 
 import edu.cmu.tetrad.data.DataReader;
@@ -30,85 +31,39 @@ import edu.cmu.tetrad.util.JOptionUtils;
 import edu.cmu.tetrad.util.TetradLogger;
 import edu.cmu.tetradapp.model.ForbiddenGraphModel;
 import edu.cmu.tetradapp.model.KnowledgeBoxModel;
-import java.awt.BorderLayout;
-import java.awt.Color;
-import java.awt.Component;
-import java.awt.Dimension;
-import java.awt.Font;
+
+import javax.swing.*;
+import javax.swing.border.*;
+import javax.swing.event.ChangeEvent;
+import javax.swing.event.ChangeListener;
+import java.awt.*;
 import java.awt.datatransfer.DataFlavor;
 import java.awt.datatransfer.Transferable;
 import java.awt.datatransfer.UnsupportedFlavorException;
-import java.awt.dnd.DnDConstants;
-import java.awt.dnd.DragGestureEvent;
-import java.awt.dnd.DragGestureListener;
-import java.awt.dnd.DragGestureRecognizer;
-import java.awt.dnd.DragSource;
-import java.awt.dnd.DragSourceDragEvent;
-import java.awt.dnd.DragSourceDropEvent;
-import java.awt.dnd.DragSourceEvent;
-import java.awt.dnd.DragSourceListener;
-import java.awt.dnd.DropTarget;
-import java.awt.dnd.DropTargetDragEvent;
-import java.awt.dnd.DropTargetDropEvent;
-import java.awt.dnd.DropTargetEvent;
-import java.awt.dnd.DropTargetListener;
-import java.awt.event.ComponentAdapter;
-import java.awt.event.ComponentEvent;
-import java.awt.event.InputEvent;
-import java.io.CharArrayWriter;
-import java.io.File;
-import java.io.FileReader;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
+import java.awt.dnd.*;
+import java.awt.event.*;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.io.*;
+import java.util.*;
 import java.util.List;
 import java.util.prefs.Preferences;
-import javax.swing.Box;
-import javax.swing.DefaultListModel;
-import javax.swing.JButton;
-import javax.swing.JCheckBox;
-import javax.swing.JComponent;
-import javax.swing.JFileChooser;
-import javax.swing.JLabel;
-import javax.swing.JList;
-import javax.swing.JMenu;
-import javax.swing.JMenuBar;
-import javax.swing.JMenuItem;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-import javax.swing.JScrollPane;
-import javax.swing.JSpinner;
-import javax.swing.JTabbedPane;
-import javax.swing.JTextArea;
-import javax.swing.SpinnerNumberModel;
-import javax.swing.SwingConstants;
-import javax.swing.border.CompoundBorder;
-import javax.swing.border.EmptyBorder;
-import javax.swing.border.LineBorder;
-import javax.swing.border.MatteBorder;
-import javax.swing.border.TitledBorder;
 
 /**
  * Edits knowledge of forbidden and required edges.
- *
  * @author kaalpurush
  */
 public class KnowledgeBoxEditor extends JPanel {
-
     private static final long serialVersionUID = 959706288096545158L;
 
-    private static final long EDGE_LIMIT = 100;
-
     private List<String> varNames;
     private KnowledgeWorkbench edgeWorkbench;
     private JPanel tiersPanel;
-    private boolean showForbiddenExplicitly = false;
-    private boolean showForbiddenByTiers = false;
-    private boolean showRequired = false;
-    private boolean showRequiredByGroups = false;
-    private boolean showForbiddenByGroups = false;
+    private boolean showForbiddenExplicitly = true;
+    private boolean showForbiddenByTiers = true;
+    private boolean showRequired = true;
+    private boolean showRequiredByGroups = true;
+    private boolean showForbiddenByGroups = true;
     private JTextArea textArea;
 
     // Unused, moved to KnowledgeBoxModel. Keeping for serialization. Can delete after a while. 2017.06.17
@@ -172,69 +127,75 @@ public class KnowledgeBoxEditor extends JPanel {
         file.add(load);
         file.add(save);
 
-        load.addActionListener((e) -> {
-            JFileChooser chooser = new JFileChooser();
-            String sessionSaveLocation
-                    = Preferences.userRoot().get("fileSaveLocation", "");
-            chooser.setCurrentDirectory(new File(sessionSaveLocation));
-            chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
+        load.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JFileChooser chooser = new JFileChooser();
+                String sessionSaveLocation =
+                        Preferences.userRoot().get("fileSaveLocation", "");
+                chooser.setCurrentDirectory(new File(sessionSaveLocation));
+                chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
 
-            int ret1 = chooser.showOpenDialog(JOptionUtils.centeringComp());
+                int ret1 = chooser.showOpenDialog(JOptionUtils.centeringComp());
 
-            if (!(ret1 == JFileChooser.APPROVE_OPTION)) {
-                return;
-            }
+                if (!(ret1 == JFileChooser.APPROVE_OPTION)) {
+                    return;
+                }
 
-            final File selectedFile = chooser.getSelectedFile();
+                final File file = chooser.getSelectedFile();
 
-            if (selectedFile == null) {
-                return;
-            }
+                if (file == null) {
+                    return;
+                }
 
-            Preferences.userRoot().put("fileSaveLocation", selectedFile.getParent());
 
-            try {
-                IKnowledge knowledge = new DataReader().parseKnowledge(selectedFile);
+                Preferences.userRoot().put("fileSaveLocation", file.getParent());
 
-                if (knowledge == null) {
-                    throw new NullPointerException("No knowledge found in this file. Perhaps the formatting is off");
-                }
+                try {
+                    IKnowledge knowledge = new DataReader().parseKnowledge(file);
 
-                setKnowledge(knowledge);
-                resetTabbedPane(KnowledgeBoxEditor.this.tabbedPane);
-            } catch (Exception e1) {
-                JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
-                        e1.getMessage());
-                e1.printStackTrace();
+                    if (knowledge == null) {
+                        throw new NullPointerException("No knowledge found in this file. Perhaps the formatting is off");
+                    }
+
+                    setKnowledge(knowledge);
+                    resetTabbedPane(KnowledgeBoxEditor.this.tabbedPane);
+                } catch (Exception e1) {
+                    JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
+                            e1.getMessage());
+                    e1.printStackTrace();
+                }
             }
         });
 
-        save.addActionListener((e) -> {
-            JFileChooser chooser = new JFileChooser();
-            String sessionSaveLocation
-                    = Preferences.userRoot().get("fileSaveLocation", "");
-            chooser.setCurrentDirectory(new File(sessionSaveLocation));
-            chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
+        save.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JFileChooser chooser = new JFileChooser();
+                String sessionSaveLocation =
+                        Preferences.userRoot().get("fileSaveLocation", "");
+                chooser.setCurrentDirectory(new File(sessionSaveLocation));
+                chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
 
-            int ret1 = chooser.showSaveDialog(JOptionUtils.centeringComp());
+                int ret1 = chooser.showSaveDialog(JOptionUtils.centeringComp());
 
-            if (!(ret1 == JFileChooser.APPROVE_OPTION)) {
-                return;
-            }
+                if (!(ret1 == JFileChooser.APPROVE_OPTION)) {
+                    return;
+                }
 
-            final File selectedFile = chooser.getSelectedFile();
+                final File file = chooser.getSelectedFile();
 
-            if (selectedFile == null) {
-                return;
-            }
+                if (file == null) {
+                    return;
+                }
 
-            Preferences.userRoot().put("fileSaveLocation", selectedFile.getParent());
 
-            try {
-                Knowledge.saveKnowledge(knowledgeBoxModel.getKnowledge(), new FileWriter(selectedFile));
-            } catch (Exception e1) {
-                JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
-                        e1.getMessage());
+                Preferences.userRoot().put("fileSaveLocation", file.getParent());
+
+                try {
+                    Knowledge.saveKnowledge(knowledgeBoxModel.getKnowledge(), new FileWriter(file));
+                } catch (Exception e1) {
+                    JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
+                            e1.getMessage());
+                }
             }
         });
 
@@ -246,19 +207,29 @@ public class KnowledgeBoxEditor extends JPanel {
         tabbedPane.add("Tiers", tierDisplay());
         tabbedPane.add("Other Groups", new OtherGroupsEditor(knowledgeBoxModel.getKnowledge(), this.varNames));
         tabbedPane.add("Edges", edgeDisplay());
-
-        tabbedPane.addChangeListener((e) -> {
-            JTabbedPane pane = (JTabbedPane) e.getSource();
-            if (pane.getSelectedIndex() == 0) {
-                setNumDisplayTiers(getNumTiers());
-            } else if (pane.getSelectedIndex() == 2) {
-                resetEdgeDisplay(null);
+//        tabbedPane.add("Text", textDisplay());
+
+        tabbedPane.addChangeListener(new ChangeListener() {
+            public void stateChanged(ChangeEvent e) {
+                JTabbedPane pane = (JTabbedPane) e.getSource();
+                if (pane.getSelectedIndex() == 0) {
+                    setNumDisplayTiers(getNumTiers());
+                } else if (pane.getSelectedIndex() == 2) {
+                    resetEdgeDisplay();
+                }
+//                else if (pane.getSelectedIndex() == 3) {
+//                    resetTextDisplay();
+//                }
             }
         });
 
         this.tabbedPane = tabbedPane;
     }
 
+    // public KnowledgeEditor(KnowledgeWrapper wrapper) {
+    // this(wrapper.getKnowledge());
+    // }
+
     private Box tierDisplay() {
         if (getNumTiers() < 0) {
             int numTiers = getKnowledge().getNumTiers();
@@ -276,20 +247,30 @@ public class KnowledgeBoxEditor extends JPanel {
         b1.add(new JLabel("# Tiers = "));
         SpinnerNumberModel spinnerNumberModel = new SpinnerNumberModel(
                 getNumTiers(), 2, 100, 1);
-        spinnerNumberModel.addChangeListener((e) -> {
-            SpinnerNumberModel model = (SpinnerNumberModel) e.getSource();
-            int numTiers = model.getNumber().intValue();
-
-            setNumDisplayTiers(numTiers);
-            setNumTiers(numTiers);
-            model.setValue(numTiers);
+        spinnerNumberModel.addChangeListener(new ChangeListener() {
+            public void stateChanged(ChangeEvent e) {
+                SpinnerNumberModel model = (SpinnerNumberModel) e.getSource();
+                int numTiers = model.getNumber().intValue();
+
+//                int knowledgeNumTiers = getKnowledge().getNumTiers();
+//
+//                if (numTiers >= knowledgeNumTiers) {
+                    setNumDisplayTiers(numTiers);
+                    setNumTiers(numTiers);
+                    model.setValue(numTiers);
+//                } else {
+//                    model.setValue(numTiers);
+//                    setNumTiers(knowledgeNumTiers);
+//                    model.setValue(numTiers);
+//                }
+
+                for (int i = getNumTiers(); i <= getKnowledge()
+                        .getMaxTierForbiddenWithin(); i++) {
+                    getKnowledge().setTierForbiddenWithin(i, false);
+                }
 
-            for (int i = getNumTiers(); i <= getKnowledge()
-                    .getMaxTierForbiddenWithin(); i++) {
-                getKnowledge().setTierForbiddenWithin(i, false);
+                notifyKnowledge();
             }
-
-            notifyKnowledge();
         });
 
         JSpinner spinner = new JSpinner(spinnerNumberModel);
@@ -362,26 +343,32 @@ public class KnowledgeBoxEditor extends JPanel {
             textRow.add(new JLabel("Tier " + (tier + 1)));
             final int _tier = tier;
 
+
             textRow.add(Box.createHorizontalGlue());
 
             JCheckBox forbiddenCheckbox = new JCheckBox("Forbid Within Tier",
                     getKnowledge().isTierForbiddenWithin(_tier));
             final JComponent upReference = this;
 
-            forbiddenCheckbox.addActionListener((e) -> {
-                JCheckBox checkbox = (JCheckBox) e.getSource();
-                try {
-                    getKnowledge().setTierForbiddenWithin(_tier,
-                            checkbox.isSelected());
-                } catch (Exception e1) {
-                    checkbox.setSelected(false);
-                    JOptionPane.showMessageDialog(upReference, e1.getMessage());
-                }
+            forbiddenCheckbox.addActionListener(new ActionListener() {
+                public void actionPerformed(ActionEvent e) {
+                    JCheckBox checkbox = (JCheckBox) e.getSource();
+                    try {
+                        getKnowledge().setTierForbiddenWithin(_tier,
+                                checkbox.isSelected());
+                    } catch (Exception e1) {
+                        checkbox.setSelected(false);
+                        JOptionPane.showMessageDialog(upReference, e1.getMessage());
+//                        throw new RuntimeException(e1);
+                    }
 
-                notifyKnowledge();
+                    notifyKnowledge();
+                }
             });
 
             textRow.add(forbiddenCheckbox);
+//            JButton expressionButton = new JButton("Add Expression");
+//            textRow.add(expressionButton);
 
             d.add(textRow);
 
@@ -405,17 +392,19 @@ public class KnowledgeBoxEditor extends JPanel {
     private JPanel edgeDisplay() {
         KnowledgeGraph graph = new KnowledgeGraph(getKnowledge());
 
-        graph.addPropertyChangeListener((evt) -> {
-            if ("modelChanged".equals(evt.getPropertyName())) {
-                notifyKnowledge();
+        graph.addPropertyChangeListener(new PropertyChangeListener() {
+            public void propertyChange(PropertyChangeEvent evt) {
+                if ("modelChanged".equals(evt.getPropertyName())) {
+                    notifyKnowledge();
+                }
             }
         });
 
         edgeWorkbench = new KnowledgeWorkbench(graph);
-        resetEdgeDisplay(null);
+        resetEdgeDisplay();
 
         JCheckBox showForbiddenByTiersCheckbox = new JCheckBox(
-                "Show Forbidden By Tiers", showForbiddenByTiers);
+                "Show Forbidden By Tiers", showForbiddenExplicitly);
         JCheckBox showForbiddenExplicitlyCheckbox = new JCheckBox(
                 "Show Forbidden Explicitly", showForbiddenExplicitly);
         JCheckBox showRequiredCheckbox = new JCheckBox(
@@ -425,34 +414,44 @@ public class KnowledgeBoxEditor extends JPanel {
         JCheckBox showForbiddenGroupsCheckBox = new JCheckBox(
                 "Show Forbidden by Groups", this.showForbiddenByGroups);
 
-        showRequiredGroupsCheckBox.addActionListener((e) -> {
-            JCheckBox box = (JCheckBox) e.getSource();
-            showRequiredByGroups = box.isSelected();
-            resetEdgeDisplay(showRequiredGroupsCheckBox);
+        showRequiredGroupsCheckBox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JCheckBox box = (JCheckBox) e.getSource();
+                showRequiredByGroups = box.isSelected();
+                resetEdgeDisplay();
+            }
         });
 
-        showForbiddenGroupsCheckBox.addActionListener((e) -> {
-            JCheckBox box = (JCheckBox) e.getSource();
-            showForbiddenByGroups = box.isSelected();
-            resetEdgeDisplay(showForbiddenGroupsCheckBox);
+        showForbiddenGroupsCheckBox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JCheckBox box = (JCheckBox) e.getSource();
+                showForbiddenByGroups = box.isSelected();
+                resetEdgeDisplay();
+            }
         });
 
-        showForbiddenByTiersCheckbox.addActionListener((e) -> {
-            JCheckBox checkBox = (JCheckBox) e.getSource();
-            setShowForbiddenByTiers(checkBox.isSelected());
-            resetEdgeDisplay(showForbiddenByTiersCheckbox);
+        showForbiddenByTiersCheckbox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JCheckBox checkBox = (JCheckBox) e.getSource();
+                setShowForbiddenByTiers(checkBox.isSelected());
+                resetEdgeDisplay();
+            }
         });
 
-        showForbiddenExplicitlyCheckbox.addActionListener((e) -> {
-            JCheckBox checkBox = (JCheckBox) e.getSource();
-            setShowForbiddenExplicitly(checkBox.isSelected());
-            resetEdgeDisplay(showForbiddenExplicitlyCheckbox);
+        showForbiddenExplicitlyCheckbox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JCheckBox checkBox = (JCheckBox) e.getSource();
+                setShowForbiddenExplicitly(checkBox.isSelected());
+                resetEdgeDisplay();
+            }
         });
 
-        showRequiredCheckbox.addActionListener((e) -> {
-            JCheckBox checkBox = (JCheckBox) e.getSource();
-            setShowRequired(checkBox.isSelected());
-            resetEdgeDisplay(showRequiredCheckbox);
+        showRequiredCheckbox.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JCheckBox checkBox = (JCheckBox) e.getSource();
+                setShowRequired(checkBox.isSelected());
+                resetEdgeDisplay();
+            }
         });
 
         JPanel workbenchPanel = new JPanel();
@@ -490,175 +489,7 @@ public class KnowledgeBoxEditor extends JPanel {
         return display;
     }
 
-    private void resetEdgeDisplay(JCheckBox checkBox) {
-        IKnowledge knowledge = getKnowledge();
-        KnowledgeGraph graph = new KnowledgeGraph(getKnowledge());
-        getVarNames().forEach(e -> {
-            knowledge.addVariable(e);
-            graph.addNode(new KnowledgeModelNode(e));
-        });
-
-        if (this.showRequiredByGroups) {
-            List<KnowledgeEdge> list = knowledge.getListOfRequiredEdges();
-            if (list.size() > EDGE_LIMIT) {
-                showRequiredByGroups = false;
-                if (checkBox != null) {
-                    checkBox.setSelected(false);
-                }
-                String errMsg = String.format("The number of edges to show exceeds the limit %d.", EDGE_LIMIT);
-                JOptionPane.showMessageDialog(this, errMsg, "Unable To Display Edges", JOptionPane.ERROR_MESSAGE);
-            } else {
-                list.forEach(e -> {
-                    String from = e.getFrom();
-                    String to = e.getTo();
-                    if (knowledge.isRequiredByGroups(from, to)) {
-                        KnowledgeModelNode fromNode = (KnowledgeModelNode) graph
-                                .getNode(from);
-                        KnowledgeModelNode toNode = (KnowledgeModelNode) graph
-                                .getNode(to);
-
-                        graph.addEdge(new KnowledgeModelEdge(fromNode, toNode,
-                                KnowledgeModelEdge.REQUIRED_BY_GROUPS));
-                    }
-                });
-            }
-        }
-
-        if (this.showForbiddenByGroups) {
-            List<KnowledgeEdge> list = knowledge.getListOfForbiddenEdges();
-            if (list.size() > EDGE_LIMIT) {
-                showForbiddenByGroups = false;
-                if (checkBox != null) {
-                    checkBox.setSelected(false);
-                }
-                String errMsg = String.format("The number of edges to show exceeds the limit %d.", EDGE_LIMIT);
-                JOptionPane.showMessageDialog(this, errMsg, "Unable To Display Edges", JOptionPane.ERROR_MESSAGE);
-            } else {
-                list.forEach(e -> {
-                    String from = e.getFrom();
-                    String to = e.getTo();
-                    if (knowledge.isForbiddenByGroups(from, to)) {
-                        KnowledgeModelNode fromNode = (KnowledgeModelNode) graph
-                                .getNode(from);
-                        KnowledgeModelNode toNode = (KnowledgeModelNode) graph
-                                .getNode(to);
-
-                        graph.addEdge(new KnowledgeModelEdge(fromNode, toNode,
-                                KnowledgeModelEdge.FORBIDDEN_BY_GROUPS));
-                    }
-                });
-            }
-        }
-
-        if (showRequired) {
-            List<KnowledgeEdge> list = knowledge.getListOfExplicitlyRequiredEdges();
-            if (list.size() > EDGE_LIMIT) {
-                showRequired = false;
-                if (checkBox != null) {
-                    checkBox.setSelected(false);
-                }
-                String errMsg = String.format("The number of edges to show exceeds the limit %d.", EDGE_LIMIT);
-                JOptionPane.showMessageDialog(this, errMsg, "Unable To Display Edges", JOptionPane.ERROR_MESSAGE);
-            } else {
-                list.forEach(e -> {
-                    String from = e.getFrom();
-                    String to = e.getTo();
-                    KnowledgeModelNode fromNode = (KnowledgeModelNode) graph
-                            .getNode(from);
-                    KnowledgeModelNode toNode = (KnowledgeModelNode) graph
-                            .getNode(to);
-
-                    if (!(fromNode == null || toNode == null)) {
-                        graph.addEdge(new KnowledgeModelEdge(fromNode, toNode,
-                                KnowledgeModelEdge.REQUIRED));
-                    }
-                });
-            }
-        }
-
-        if (showForbiddenByTiers) {
-            List<KnowledgeEdge> list = knowledge.getListOfForbiddenEdges();
-            if (list.size() > EDGE_LIMIT) {
-                showForbiddenByTiers = false;
-                if (checkBox != null) {
-                    checkBox.setSelected(false);
-                }
-                String errMsg = String.format("The number of edges to show exceeds the limit %d.", EDGE_LIMIT);
-                JOptionPane.showMessageDialog(this, errMsg, "Unable To Display Edges", JOptionPane.ERROR_MESSAGE);
-            } else {
-                list.forEach(e -> {
-                    String from = e.getFrom();
-                    String to = e.getTo();
-                    if (knowledge.isForbiddenByTiers(from, to)) {
-                        KnowledgeModelNode fromNode = (KnowledgeModelNode) graph
-                                .getNode(from);
-                        KnowledgeModelNode toNode = (KnowledgeModelNode) graph
-                                .getNode(to);
-
-                        if (fromNode == null) {
-                            graph.addNode(new KnowledgeModelNode(from));
-                            fromNode = (KnowledgeModelNode) graph.getNode(from);
-                        }
-
-                        if (toNode == null) {
-                            graph.addNode(new KnowledgeModelNode(to));
-                            toNode = (KnowledgeModelNode) graph.getNode(to);
-                        }
-
-                        KnowledgeModelEdge knowledgeModelEdge = new KnowledgeModelEdge(
-                                fromNode, toNode, KnowledgeModelEdge.FORBIDDEN_BY_TIERS);
-
-                        graph.addEdge(knowledgeModelEdge);
-                    }
-                });
-            }
-        }
-
-        if (showForbiddenExplicitly) {
-            List<KnowledgeEdge> list = knowledge.getListOfExplicitlyForbiddenEdges();
-            if (list.size() > EDGE_LIMIT) {
-                showForbiddenExplicitly = false;
-                if (checkBox != null) {
-                    checkBox.setSelected(false);
-                }
-                String errMsg = String.format("The number of edges to show exceeds the limit %d.", EDGE_LIMIT);
-                JOptionPane.showMessageDialog(this, errMsg, "Unable To Display Edges", JOptionPane.ERROR_MESSAGE);
-            } else {
-                list.forEach(e -> {
-                    String from = e.getFrom();
-                    String to = e.getTo();
-                    KnowledgeModelNode fromNode = (KnowledgeModelNode) graph
-                            .getNode(from);
-                    KnowledgeModelNode toNode = (KnowledgeModelNode) graph
-                            .getNode(to);
-
-                    KnowledgeModelEdge edge = new KnowledgeModelEdge(fromNode,
-                            toNode, KnowledgeModelEdge.FORBIDDEN_EXPLICITLY);
-                    if (!graph.containsEdge(edge)) {
-                        graph.addEdge(edge);
-                    }
-                });
-            }
-        }
-
-        boolean arrangedAll = GraphUtils.arrangeBySourceGraph(graph,
-                edgeWorkbench.getGraph());
-
-        if (!arrangedAll) {
-            GraphUtils.circleLayout(graph, 200, 200, 150);
-        }
-
-        edgeWorkbench.setGraph(graph);
-        if (knowledgeBoxModel != null) {
-            notifyKnowledge();
-        }
-
-    }
-
-    /**
-     * This is an old method that needs to be removed when cleaning up code.
-     */
-    private void resetEdgeDisplayOld() {
+    private void resetEdgeDisplay() {
         List<String> varNames = getVarNames();
         IKnowledge knowledge = getKnowledge();
 
@@ -674,8 +505,8 @@ public class KnowledgeBoxEditor extends JPanel {
 
         if (this.showRequiredByGroups) {
             for (Iterator<KnowledgeEdge> i = knowledge.requiredEdgesIterator(); i
-                    .hasNext();) {
-                KnowledgeEdge edge = i.next();
+                    .hasNext(); ) {
+                KnowledgeEdge edge = i.next()   ;
                 String from = edge.getFrom();
                 String to = edge.getTo();
                 if (knowledge.isRequiredByGroups(from, to)) {
@@ -692,7 +523,7 @@ public class KnowledgeBoxEditor extends JPanel {
 
         if (this.showForbiddenByGroups) {
             for (Iterator<KnowledgeEdge> i = knowledge.forbiddenEdgesIterator(); i
-                    .hasNext();) {
+                    .hasNext(); ) {
                 KnowledgeEdge edge = i.next();
                 String from = edge.getFrom();
                 String to = edge.getTo();
@@ -710,7 +541,7 @@ public class KnowledgeBoxEditor extends JPanel {
 
         if (showRequired) {
             for (Iterator<KnowledgeEdge> i = knowledge
-                    .explicitlyRequiredEdgesIterator(); i.hasNext();) {
+                    .explicitlyRequiredEdgesIterator(); i.hasNext(); ) {
                 KnowledgeEdge pair = i.next();
                 String from = pair.getFrom();
                 String to = pair.getTo();
@@ -730,7 +561,7 @@ public class KnowledgeBoxEditor extends JPanel {
         }
 
         if (showForbiddenByTiers) {
-            for (Iterator<KnowledgeEdge> i = knowledge.forbiddenEdgesIterator(); i.hasNext();) {
+            for (Iterator<KnowledgeEdge> i = knowledge.forbiddenEdgesIterator(); i.hasNext(); ) {
                 KnowledgeEdge pair = i.next();
                 String from = pair.getFrom();
                 String to = pair.getTo();
@@ -767,7 +598,7 @@ public class KnowledgeBoxEditor extends JPanel {
 
         if (showForbiddenExplicitly) {
             for (Iterator<KnowledgeEdge> i = knowledge
-                    .explicitlyForbiddenEdgesIterator(); i.hasNext();) {
+                    .explicitlyForbiddenEdgesIterator(); i.hasNext(); ) {
                 KnowledgeEdge pair = i.next();
 
                 String from = pair.getFrom();
@@ -803,60 +634,71 @@ public class KnowledgeBoxEditor extends JPanel {
         final JButton loadFromTextPaneButton = new JButton("Load from Text Pane");
         final JButton loadFromFileButton = new JButton("Load from File");
 
-        testButton.addActionListener((e) -> {
-            try {
-                String text = getTextArea().getText();
-                DataReader reader = new DataReader();
-                reader.parseKnowledge(text.toCharArray());
-                JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
-                        "Looks good.");
-            } catch (Exception e1) {
-                JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
-                        e1.getMessage());
+        testButton.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+
+                try {
+                    String text = getTextArea().getText();
+                    DataReader reader = new DataReader();
+                    reader.parseKnowledge(text.toCharArray());
+                    JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
+                            "Looks good.");
+                } catch (Exception e1) {
+                    JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
+                            e1.getMessage());
+                }
             }
         });
 
-        loadFromTextPaneButton.addActionListener((e) -> {
-            try {
-                String text = getTextArea().getText();
-                DataReader reader = new DataReader();
-                IKnowledge knowledge = reader.parseKnowledge(text.toCharArray());
-                setKnowledge(knowledge);
-                resetTabbedPane(KnowledgeBoxEditor.this.tabbedPane);
-            } catch (Exception e1) {
-                JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
-                        e1.getMessage());
+        loadFromTextPaneButton.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                try {
+                    String text = getTextArea().getText();
+                    DataReader reader = new DataReader();
+                    IKnowledge knowledge = reader.parseKnowledge(text.toCharArray());
+                    setKnowledge(knowledge);
+//                    setNumTiers(-1);
+                    resetTabbedPane(KnowledgeBoxEditor.this.tabbedPane);
+//                    JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
+//                            "Loaded.");
+                } catch (Exception e1) {
+                    JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
+                            e1.getMessage());
+                }
             }
         });
 
-        loadFromFileButton.addActionListener((e) -> {
-            JFileChooser chooser = new JFileChooser();
-            String sessionSaveLocation
-                    = Preferences.userRoot().get("fileSaveLocation", "");
-            chooser.setCurrentDirectory(new File(sessionSaveLocation));
-            chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
+        loadFromFileButton.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JFileChooser chooser = new JFileChooser();
+                String sessionSaveLocation =
+                        Preferences.userRoot().get("fileSaveLocation", "");
+                chooser.setCurrentDirectory(new File(sessionSaveLocation));
+                chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
 
-            int ret1 = chooser.showOpenDialog(JOptionUtils.centeringComp());
+                int ret1 = chooser.showOpenDialog(JOptionUtils.centeringComp());
 
-            if (!(ret1 == JFileChooser.APPROVE_OPTION)) {
-                return;
-            }
+                if (!(ret1 == JFileChooser.APPROVE_OPTION)) {
+                    return;
+                }
 
-            final File file = chooser.getSelectedFile();
+                final File file = chooser.getSelectedFile();
 
-            if (file == null) {
-                return;
-            }
+                if (file == null) {
+                    return;
+                }
 
-            Preferences.userRoot().put("fileSaveLocation", file.getParent());
 
-            try {
-                IKnowledge knowledge = new DataReader().parseKnowledge(file);
-                setKnowledge(knowledge);
-                resetTabbedPane(KnowledgeBoxEditor.this.tabbedPane);
-            } catch (Exception e1) {
-                JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
-                        e1.getMessage());
+                Preferences.userRoot().put("fileSaveLocation", file.getParent());
+
+                try {
+                    IKnowledge knowledge = new DataReader().parseKnowledge(file);
+                    setKnowledge(knowledge);
+                    resetTabbedPane(KnowledgeBoxEditor.this.tabbedPane);
+                } catch (Exception e1) {
+                    JOptionPane.showMessageDialog(JOptionUtils.centeringComp(),
+                            e1.getMessage());
+                }
             }
         });
 
@@ -973,7 +815,6 @@ public class KnowledgeBoxEditor extends JPanel {
 
     public class DragDropList extends JList implements DropTargetListener,
             DragSourceListener, DragGestureListener {
-
         private List movedList;
 
         /**
@@ -993,26 +834,30 @@ public class KnowledgeBoxEditor extends JPanel {
 
             setLayoutOrientation(JList.HORIZONTAL_WRAP);
             setVisibleRowCount(0);
-            this.setCellRenderer((list, value, index, isSelected, cellHasFocus) -> {
-                Color fillColor = new Color(153, 204, 204);
-                Color selectedFillColor = new Color(255, 204, 102);
-
-                JLabel comp = new JLabel(" " + value + " ");
-                comp.setOpaque(true);
-
-                if (isSelected) {
-                    comp.setForeground(Color.BLACK);
-                    comp.setBackground(selectedFillColor);
-                } else {
-                    comp.setForeground(Color.BLACK);
-                    comp.setBackground(fillColor);
-                }
+            this.setCellRenderer(new ListCellRenderer() {
+                public Component getListCellRendererComponent(JList list,
+                                                              Object value, int index, boolean isSelected,
+                                                              boolean cellHasFocus) {
+                    Color fillColor = new Color(153, 204, 204);
+                    Color selectedFillColor = new Color(255, 204, 102);
+
+                    JLabel comp = new JLabel(" " + value + " ");
+                    comp.setOpaque(true);
+
+                    if (isSelected) {
+                        comp.setForeground(Color.BLACK);
+                        comp.setBackground(selectedFillColor);
+                    } else {
+                        comp.setForeground(Color.BLACK);
+                        comp.setBackground(fillColor);
+                    }
 
-                comp.setHorizontalAlignment(SwingConstants.CENTER);
-                comp.setBorder(new CompoundBorder(new MatteBorder(2, 2, 2,
-                        2, Color.WHITE), new LineBorder(Color.BLACK)));
+                    comp.setHorizontalAlignment(SwingConstants.CENTER);
+                    comp.setBorder(new CompoundBorder(new MatteBorder(2, 2, 2,
+                            2, Color.WHITE), new LineBorder(Color.BLACK)));
 
-                return comp;
+                    return comp;
+                }
             });
 
             new DropTarget(this, DnDConstants.ACTION_MOVE, this, true);
@@ -1021,14 +866,15 @@ public class KnowledgeBoxEditor extends JPanel {
                     DnDConstants.ACTION_MOVE, this);
 
             setModel(new DefaultListModel());
-            items.forEach(item -> ((DefaultListModel) getModel()).addElement(item));
+            for (Object item : items) {
+                ((DefaultListModel) getModel()).addElement(item);
+            }
         }
 
         public int getTier() {
             return tier;
         }
 
-        @Override
         public void dragGestureRecognized(DragGestureEvent dragGestureEvent) {
             if (getSelectedIndex() == -1) {
                 return;
@@ -1046,7 +892,6 @@ public class KnowledgeBoxEditor extends JPanel {
             }
         }
 
-        @Override
         public void drop(DropTargetDropEvent dropTargetDropEvent) {
             try {
                 Transferable tr = dropTargetDropEvent.getTransferable();
@@ -1086,7 +931,6 @@ public class KnowledgeBoxEditor extends JPanel {
             }
         }
 
-        @Override
         public void dragDropEnd(DragSourceDropEvent dsde) {
             if (!dsde.getDropSuccess()) {
                 return;
@@ -1101,35 +945,27 @@ public class KnowledgeBoxEditor extends JPanel {
             }
         }
 
-        @Override
         public void dragEnter(DropTargetDragEvent dtde) {
         }
 
-        @Override
         public void dragOver(DropTargetDragEvent dtde) {
         }
 
-        @Override
         public void dropActionChanged(DropTargetDragEvent dtde) {
         }
 
-        @Override
         public void dragExit(DropTargetEvent dte) {
         }
 
-        @Override
         public void dragEnter(DragSourceDragEvent dsde) {
         }
 
-        @Override
         public void dragOver(DragSourceDragEvent dsde) {
         }
 
-        @Override
         public void dropActionChanged(DragSourceDragEvent dsde) {
         }
 
-        @Override
         public void dragExit(DragSourceEvent dse) {
         }
 
@@ -1141,25 +977,29 @@ public class KnowledgeBoxEditor extends JPanel {
                 strings.add((String) e);
             }
 
-            Collections.sort(strings, (o1, o2) -> {
-                String[] tokens1 = o1.split(":");
-                String[] tokens2 = o2.split(":");
+            Collections.sort(strings, new Comparator<String>() {
+                @Override
+                public int compare(String o1, String o2) {
+                    String[] tokens1 = o1.split(":");
+                    String[] tokens2 = o2.split(":");
 
-                if (tokens1.length == 1) {
-                    tokens1 = new String[]{tokens1[0], "0"};
-                }
+                    if (tokens1.length == 1) {
+                        tokens1 = new String[]{tokens1[0], "0"};
+                    }
 
-                if (tokens2.length == 1) {
-                    tokens2 = new String[]{tokens2[0], "0"};
-                }
+                    if (tokens2.length == 1) {
+                        tokens2 = new String[]{tokens2[0], "0"};
+                    }
 
-                int i1 = tokens1[1].compareTo(tokens2[1]);
-                int i0 = tokens1[0].compareTo(tokens2[0]);
+                    int i1 = tokens1[1].compareTo(tokens2[1]);
+                    int i0 = tokens1[0].compareTo(tokens2[0]);
 
-                if (i1 == 0) {
-                    return i0;
-                } else {
-                    return i1;
+                    if (i1 == 0) {
+                        return i0;
+                    }
+                    else {
+                        return i1;
+                    }
                 }
             });
 
@@ -1171,26 +1011,23 @@ public class KnowledgeBoxEditor extends JPanel {
         }
     }
 
-    private static final class MyDragGestureRecognizer extends DragGestureRecognizer {
-
-        private static final long serialVersionUID = -2859027146893129647L;
-
+    private static final class MyDragGestureRecognizer extends
+            DragGestureRecognizer {
         public MyDragGestureRecognizer(DragSource ds) {
             super(ds);
         }
 
-        @Override
         protected void registerListeners() {
         }
 
-        @Override
         protected void unregisterListeners() {
         }
 
-        @Override
         protected synchronized void appendEvent(InputEvent awtie) {
             super.appendEvent(awtie);
         }
     }
-
 }
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/DataStandardizer.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/DataStandardizer.java
index 850705be..27ba3cf4 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/DataStandardizer.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/DataStandardizer.java
@@ -50,6 +50,10 @@ public class DataStandardizer extends DataWrapper {
 
             DataSet dataSet = (DataSet) model;
 
+            if (!(dataSet.isContinuous())) {
+                throw new IllegalArgumentException("Not a continuous data set: " + dataSet.getName());
+            }
+
             TetradMatrix data2 = DataUtils.standardizeData(dataSet.getDoubleData());
             List<Node> list = dataSet.getVariables();
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/EdgewiseComparisonModel.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/EdgewiseComparisonModel.java
index fca3bac7..7df9fc81 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/EdgewiseComparisonModel.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/EdgewiseComparisonModel.java
@@ -105,11 +105,9 @@ public final class EdgewiseComparisonModel implements SessionModel, DoNotAddOldM
         String referenceName = this.params.getString("referenceGraphName", null);
 
         if (referenceName.equals(model1.getName())) {
-//            if (model1 instanceof Simulation && model2 instanceof GeneralAlgorithmRunner) {
-//                this.referenceGraphs = ((GeneralAlgorithmRunner) model2).getCompareGraphs(((Simulation) model1).getGraphs());
-//            }
-//            else
-            if (model1 instanceof MultipleGraphSource) {
+            if (model1 instanceof Simulation && model2 instanceof GeneralAlgorithmRunner) {
+                this.referenceGraphs = ((GeneralAlgorithmRunner) model2).getCompareGraphs(((Simulation) model1).getGraphs());
+            } else if (model1 instanceof MultipleGraphSource) {
                 this.referenceGraphs = ((MultipleGraphSource) model1).getGraphs();
             }
 
@@ -141,10 +139,9 @@ public final class EdgewiseComparisonModel implements SessionModel, DoNotAddOldM
                 this.targetGraphs = Collections.singletonList(((GraphSource) model2).getGraph());
             }
         } else if (referenceName.equals(model2.getName())) {
-//            if (model2 instanceof Simulation && model1 instanceof GeneralAlgorithmRunner) {
-//                this.referenceGraphs = ((GeneralAlgorithmRunner) model1).getCompareGraphs(((Simulation) model2).getGraphs());
-//            } else
-            if (model1 instanceof MultipleGraphSource) {
+            if (model2 instanceof Simulation && model1 instanceof GeneralAlgorithmRunner) {
+                this.referenceGraphs = ((GeneralAlgorithmRunner) model1).getCompareGraphs(((Simulation) model2).getGraphs());
+            } else if (model1 instanceof MultipleGraphSource) {
                 this.referenceGraphs = ((MultipleGraphSource) model2).getGraphs();
             }
 
@@ -283,7 +280,6 @@ public final class EdgewiseComparisonModel implements SessionModel, DoNotAddOldM
     public List<Graph> getTargetGraphs() {
         return targetGraphs;
     }
-
     public List<Graph> getReferenceGraphs() {
         return referenceGraphs;
     }
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/ForbiddenGraphModel.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/ForbiddenGraphModel.java
index 57bc2bb6..679bfe4e 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/ForbiddenGraphModel.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/ForbiddenGraphModel.java
@@ -18,6 +18,7 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.model;
 
 import edu.cmu.tetrad.data.IKnowledge;
@@ -30,6 +31,7 @@ import edu.cmu.tetrad.graph.Node;
 import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.util.TetradLogger;
 import edu.cmu.tetrad.util.TetradSerializableUtils;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.SortedSet;
@@ -39,16 +41,17 @@ import java.util.TreeSet;
  * @author kaalpurush
  */
 public class ForbiddenGraphModel extends KnowledgeBoxModel {
-
     static final long serialVersionUID = 23L;
 
     /**
-     * @serial @deprecated
+     * @serial
+     * @deprecated
      */
     private IKnowledge knowledge;
 
     /**
-     * @serial @deprecated
+     * @serial
+     * @deprecated
      */
 //    private List<Knowledge> knowledgeList;
     private List<Node> variables = new ArrayList<>();
@@ -127,6 +130,7 @@ public class ForbiddenGraphModel extends KnowledgeBoxModel {
         this(params, input);
     }
 
+
     /**
      * Constructor from dataWrapper edge
      */
@@ -168,20 +172,15 @@ public class ForbiddenGraphModel extends KnowledgeBoxModel {
     }
 
     private void createKnowledge(Parameters params) {
-        IKnowledge knwl = getKnowledge();
-        if (knwl == null) {
-            return;
-        }
-
-        knwl.clear();
+        IKnowledge knowledge = (IKnowledge) params.get("knowledge", new Knowledge2());
+        knowledge.clear();
 
-        List<String> varNames = getVarNames();
-        getKnowledgeBoxInput().getVariableNames().stream()
-                .filter(e -> !e.startsWith("E_"))
-                .forEach(e -> {
-                    varNames.add(e);
-                    knwl.addVariable(e);
-                });
+        for (String varName : getKnowledgeBoxInput().getVariableNames()) {
+            if (!varName.startsWith("E_")) {
+                getVarNames().add(varName);
+                knowledge.addVariable(varName);
+            }
+        }
 
         if (resultGraph == null) {
             throw new NullPointerException("I couldn't find a parent graph.");
@@ -189,19 +188,25 @@ public class ForbiddenGraphModel extends KnowledgeBoxModel {
 
         List<Node> nodes = resultGraph.getNodes();
 
-        int numOfNodes = nodes.size();
-        for (int i = 0; i < numOfNodes; i++) {
-            for (int j = i + 1; j < numOfNodes; j++) {
-                Node n1 = nodes.get(i);
-                Node n2 = nodes.get(j);
+        for (int i = 0; i < nodes.size(); i++) {
+            for (int j = i + 1; j < nodes.size(); j++) {
+//                if (resultGraph.getEdges().size() >= 2) continue;
+                if (nodes.get(i).getName().startsWith("E_")) continue;
+                if (nodes.get(j).getName().startsWith("E_")) continue;
 
-                if (n1.getName().startsWith("E_") || n2.getName().startsWith("E_")) {
-                    continue;
-                }
+                Edge edge = resultGraph.getEdge(nodes.get(i), nodes.get(j));
 
-                Edge edge = resultGraph.getEdge(n1, n2);
-                if (edge != null && edge.isDirected()) {
-                    knwl.setForbidden(edge.getNode2().getName(), edge.getNode1().getName());
+                if (edge == null) {
+                    Node node1 = nodes.get(i);
+                    Node node2 = nodes.get(j);
+                    knowledge.setForbidden(node1.getName(), node2.getName());
+                    knowledge.setForbidden(node2.getName(), node1.getName());
+                }
+                else if (edge.isDirected()) {
+                    Node node1 = edge.getNode1();
+                    Node node2 = edge.getNode2();
+                    knowledge.setForbidden(node2.getName(), node1.getName());
+//                    knowledge.setEdgeRequired(node1.getNode(), node2.getNode(), true);
                 }
             }
         }
@@ -219,5 +224,7 @@ public class ForbiddenGraphModel extends KnowledgeBoxModel {
     public Graph getResultGraph() {
         return resultGraph;
     }
-
 }
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/GeneralAlgorithmRunner.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/GeneralAlgorithmRunner.java
index 578fa104..4cc01559 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/GeneralAlgorithmRunner.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/GeneralAlgorithmRunner.java
@@ -53,7 +53,6 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.stream.Collectors;
 
 /**
  * Stores an algorithms in the format of the algorithm comparison API.
@@ -230,13 +229,13 @@ public class GeneralAlgorithmRunner implements AlgorithmRunner, ParamsResettable
 
         if (getDataModelList().isEmpty()) {
             if (getSourceGraph() != null) {
-                Algorithm algo = getAlgorithm();
+                Algorithm algorithm = getAlgorithm();
 
-                if (algo instanceof HasKnowledge) {
-                    ((HasKnowledge) algo).setKnowledge(getKnowledge());
+                if (algorithm instanceof HasKnowledge) {
+                    ((HasKnowledge) algorithm).setKnowledge(getKnowledge());
                 }
 
-                graphList.add(algo.search(null, parameters));
+                graphList.add(algorithm.search(null, parameters));
             } else {
                 throw new IllegalArgumentException("The parent boxes did not include any datasets or graphs. Try opening\n"
                         + "the editors for those boxes and loading or simulating them.");
@@ -244,29 +243,36 @@ public class GeneralAlgorithmRunner implements AlgorithmRunner, ParamsResettable
         } else {
             if (getAlgorithm() instanceof MultiDataSetAlgorithm) {
                 for (int k = 0; k < parameters.getInt("numRuns"); k++) {
-                    List<DataSet> dataSets = getDataModelList().stream()
-                            .map(e -> (DataSet) e)
-                            .collect(Collectors.toCollection(ArrayList::new));
+                    List<DataSet> dataSets = new ArrayList<>();
+
+                    for (DataModel dataModel : getDataModelList()) {
+                        dataSets.add((DataSet) dataModel);
+                    }
+
                     if (dataSets.size() < parameters.getInt("randomSelectionSize")) {
                         throw new IllegalArgumentException("Sorry, the 'random selection size' is greater than "
                                 + "the number of data sets.");
                     }
+
                     Collections.shuffle(dataSets);
 
                     List<DataModel> sub = new ArrayList<>();
+
                     for (int j = 0; j < parameters.getInt("randomSelectionSize"); j++) {
                         sub.add(dataSets.get(j));
                     }
 
-                    Algorithm algo = getAlgorithm();
-                    if (algo instanceof HasKnowledge) {
-                        ((HasKnowledge) algo).setKnowledge(getKnowledge());
+                    Algorithm algorithm = getAlgorithm();
+
+                    if (algorithm instanceof HasKnowledge) {
+                        ((HasKnowledge) algorithm).setKnowledge(getKnowledge());
                     }
-                    graphList.add(((MultiDataSetAlgorithm) algo).search(sub, parameters));
+
+                    graphList.add(((MultiDataSetAlgorithm) algorithm).search(sub, parameters));
                 }
             } else if (getAlgorithm() instanceof ClusterAlgorithm) {
                 for (int k = 0; k < parameters.getInt("numRuns"); k++) {
-                    getDataModelList().forEach(dataModel -> {
+                    for (DataModel dataModel : getDataModelList()) {
                         if (dataModel instanceof ICovarianceMatrix) {
                             ICovarianceMatrix dataSet = (ICovarianceMatrix) dataModel;
                             graphList.add(algorithm.search(dataSet, parameters));
@@ -279,33 +285,30 @@ public class GeneralAlgorithmRunner implements AlgorithmRunner, ParamsResettable
 
                             graphList.add(algorithm.search(dataSet, parameters));
                         }
-                    });
+                    }
                 }
             } else {
-                getDataModelList().forEach(data -> {
-                    IKnowledge knowledgeFromData = data.getKnowledge();
-                    if (!(knowledgeFromData == null || knowledgeFromData.getVariables().isEmpty())) {
-                        this.knowledge = knowledgeFromData;
-                    }
+                for (DataModel data : getDataModelList()) {
 
-                    Algorithm algo = getAlgorithm();
-                    if (algo instanceof HasKnowledge) {
-                        ((HasKnowledge) algo).setKnowledge(getKnowledge());
+                    Algorithm algorithm = getAlgorithm();
+
+                    if (algorithm instanceof HasKnowledge) {
+                        ((HasKnowledge) algorithm).setKnowledge(getKnowledge());
                     }
 
-                    DataType algDataType = algo.getDataType();
+                    DataType algDataType = algorithm.getDataType();
 
                     if (data.isContinuous() && (algDataType == DataType.Continuous || algDataType == DataType.Mixed)) {
-                        graphList.add(algo.search(data, parameters));
+                        graphList.add(algorithm.search(data, parameters));
                     } else if (data.isDiscrete() && (algDataType == DataType.Discrete || algDataType == DataType.Mixed)) {
-                        graphList.add(algo.search(data, parameters));
+                        graphList.add(algorithm.search(data, parameters));
                     } else if (data.isMixed() && algDataType == DataType.Mixed) {
-                        graphList.add(algo.search(data, parameters));
+                        graphList.add(algorithm.search(data, parameters));
                     } else {
                         throw new IllegalArgumentException("The type of data changed; try opening up the search editor and "
                                 + "running the algorithm there.");
                     }
-                });
+                }
             }
         }
 
@@ -456,17 +459,17 @@ public class GeneralAlgorithmRunner implements AlgorithmRunner, ParamsResettable
 
     @Override
     public List<String> getTriplesClassificationTypes() {
-        return Collections.EMPTY_LIST;
+        return null;
     }
 
     @Override
     public List<List<Triple>> getTriplesLists(Node node) {
-        return Collections.EMPTY_LIST;
+        return null;
     }
 
     @Override
     public Map<String, String> getParamSettings() {
-        return Collections.EMPTY_MAP;
+        return null;
     }
 
     @Override
@@ -476,7 +479,7 @@ public class GeneralAlgorithmRunner implements AlgorithmRunner, ParamsResettable
 
     @Override
     public Map<String, String> getAllParamSettings() {
-        return Collections.EMPTY_MAP;
+        return null;
     }
 
     @Override
@@ -507,12 +510,12 @@ public class GeneralAlgorithmRunner implements AlgorithmRunner, ParamsResettable
 
     @Override
     public List<Node> getVariables() {
-        return Collections.EMPTY_LIST;
+        return null;
     }
 
     @Override
     public List<String> getVariableNames() {
-        return Collections.EMPTY_LIST;
+        return null;
     }
 
     public List<Graph> getCompareGraphs(List<Graph> graphs) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/GraphSelectionWrapper.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/GraphSelectionWrapper.java
index b313cdc3..6c19fbe3 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/GraphSelectionWrapper.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/GraphSelectionWrapper.java
@@ -50,7 +50,7 @@ public class GraphSelectionWrapper implements SessionModel, GraphSource, Knowled
     private List<Graph> graphs = new ArrayList<>();
 
     public enum Type {
-        Subgraph, Parents, Children, Adjacents, Adjacents_of_Adjacents, Adjacents_of_Adjacents_of_Adjacents, Markov_Blankets, Treks, Trek_Edges,
+        Subgraph, Adjacents, Adjacents_of_Adjacents, Adjacents_of_Adjacents_of_Adjacents, Markov_Blankets, Treks, Trek_Edges,
         Paths, Path_Edges, Directed_Paths, Directed_Path_Edges, Y_Structures,
         Pag_Y_Structures, Indegree, Out_Degree, Degree
     }
@@ -177,24 +177,6 @@ public class GraphSelectionWrapper implements SessionModel, GraphSource, Knowled
                 adj.addAll((getSelectedGraph(k).getAdjacentNodes(node)));
             }
 
-            selectedGraph = (getSelectedGraph(k).subgraph(new ArrayList<>(adj)));
-            params.set("highlightInEditor", selectedVariables);
-        } else if (params.getString("graphSelectionType", "subgraph").equals(Type.Parents.toString())) {
-            Set<Node> adj = new HashSet<>(selectedVariables);
-
-            for (Node node : selectedVariables) {
-                adj.addAll((getSelectedGraph(k).getParents(node)));
-            }
-
-            selectedGraph = (getSelectedGraph(k).subgraph(new ArrayList<>(adj)));
-            params.set("highlightInEditor", selectedVariables);
-        } else if (params.getString("graphSelectionType", "subgraph").equals(Type.Children.toString())) {
-            Set<Node> adj = new HashSet<>(selectedVariables);
-
-            for (Node node : selectedVariables) {
-                adj.addAll((getSelectedGraph(k).getChildren(node)));
-            }
-
             selectedGraph = (getSelectedGraph(k).subgraph(new ArrayList<>(adj)));
             params.set("highlightInEditor", selectedVariables);
         } else if (params.getString("graphSelectionType", "Subgraph").equals(Type.Adjacents_of_Adjacents.toString())) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LingamRunner.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LingamRunner.java
index 96b0eed0..801e55f4 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LingamRunner.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LingamRunner.java
@@ -56,7 +56,7 @@ public class LingamRunner extends AbstractAlgorithmRunner implements GraphSource
     public LingamRunner(DataWrapper dataWrapper) {
         super(dataWrapper, new Parameters(), null);
     }
-
+    
     public LingamRunner(DataWrapper dataWrapper, Parameters params) {
         super(dataWrapper, params, null);
     }
@@ -75,14 +75,14 @@ public class LingamRunner extends AbstractAlgorithmRunner implements GraphSource
     public LingamRunner(GraphSource graphWrapper, Parameters params, KnowledgeBoxModel knowledgeBoxModel) {
         super(graphWrapper.getGraph(), params, knowledgeBoxModel);
     }
-
+    
     /**
      * Constucts a wrapper for the given EdgeListGraph.
      */
     public LingamRunner(GraphSource graphWrapper, Parameters params) {
         super(graphWrapper.getGraph(), params, null);
     }
-
+    
     /**
      * Generates a simple exemplar of this class to test serialization.
      *
@@ -122,6 +122,8 @@ public class LingamRunner extends AbstractAlgorithmRunner implements GraphSource
 //        Graph graph = lingam.lingam(data).getGraph();
 
         Lingam lingam = new Lingam();
+        Parameters params = getParams();
+        lingam.setPruneFactor(params.getDouble("pruneFactor", 1.0));
         Graph graph = lingam.search(data);
 
         if (getSourceGraph() != null) {
@@ -198,3 +200,4 @@ public class LingamRunner extends AbstractAlgorithmRunner implements GraphSource
     }
 }
 
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LingamStructureRunner.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LingamStructureRunner.java
index 8b06975a..67527d87 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LingamStructureRunner.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LingamStructureRunner.java
@@ -97,6 +97,7 @@ public class LingamStructureRunner extends AbstractAlgorithmRunner implements Gr
 
         Lingam lingam = new Lingam();
         Parameters params = getParams();
+        lingam.setPruneFactor(params.getDouble("pruneFactor", 1.0));
         Graph graph = lingam.search(data);
 
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LogisticRegressionRunner.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LogisticRegressionRunner.java
index be7a35e1..a4c7ffd3 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LogisticRegressionRunner.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/LogisticRegressionRunner.java
@@ -18,14 +18,10 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.model;
 
-import edu.cmu.tetrad.data.ColtDataSet;
-import edu.cmu.tetrad.data.ContinuousVariable;
-import edu.cmu.tetrad.data.DataModel;
-import edu.cmu.tetrad.data.DataModelList;
-import edu.cmu.tetrad.data.DataSet;
-import edu.cmu.tetrad.data.DiscreteVariable;
+import edu.cmu.tetrad.data.*;
 import edu.cmu.tetrad.graph.EdgeListGraph;
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.graph.Node;
@@ -35,13 +31,10 @@ import edu.cmu.tetrad.search.ImpliedOrientation;
 import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.util.TetradLogger;
 import edu.cmu.tetrad.util.TetradSerializableUtils;
+
 import java.io.IOException;
 import java.io.ObjectInputStream;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 /**
  * Extends AbstractAlgorithmRunner to produce a wrapper for the Regression
@@ -50,7 +43,6 @@ import java.util.Map;
  * @author Frank Wimberly after Joe Ramsey's PcRunner
  */
 public class LogisticRegressionRunner implements AlgorithmRunner, RegressionModel {
-
     static final long serialVersionUID = 23L;
 
     private String name;
@@ -70,12 +62,14 @@ public class LogisticRegressionRunner implements AlgorithmRunner, RegressionMode
     private List<String> variableNames;
 
     //=========================CONSTRUCTORS===============================//
+
     /**
      * Constructs a wrapper for the given DataWrapper. The DataWrapper must
      * contain a DataSet that is either a DataSet or a DataSet or a DataList
      * containing either a DataSet or a DataSet as its selected model.
      */
-    public LogisticRegressionRunner(DataWrapper dataWrapper, Parameters params) {
+    public LogisticRegressionRunner(DataWrapper dataWrapper,
+                                    Parameters params) {
         if (dataWrapper == null) {
             throw new NullPointerException();
         }
@@ -148,6 +142,7 @@ public class LogisticRegressionRunner implements AlgorithmRunner, RegressionMode
     }
 
     //===========================PUBLIC METHODS============================//
+
     public DataModel getDataModel() {
         return dataSets.get(getModelIndex());
     }
@@ -159,9 +154,6 @@ public class LogisticRegressionRunner implements AlgorithmRunner, RegressionMode
         return alpha;//this.params.getDouble("alpha", 0.001);
     }
 
-    public void setAlpha(double alpha) {
-        this.alpha = alpha;
-    }
 
     public LogisticRegression.Result getResult() {
         return this.result;
@@ -184,22 +176,21 @@ public class LogisticRegressionRunner implements AlgorithmRunner, RegressionMode
     }
 
     //=================PUBLIC METHODS OVERRIDING ABSTRACT=================//
+
     /**
      * Executes the algorithm, producing (at least) a result workbench. Must be
      * implemented in the extending class.
      */
     public void execute() {
-        outGraph = new EdgeListGraph();
-
         if (regressorNames == null || regressorNames.isEmpty() || targetName == null) {
             report = "Response and predictor variables not set.";
-
+            outGraph = new EdgeListGraph();
             return;
         }
 
         if (regressorNames.contains(targetName)) {
             report = "Response must not be a predictor.";
-
+            outGraph = new EdgeListGraph();
             return;
         }
 
@@ -329,11 +320,10 @@ public class LogisticRegressionRunner implements AlgorithmRunner, RegressionMode
     }
 
     /**
-     * @param node The node that the classifications are for. All triple from
-     * adjacencies to this node to adjacencies to this node through the given
-     * node will be considered.
-     * @return the list of triples corresponding to
-     * <code>getTripleClassificationNames</code> for the given node.
+     * @param node The node that the classifications are for. All triple from adjacencies to this
+     *             node to adjacencies to this node through the given node will be considered.
+     * @return the list of triples corresponding to <code>getTripleClassificationNames</code>
+     * for the given node.
      */
     public List<List<Triple>> getTriplesLists(Node node) {
         return new LinkedList<>();
@@ -382,3 +372,9 @@ public class LogisticRegressionRunner implements AlgorithmRunner, RegressionMode
         return null;
     }
 }
+
+
+
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/Misclassifications.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/Misclassifications.java
index 5d32af17..fb75ca1f 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/Misclassifications.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/Misclassifications.java
@@ -314,12 +314,18 @@ public final class Misclassifications implements SessionModel, DoNotAddOldModel
 
                 log("info", "Graph Comparison");
 
-        for (int i = 0; i < referenceGraphs.size(); i++) {
+        for (
+                int i = 0;
+                i < referenceGraphs.size(); i++)
+
+        {
             TetradLogger.getInstance().log("comparison", "\nModel " + (i + 1));
             TetradLogger.getInstance().log("comparison", getComparisonString(i));
         }
 
-        this.nf = NumberFormatUtil.getInstance().getNumberFormat();
+        this.nf = NumberFormatUtil.getInstance().
+
+                getNumberFormat();
 
     }
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/RequiredGraphModel.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/RequiredGraphModel.java
index e30a7fa3..7ea6464b 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/RequiredGraphModel.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/RequiredGraphModel.java
@@ -18,19 +18,17 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetradapp.model;
 
 import edu.cmu.tetrad.data.IKnowledge;
 import edu.cmu.tetrad.data.Knowledge2;
 import edu.cmu.tetrad.data.KnowledgeBoxInput;
-import edu.cmu.tetrad.graph.Edge;
-import edu.cmu.tetrad.graph.EdgeListGraph;
-import edu.cmu.tetrad.graph.Edges;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.graph.Node;
+import edu.cmu.tetrad.graph.*;
 import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.util.TetradLogger;
 import edu.cmu.tetrad.util.TetradSerializableUtils;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.SortedSet;
@@ -40,20 +38,22 @@ import java.util.TreeSet;
  * @author kaalpurush
  */
 public class RequiredGraphModel extends KnowledgeBoxModel {
-
     static final long serialVersionUID = 23L;
 
 //    private String name;
 //    private Parameters params;
 //    private KnowledgeBoxInput knowledgeBoxInput;
 //    private List<String> varNames = new ArrayList<String>();
+
     /**
-     * @serial @deprecated
+     * @serial
+     * @deprecated
      */
     private IKnowledge knowledge;
 
     /**
-     * @serial @deprecated
+     * @serial
+     * @deprecated
      */
 //    private List<Knowledge> knowledgeList;
     private List<Node> variables = new ArrayList<>();
@@ -132,6 +132,7 @@ public class RequiredGraphModel extends KnowledgeBoxModel {
         this(params, input);
     }
 
+
     /**
      * Constructor from dataWrapper edge
      */
@@ -173,20 +174,15 @@ public class RequiredGraphModel extends KnowledgeBoxModel {
     }
 
     private void createKnowledge(Parameters params) {
-        IKnowledge knwl = getKnowledge();
-        if (knwl == null) {
-            return;
-        }
+        IKnowledge knowledge = (IKnowledge) params.get("knowledge", new Knowledge2());
+        knowledge.clear();
 
-        knwl.clear();
-
-        List<String> varNames = getVarNames();
-        getKnowledgeBoxInput().getVariableNames().stream()
-                .filter(e -> !e.startsWith("E_"))
-                .forEach(e -> {
-                    varNames.add(e);
-                    knwl.addVariable(e);
-                });
+        for (String varName : getKnowledgeBoxInput().getVariableNames()) {
+            if (!varName.startsWith("E_")) {
+                getVarNames().add(varName);
+                knowledge.addVariable(varName);
+            }
+        }
 
         if (resultGraph == null) {
             throw new NullPointerException("I couldn't find a parent graph.");
@@ -194,24 +190,28 @@ public class RequiredGraphModel extends KnowledgeBoxModel {
 
         List<Node> nodes = resultGraph.getNodes();
 
-        int numOfNodes = nodes.size();
-        for (int i = 0; i < numOfNodes; i++) {
-            for (int j = i + 1; j < numOfNodes; j++) {
-                Node n1 = nodes.get(i);
-                Node n2 = nodes.get(j);
+        for (int i = 0; i < nodes.size(); i++) {
+            for (int j = i + 1; j < nodes.size(); j++) {
+//                if (resultGraph.getEdges().size() >= 2) continue;
+                if (nodes.get(i).getName().startsWith("E_")) continue;
+                if (nodes.get(j).getName().startsWith("E_")) continue;
 
-                if (n1.getName().startsWith("E_") || n2.getName().startsWith("E_")) {
-                    continue;
-                }
+                Edge edge = resultGraph.getEdge(nodes.get(i), nodes.get(j));
 
-                Edge edge = resultGraph.getEdge(n1, n2);
                 if (edge == null) {
                     continue;
-                } else if (edge.isDirected()) {
-                    knwl.setRequired(edge.getNode1().getName(), edge.getNode2().getName());
-                } else if (Edges.isUndirectedEdge(edge)) {
-                    knwl.setRequired(n1.getName(), n2.getName());
-                    knwl.setRequired(n2.getName(), n1.getName());
+                }
+                else if (edge.isDirected()) {
+                    Node node1 = edge.getNode1();
+                    Node node2 = edge.getNode2();
+//                    knowledge.setEdgeForbidden(node2.getNode(), node1.getNode(), true);
+                    knowledge.setRequired(node1.getName(), node2.getName());
+                }
+                else if (Edges.isUndirectedEdge(edge)) {
+                    Node node1 = edge.getNode1();
+                    Node node2 = edge.getNode2();
+                    knowledge.setRequired(node1.getName(), node2.getName());
+                    knowledge.setRequired(node2.getName(), node1.getName());
                 }
             }
         }
@@ -230,3 +230,6 @@ public class RequiredGraphModel extends KnowledgeBoxModel {
         return resultGraph;
     }
 }
+
+
+
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/Simulation.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/Simulation.java
index 9d09427d..178c8f46 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/Simulation.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/Simulation.java
@@ -64,8 +64,7 @@ public class Simulation extends DataWrapper implements SessionModel,
 
     public Simulation(Parameters parameters) {
         if (simulation == null) {
-            // By default there shouldn't be a simulation until the users create one - Zhou
-            //this.simulation = new BayesNetSimulation(new RandomForward());
+            this.simulation = new BayesNetSimulation(new RandomForward());
             this.parameters = parameters;
             this.fixedGraph = false;
             this.fixedSimulation = false;
@@ -89,7 +88,7 @@ public class Simulation extends DataWrapper implements SessionModel,
             this.name = simulation.name + ".copy";
             this.fixedGraph = simulation.fixedGraph;
             this.fixedSimulation = simulation.fixedSimulation;
-//            createSimulation(); // The suggestion is that you should't actually simulate before the user clicks 'simulate'
+            createSimulation();
         } else {
             simulation = new BayesNetSimulation(new SingleGraph(graphSource.getGraph()));
             this.fixedGraph = true;
@@ -108,73 +107,73 @@ public class Simulation extends DataWrapper implements SessionModel,
     public Simulation(BayesImWrapperObs wrapper, Parameters parameters) {
         simulation = new BayesNetSimulation(wrapper.getBayesIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(BayesPmWrapper wrapper, Parameters parameters) {
         simulation = new BayesNetSimulation(wrapper.getBayesPm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(BayesEstimatorWrapper wrapper, Parameters parameters) {
         simulation = new BayesNetSimulation(wrapper.getEstimatedBayesIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(DirichletBayesImWrapper wrapper, Parameters parameters) {
         simulation = new BayesNetSimulation(wrapper.getDirichletBayesIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(DirichletEstimatorWrapper wrapper, Parameters parameters) {
         simulation = new BayesNetSimulation(wrapper.getEstimatedBayesIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(CptInvariantUpdaterWrapper wrapper, Parameters parameters) {
         simulation = new BayesNetSimulation(wrapper.getBayesUpdater().getManipulatedBayesIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(SemPmWrapper wrapper, Parameters parameters) {
         simulation = new SemSimulation(wrapper.getSemPm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(SemImWrapper wrapper, Parameters parameters) {
         simulation = new SemSimulation(wrapper.getSemIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(StandardizedSemImWrapper wrapper, Parameters parameters) {
         simulation = new StandardizedSemSimulation(wrapper.getStandardizedSemIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(SemEstimatorWrapper wrapper, Parameters parameters) {
         simulation = new SemSimulation(wrapper.getEstimatedSemIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(SemUpdaterWrapper wrapper, Parameters parameters) {
         simulation = new SemSimulation(wrapper.getSemUpdater().getManipulatedSemIm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(GeneralizedSemPmWrapper wrapper, Parameters parameters) {
         simulation = new GeneralSemSimulation(wrapper.getSemPm());
         this.parameters = parameters;
-//        createSimulation();
+        createSimulation();
     }
 
     public Simulation(GeneralizedSemImWrapper wrapper, Parameters parameters) {
@@ -273,9 +272,9 @@ public class Simulation extends DataWrapper implements SessionModel,
     }
 
     public void createSimulation() {
-//        if (simulation.getNumDataModels() == 0) {
-        simulation.createData(parameters);
-//        }
+        if (simulation.getNumDataModels() == 0) {
+            simulation.createData(parameters);
+        }
     }
 
     @Override
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/TabularComparison.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/TabularComparison.java
index 2077265e..4dc47d08 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/TabularComparison.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/TabularComparison.java
@@ -96,10 +96,9 @@ public final class TabularComparison implements SessionModel, SimulationParamsSo
         String referenceName = params.getString("referenceGraphName", null);
 
         if (referenceName.equals(model1.getName())) {
-//            if (model1 instanceof Simulation && model2 instanceof GeneralAlgorithmRunner) {
-//                this.referenceGraphs = ((GeneralAlgorithmRunner) model2).getCompareGraphs(((Simulation) model1).getGraphs());
-//            } else
-            if (model1 instanceof MultipleGraphSource) {
+            if (model1 instanceof Simulation && model2 instanceof GeneralAlgorithmRunner) {
+                this.referenceGraphs = ((GeneralAlgorithmRunner) model2).getCompareGraphs(((Simulation) model1).getGraphs());
+            } else if (model1 instanceof MultipleGraphSource) {
                 this.referenceGraphs = ((MultipleGraphSource) model1).getGraphs();
             }
 
@@ -131,10 +130,9 @@ public final class TabularComparison implements SessionModel, SimulationParamsSo
                 this.targetGraphs = Collections.singletonList(((GraphSource) model2).getGraph());
             }
         } else if (referenceName.equals(model2.getName())) {
-//            if (model2 instanceof Simulation && model1 instanceof GeneralAlgorithmRunner) {
-//                this.referenceGraphs = ((GeneralAlgorithmRunner) model1).getCompareGraphs(((Simulation) model2).getGraphs());
-//            } else
-            if (model1 instanceof MultipleGraphSource) {
+            if (model2 instanceof Simulation && model1 instanceof GeneralAlgorithmRunner) {
+                this.referenceGraphs = ((GeneralAlgorithmRunner) model1).getCompareGraphs(((Simulation) model2).getGraphs());
+            } else if (model1 instanceof MultipleGraphSource) {
                 this.referenceGraphs = ((MultipleGraphSource) model2).getGraphs();
             }
 
@@ -180,9 +178,7 @@ public final class TabularComparison implements SessionModel, SimulationParamsSo
         }
         if (algorithm != null) {
             for (int i = 0; i < referenceGraphs.size(); i++) {
-                Graph comparisonGraph = algorithm.getComparisonGraph(referenceGraphs.get(i));
-                comparisonGraph = GraphUtils.replaceNodes(comparisonGraph, getTrueGraph().getNodes());
-                referenceGraphs.set(i, comparisonGraph);
+                referenceGraphs.set(i, algorithm.getComparisonGraph(referenceGraphs.get(i)));
             }
         }
 
@@ -208,7 +204,6 @@ public final class TabularComparison implements SessionModel, SimulationParamsSo
         statistics.add(new TwoCyclePrecision());
         statistics.add(new TwoCycleRecall());
         statistics.add(new TwoCycleFalsePositive());
-
 //        statistics.add(new ElapsedTime());
 //        statistics.add(new F1Adj());
 //        statistics.add(new F1Arrow());
@@ -216,22 +211,6 @@ public final class TabularComparison implements SessionModel, SimulationParamsSo
 //        statistics.add(new MathewsCorrArrow());
 //        statistics.add(new SHD());
 
-//        statistics.add(new AdjacencyPrecision());
-//        statistics.add(new AdjacencyRecall());
-//        statistics.add(new ArrowheadPrecisionIgnore2c());
-//        statistics.add(new ArrowheadRecall());
-
-//        statistics.add(new AncestorPrecision());
-//        statistics.add(new AncestorRecall());
-//        statistics.add(new TwoCycleFalsePositive());
-//        statistics.add(new TwoCycleFalseNegative());
-////        statistics.add(new MathewsCorrAdj());
-//        statistics.add(new MathewsCorrArrow());
-////        statistics.add(new F1Adj());
-////        statistics.add(new F1Arrow());
-////        statistics.add(new SHD());
-////        statistics.add(new ElapsedTime());
-
         List<Node> variables = new ArrayList<>();
 
         for (Statistic statistic : statistics) {
@@ -264,6 +243,7 @@ public final class TabularComparison implements SessionModel, SimulationParamsSo
 //    }
 
     //==============================PUBLIC METHODS========================//
+
     public DataSet getDataSet() {
         return this.dataSet;
     }
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetContinuousVariablesWrapper.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetContinuousVariablesWrapper.java
index 037da190..43cab6aa 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetContinuousVariablesWrapper.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetContinuousVariablesWrapper.java
@@ -22,11 +22,15 @@
 package edu.cmu.tetradapp.model.datamanip;
 
 import edu.cmu.tetrad.data.*;
+import edu.cmu.tetrad.graph.Node;
 import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.util.TetradSerializableUtils;
 import edu.cmu.tetradapp.model.DataWrapper;
 import edu.cmu.tetradapp.model.PcRunner;
 
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Add description
  *
@@ -44,7 +48,7 @@ public class SubsetContinuousVariablesWrapper extends DataWrapper {
         if (!(model instanceof DataSet)) {
             throw new IllegalArgumentException("The given dataset must be tabular");
         }
-        this.setDataModel(DataUtils.copycContinuousVariables((DataSet) model));
+        this.setDataModel(createModel((DataSet) model));
         this.setSourceGraph(data.getSourceGraph());
 
         LogDataUtils.logDataModelList("Parent data restricted to continuous variables only.", getDataModelList());
@@ -64,6 +68,38 @@ public class SubsetContinuousVariablesWrapper extends DataWrapper {
     //=========================== Private Methods =================================//
 
 
+    private static DataModel createModel(DataSet data) {
+//        for (int i = data.getNumColumns() -1; i >= 0; i--) {
+//            if (!(data.getVariable(i) instanceof ContinuousVariable)) {
+//                data.removeColumn(i);
+//            }
+//        }
+//        return data;
+
+        List<Node> variables = data.getVariables();
+
+        int n = 0;
+        for (Node variable : variables) {
+            if (variable instanceof ContinuousVariable) {
+                n++;
+            }
+        }
+        if (n == 0) {
+            return new ColtDataSet(0, new ArrayList<Node>());
+        }
+
+        int[] indices = new int[n];
+        int m = 0;
+        for (int i = 0; i < variables.size(); i++) {
+            if (variables.get(i) instanceof ContinuousVariable) {
+                indices[m++] = i;
+            }
+        }
+
+        return data.subsetColumns(indices);
+    }
+
+
 }
 
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetDiscreteVariablesWrapper.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetDiscreteVariablesWrapper.java
index 1369aee7..e9661088 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetDiscreteVariablesWrapper.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetDiscreteVariablesWrapper.java
@@ -22,11 +22,15 @@
 package edu.cmu.tetradapp.model.datamanip;
 
 import edu.cmu.tetrad.data.*;
+import edu.cmu.tetrad.graph.Node;
 import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.util.TetradSerializableUtils;
 import edu.cmu.tetradapp.model.DataWrapper;
 import edu.cmu.tetradapp.model.PcRunner;
 
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Add description
  *
@@ -44,7 +48,7 @@ public class SubsetDiscreteVariablesWrapper extends DataWrapper {
         if (!(model instanceof DataSet)) {
             throw new IllegalArgumentException("The given dataset must be tabular");
         }
-        this.setDataModel(DataUtils.copyDiscreteVariables((DataSet) model));
+        this.setDataModel(createModel((DataSet) model));
         this.setSourceGraph(data.getSourceGraph());
 
         LogDataUtils.logDataModelList("Parent data restricted to discrete variables only.", getDataModelList());
@@ -64,6 +68,38 @@ public class SubsetDiscreteVariablesWrapper extends DataWrapper {
     //=========================== Private Methods =================================//
 
 
+    private static DataModel createModel(DataSet data) {
+//        for (int i = data.getNumColumns() -1; i >= 0; i--) {
+//            if (!(data.getVariable(i) instanceof DiscreteVariable)) {
+//                data.removeColumn(i);
+//            }
+//        }
+//        return data;
+
+        List<Node> variables = data.getVariables();
+
+        int n = 0;
+        for (Node variable : variables) {
+            if (variable instanceof DiscreteVariable) {
+                n++;
+            }
+        }
+        if (n == 0) {
+            return new ColtDataSet(0, new ArrayList<Node>());
+        }
+
+        int[] indices = new int[n];
+        int m = 0;
+        for (int i = 0; i < variables.size(); i++) {
+            if (variables.get(i) instanceof DiscreteVariable) {
+                indices[m++] = i;
+            }
+        }
+
+        return data.subsetColumns(indices);
+    }
+
+
 }
 
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetSelectedVariablesWrapper.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetSelectedVariablesWrapper.java
index 962cf3ef..7872c753 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetSelectedVariablesWrapper.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/SubsetSelectedVariablesWrapper.java
@@ -29,8 +29,6 @@ import edu.cmu.tetrad.util.TetradSerializableUtils;
 import edu.cmu.tetradapp.model.DataWrapper;
 import edu.cmu.tetradapp.model.PcRunner;
 
-import java.util.List;
-
 /**
  * Add description
  *
@@ -76,27 +74,12 @@ public class SubsetSelectedVariablesWrapper extends DataWrapper {
 
 
     private static DataModel createRectangularModel(DataSet data) {
-        int numSelected = 0;
-
-        List<Node> variables = data.getVariables();
-
-        for (Node node : variables) {
-            if (data.isSelected(node)) {
-                numSelected++;
-            }
-        }
-
-        int[] selectedIndices = new int[numSelected];
-        int index = 0;
-
-        for (int i = 0; i < variables.size(); i++) {
-            Node node = variables.get(i);
-            if (data.isSelected(node)) {
-                selectedIndices[index++] = i;
+        for (int i = data.getNumColumns() -1; i >= 0; i--) {
+            if (!data.isSelected(data.getVariable(i))) {
+                data.removeColumn(i);
             }
-        }
-
-        return data.subsetColumns(selectedIndices);
+        }                                    
+        return data;
     }
 
     private static DataModel createCovarianceModel(ICovarianceMatrix data) {
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/TimeSeriesWrapper2.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/TimeSeriesWrapper2.java
index 34a3aad9..09957ebd 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/TimeSeriesWrapper2.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/model/datamanip/TimeSeriesWrapper2.java
@@ -21,8 +21,10 @@
 
 package edu.cmu.tetradapp.model.datamanip;
 
-import edu.cmu.tetrad.algcomparison.utils.HasKnowledge;
-import edu.cmu.tetrad.data.*;
+import edu.cmu.tetrad.data.DataModel;
+import edu.cmu.tetrad.data.DataModelList;
+import edu.cmu.tetrad.data.DataSet;
+import edu.cmu.tetrad.data.LogDataUtils;
 import edu.cmu.tetrad.search.TimeSeriesUtils;
 import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.util.TetradSerializableUtils;
@@ -32,7 +34,7 @@ import edu.cmu.tetradapp.model.PcRunner;
 /**
  * @author Tyler
  */
-public class TimeSeriesWrapper2 extends DataWrapper implements KnowledgeTransferable {
+public class TimeSeriesWrapper2 extends DataWrapper {
     static final long serialVersionUID = 23L;
 
     /**
@@ -47,11 +49,11 @@ public class TimeSeriesWrapper2 extends DataWrapper implements KnowledgeTransfer
 
         for (DataModel dataModel : dataSets) {
             if (!(dataModel instanceof DataSet)) {
-                throw new IllegalArgumentException("Can only add an index to tabular data.");
+                throw new IllegalArgumentException("Only tabular data sets can be converted to time lagged form.");
             }
 
             DataSet dataSet = (DataSet) dataModel;
-            DataSet timeSeries = TimeSeriesUtils.addIndex(dataSet);
+            DataSet timeSeries = TimeSeriesUtils.createLagDataWithIndex(dataSet, params.getInt("numTimeLags", 1));
             if (dataSet.getName() != null) {
                 timeSeries.setName(dataSet.getName());
             }
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/study/TestSachs.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/study/TestSachs.java
deleted file mode 100644
index 5982f1fc..00000000
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/study/TestSachs.java
+++ /dev/null
@@ -1,1304 +0,0 @@
-package edu.cmu.tetradapp.study;
-
-import edu.cmu.tetrad.algcomparison.Comparison;
-import edu.cmu.tetrad.algcomparison.algorithm.Algorithm;
-import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
-import edu.cmu.tetrad.algcomparison.algorithm.multi.Fask;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Cpc;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Pc;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.SingleGraphAlg;
-import edu.cmu.tetrad.algcomparison.independence.BDeuTest;
-import edu.cmu.tetrad.algcomparison.independence.SemBicTest;
-import edu.cmu.tetrad.algcomparison.score.BdeuScore;
-import edu.cmu.tetrad.algcomparison.score.SemBicScore;
-import edu.cmu.tetrad.algcomparison.simulation.Simulation;
-import edu.cmu.tetrad.algcomparison.simulation.Simulations;
-import edu.cmu.tetrad.algcomparison.statistic.*;
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.*;
-import edu.cmu.tetrad.search.SemBicScoreImages;
-import edu.cmu.tetrad.util.Parameters;
-import edu.cmu.tetrad.util.RandomUtil;
-import edu.cmu.tetradapp.workbench.PngWriter;
-import edu.pitt.dbmi.data.Dataset;
-import org.junit.Test;
-
-import java.io.*;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import static edu.cmu.tetrad.util.StatUtils.mean;
-import static edu.cmu.tetrad.util.StatUtils.sd;
-import static java.lang.Math.abs;
-import static java.lang.Math.log;
-
-public class TestSachs {
-
-    @Test
-    public void test1() {
-        Statistic ap = new AdjacencyPrecision();
-        Statistic ar = new AdjacencyRecall();
-        Statistic ahp = new ArrowheadPrecisionIgnore2c();
-        Statistic ahr = new ArrowheadRecall();
-
-        List<String> paths = new ArrayList<>();
-
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/1. cd3cd28.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/2. cd3cd28icam2.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/3. cd3cd28+aktinhib.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/4. cd3cd28+g0076.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/5. cd3cd28+psitect.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/6. cd3cd28+u0126.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/7. cd3cd28+ly.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/8. pma.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/9. b2camp.txt");
-
-        File dir = new File("/Users/user/Downloads/sachs/data/Data Files/main.result/");
-
-        File graphFile = new File("/Users/user/Downloads/sachsgraphs/groundtruth/ground.truth2.txt");
-//        File file2 = new File("/Users/user/Downloads/sachs/graphs/biologist.view.txt");
-        Graph groundTruth = GraphUtils.loadGraphTxt(graphFile);
-
-        for (Node node : groundTruth.getNodes()) {
-            node.setName(node.getName().toLowerCase());
-            if ("plcg".equals(node.getName())) node.setName("plc");
-        }
-
-        groundTruth = GraphUtils.replaceNodes(groundTruth, groundTruth.getNodes());
-
-        File[] filesArr = dir.listFiles();
-        List<File> files = new ArrayList<>();
-
-        for (File file : filesArr) {
-            if (!file.getName().startsWith(".")) {
-                files.add(file);
-            }
-        }
-
-        List<Algorithm> algorithms = new ArrayList<>();
-
-        algorithms.add(new Fask(new edu.cmu.tetrad.algcomparison.score.SemBicScore()));
-//        algorithms.add(new Pc(new edu.cmu.tetrad.algcomparison.independence.SemBicTest()));
-//        algorithms.add(new Cpc(new edu.cmu.tetrad.algcomparison.independence.SemBicTest()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Fges(new SemBicScore()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Fci(new SemBicTest()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Gfci(new SemBicTest(), new SemBicScore()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.FaskGfci(new SemBicTest()));
-
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.multi.ImagesSemBic());
-
-
-        Parameters parameters = new Parameters();
-
-        double[] penalties = {.5}; // only do one at a time or the computer will freeze up!
-        boolean[] loggedArr = {true, false};
-
-        for (double penalty : penalties) {
-            for (boolean logged : loggedArr) {
-
-                parameters.set("penaltyDiscount", penalty);
-                parameters.set("twoCycleAlpha", 1e-3);
-                parameters.set("faskDelta", -0.2);
-                parameters.set("numRuns", 1);
-                parameters.set("randomSelectionSize", 9);
-
-                File commonDir = new File("/Users/user/Downloads/sachsgraphs/test/tetrad3/penalty." + penalty + "/" + (logged ? "logged" : "raw"));
-                commonDir.mkdirs();
-
-                for (Algorithm alg : algorithms) {
-                    File algDir = new File(commonDir, alg.getDescription() + (logged ? ".logged" : ".raw"));
-                    algDir.mkdirs();
-
-                    File txtDir = new File(algDir, "txt");
-                    txtDir.mkdirs();
-
-                    File pngDir = new File(algDir, "png");
-                    pngDir.mkdirs();
-
-                    Graph combinedGraph = new EdgeListGraph(groundTruth.getNodes());
-
-
-                    for (int f = 0; f < files.size(); f++) {
-
-                        File file = new File(paths.get(f));
-
-                        System.out.println(file.getName());
-
-
-                        DataSet data = null;
-
-                        try {
-                            DataReader reader = new DataReader();
-                            reader.setVariablesSupplied(true);
-                            reader.setDelimiter(DelimiterType.TAB);
-                            data = reader.parseTabular(file);
-                        } catch (IOException e) {
-                            e.printStackTrace();
-                        }
-
-                        Graph estGraph = alg.search(data, parameters);
-
-                        System.out.println(estGraph.getNodes());
-
-                        for (Node node : estGraph.getNodes()) {
-                            node.setName(node.getName().toLowerCase());
-                            if ("praf".equals(node.getName())) node.setName("raf");
-                            if ("pmek".equals(node.getName())) node.setName("mek");
-                            if ("plcg".equals(node.getName())) node.setName("plc");
-                            if ("p44/42".equals(node.getName())) node.setName("erk");
-                            if ("pakts473".equals(node.getName())) node.setName("akt");
-                            if ("pjnk".equals(node.getName())) node.setName("jnk");
-                        }
-
-                        estGraph = GraphUtils.replaceNodes(estGraph, groundTruth.getNodes());
-
-                        System.out.println(groundTruth);
-                        System.out.println(estGraph);
-
-                        System.out.println("AP = " + ap.getValue(groundTruth, estGraph));
-                        System.out.println("AR = " + ar.getValue(groundTruth, estGraph));
-                        System.out.println("AHP = " + ahp.getValue(groundTruth, estGraph));
-                        System.out.println("AHR = " + ahr.getValue(groundTruth, estGraph));
-
-                        for (Edge edge : estGraph.getEdges()) {
-                            if (!combinedGraph.containsEdge(edge)) combinedGraph.addEdge(edge);
-                        }
-
-
-                        String name = "data." + (f + 1);
-
-                        if (new File(algDir, name + ".png").exists()) {
-                            continue;
-                        }
-
-                        int[][] pos = {
-                                {345, 120},
-                                {360, 210},
-                                {45, 180},
-                                {60, 380},
-                                {120, 300},
-                                {345, 285},
-                                {285, 360},
-                                {105, 105},
-                                {240, 30},
-                                {200, 270},
-                                {120, 210}
-                        };
-
-                        for (int i = 0; i < 11; i++) {
-                            Node node = estGraph.getNodes().get(i);
-                            node.setCenter(pos[i][0], pos[i][1]);
-                        }
-
-//                        GraphUtils.circleLayout(estGraph, 200, 200, 175);
-
-                        GraphUtils.saveGraph(estGraph, new File(txtDir, name + ".txt"), false);
-
-                        PngWriter.writePng(estGraph, new File(pngDir, name + ".png"));
-                    }
-
-                    String name = "combined" + (logged ? ".logged" : ".raw");
-                    GraphUtils.saveGraph(combinedGraph, new File(txtDir, name + ".txt"), false);
-
-                    GraphUtils.circleLayout(combinedGraph, 200, 200, 175);
-                    PngWriter.writePng(combinedGraph, new File(pngDir, name + ".png"));
-
-                    System.out.println("AP = " + ap.getValue(groundTruth, combinedGraph));
-                    System.out.println("AR = " + ar.getValue(groundTruth, combinedGraph));
-                    System.out.println("AHP = " + ahp.getValue(groundTruth, combinedGraph));
-                    System.out.println("AHR = " + ahr.getValue(groundTruth, combinedGraph));
-                }
-            }
-        }
-    }
-
-    @Test
-    public void test2() {
-        File txt = new File("/Users/user/Downloads/sachsgraphs/generalized.scoring.metrics.with.GES.search/raw.larger.kernel.width/txt");
-        File png = new File("/Users/user/Downloads/sachsgraphs/generalized.scoring.metrics.with.GES.search/raw.larger.kernel.width/png");
-
-        String[] _vars = {"raf", "mek", "plc", "pip2", "pip3", "erk", "akt", "pka", "pkc", "p38", "jnk"};
-        List<Node> vars = new ArrayList<>();
-        for (String name : _vars) {
-            vars.add(new ContinuousVariable(name));
-        }
-
-        File[] files = txt.listFiles();
-
-        Graph combined = new EdgeListGraph(vars);
-
-        try {
-            for (File file : files) {
-                if (file.getName().startsWith(".")) continue;
-
-                DataReader reader = new DataReader();
-                reader.setVariablesSupplied(false);
-                reader.setDelimiter(DelimiterType.COMMA);
-                DataSet data = reader.parseTabular(file);
-
-                Graph graph = new EdgeListGraph(vars);
-
-                for (int j = 0; j < 11; j++) {
-                    for (int i = 0; i < 11; i++) {
-                        if (data.getDouble(i, j) == 1) {
-                            Edge edge = Edges.directedEdge(vars.get(i), vars.get(j));
-
-                            if (!graph.containsEdge(edge)) {
-                                graph.addEdge(edge);
-                            }
-
-                            if (!combined.containsEdge(edge)) {
-                                combined.addEdge(edge);
-                            }
-                        } else if (data.getDouble(i, j) == -1) {
-                            Edge edge = Edges.undirectedEdge(vars.get(i), vars.get(j));
-
-                            if (!graph.containsEdge(edge)) {
-                                graph.addEdge(edge);
-                            }
-
-                            if (!combined.containsEdge(edge)) {
-                                combined.addEdge(edge);
-                            }
-                        }
-                    }
-                }
-
-                GraphUtils.circleLayout(graph, 200, 200, 175);
-                PngWriter.writePng(graph, new File(png, file.getName() + ".png"));
-            }
-
-            GraphUtils.circleLayout(combined, 200, 200, 175);
-            PngWriter.writePng(combined, new File(png, "combined.png"));
-            GraphUtils.saveGraph(combined, new File(txt, "combined.txt"), false);
-
-            GraphUtils.circleLayout(combined, 200, 200, 175);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test3() {
-
-        // Concatenate the "main result" data.
-        File dir = new File("/Users/user/Downloads/sachs/data/Data Files/main.result/");
-
-        File[] filesArr = dir.listFiles();
-        List<File> files = new ArrayList<>();
-
-        for (File file : filesArr) {
-            if (!file.getName().startsWith(".")) {
-                files.add(file);
-            }
-        }
-
-        List<DataSet> dataSets = new ArrayList<>();
-
-        List<String> paths = new ArrayList<>();
-
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/1. cd3cd28.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/2. cd3cd28icam2.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/3. cd3cd28+aktinhib.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/4. cd3cd28+g0076.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/5. cd3cd28+psitect.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/6. cd3cd28+u0126.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/7. cd3cd28+ly.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/8. pma.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/9. b2camp.txt");
-
-        for (int f = 0; f < paths.size(); f++) {
-
-            File file = new File(paths.get(f));
-
-            System.out.println(file.getName());
-
-            DataSet data = null;
-            try {
-                DataReader reader = new DataReader();
-                reader.setVariablesSupplied(true);
-                reader.setDelimiter(DelimiterType.WHITESPACE);
-                data = reader.parseTabular(file);
-            } catch (IOException e) {
-                throw new RuntimeException(e);
-            }
-
-            for (int i = 0; i < data.getNumRows(); i++) {
-                for (int j = 0; j < data.getNumColumns(); j++) {
-                    data.setDouble(i, j, log(0.0001 + data.getDouble(i, j)));
-                }
-            }
-
-            dataSets.add(DataUtils.center(data));
-        }
-
-        DataSet concat = DataUtils.concatenate(dataSets);
-
-//        double[][] concatdoubles = concat.getDoubleData().transpose().toArray();
-//
-//        double[] min = new double[concatdoubles.length];
-//
-//        for (int j = 0; j < min.length; j++) min[j] = min(concatdoubles[j]);
-//
-//        DataSet logged = concat.copy();
-//
-//        for (int i = 0; i < concat.getNumRows(); i++) {
-//            for (int j = 0; j < concat.getNumColumns(); j++) {
-//                logged.setDouble(i, j, log(0.0001 - min[j] + concatdoubles[j][i]));
-//            }
-//        }
-
-//        try {
-////            DataWriter.writeRectangularData(concat,
-////                    new FileWriter("/Users/user/Downloads/sachsgraphs/test/concat.main.result.centered.txt"),
-////                    '\t');
-////            DataWriter.writeRectangularData(logged,
-////                    new FileWriter("/Users/user/Downloads/sachsgraphs/test/concat.main.result.centered.logged.txt"),
-////                    '\t');
-//
-////            DataWriter.writeRectangularData(concat,
-////                    new FileWriter("/Users/user/Downloads/sachsgraphs/test/concat.main.result.logged.centered.txt"),
-////                    '\t');
-//        } catch (IOException e) {
-//            e.printStackTrace();
-//        }
-    }
-
-    @Test
-    public void test4() {
-        File centeredLoggedFile = new File("/Users/user/Downloads/sachsgraphs/data/combined.data2/nonparametric.concatenated.txt");
-//        File centeredFile = new File("/Users/user/Downloads/sachsgraphs/data/combined.centered.data/concat.main.result.centered.txt");
-
-        List<Algorithm> algorithms = new ArrayList<>();
-
-        algorithms.add(new Fask(new edu.cmu.tetrad.algcomparison.score.SemBicScore()));
-        algorithms.add(new Pc(new edu.cmu.tetrad.algcomparison.independence.SemBicTest()));
-        algorithms.add(new Cpc(new edu.cmu.tetrad.algcomparison.independence.SemBicTest()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Fges(new SemBicScore()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Fci(new SemBicTest()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Gfci(new SemBicTest(), new SemBicScore()));
-
-        Parameters parameters = new Parameters();
-
-        double[] penalties = {2, 1, .5, .1}; // only do one at a time or the computer will freeze up!
-        boolean[] loggedArr = {true, false};
-
-        for (double penalty : penalties) {
-
-            parameters.set("penaltyDiscount", penalty);
-            parameters.set("twoCycleAlpha", 1e-6);
-            parameters.set("presumePositiveCoefficients", true);
-
-            File commonDir = new File("/Users/user/Downloads/sachsgraphs/test/tetrad2/standardizedcombined/penalty." + penalty + "/" + "raw");
-            commonDir.mkdirs();
-
-            for (Algorithm alg : algorithms) {
-                File algDir = new File(commonDir, alg.getDescription() + (".raw"));
-                algDir.mkdirs();
-
-                File txtDir = new File(algDir, "txt");
-                txtDir.mkdirs();
-
-                File pngDir = new File(algDir, "png");
-                pngDir.mkdirs();
-
-                DataSet data1 = null;
-                try {
-                    DataReader reader = new DataReader();
-                    reader.setVariablesSupplied(true);
-                    reader.setDelimiter(DelimiterType.TAB);
-
-//                        if (logged) {
-                    data1 = reader.parseTabular(centeredLoggedFile);
-//                        } else {
-//                            data1 = reader.parseTabular(centeredFile);
-//                        }
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-
-                Graph combinedGraph = alg.search(data1, parameters);
-
-                System.out.println(combinedGraph.getNodes());
-
-                for (Node node : combinedGraph.getNodes()) {
-                    node.setName(node.getName().toLowerCase());
-                    if ("praf".equals(node.getName())) node.setName("raf");
-                    if ("pmek".equals(node.getName())) node.setName("mek");
-                    if ("plcg".equals(node.getName())) node.setName("plc");
-                    if ("p44/42".equals(node.getName())) node.setName("erk");
-                    if ("pakts473".equals(node.getName())) node.setName("akt");
-                    if ("pjnk".equals(node.getName())) node.setName("jnk");
-                }
-
-                String name = "combined";
-
-                if (new File(algDir, name + ".png").exists()) {
-                    continue;
-                }
-
-                GraphUtils.circleLayout(combinedGraph, 200, 200, 175);
-
-//                GraphUtils.saveGraph(combinedGraph, new File(txtDir, name + ".txt"), false);
-
-                PngWriter.writePng(combinedGraph, new File(pngDir, name + ".png"));
-
-                GraphUtils.circleLayout(combinedGraph, 200, 200, 175);
-                PngWriter.writePng(combinedGraph, new File(pngDir, name + ".png"));
-            }
-        }
-    }
-
-    @Test
-    public void test5() {
-        Statistic ap = new AdjacencyPrecision();
-        Statistic ar = new AdjacencyRecall();
-        Statistic ahp = new ArrowheadPrecisionIgnore2c();
-        Statistic ahr = new ArrowheadRecall();
-
-        List<String> paths = new ArrayList<>();
-
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/1. cd3cd28.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/2. cd3cd28icam2.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/3. cd3cd28+aktinhib.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/4. cd3cd28+g0076.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/5. cd3cd28+psitect.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/6. cd3cd28+u0126.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/7. cd3cd28+ly.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/8. pma.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/9. b2camp.txt");
-
-        File dir = new File("/Users/user/Downloads/sachs/data/Data Files/main.result/");
-
-        File graphFile = new File("/Users/user/Downloads/sachs/graphs/ground.truth.txt");
-//        File file2 = new File("/Users/user/Downloads/sachs/graphs/biologist.view.txt");
-        Graph groundTruth = GraphUtils.loadGraphTxt(graphFile);
-
-        for (Node node : groundTruth.getNodes()) {
-            node.setName(node.getName().toLowerCase());
-            if ("plcg".equals(node.getName())) node.setName("plc");
-        }
-
-        groundTruth = GraphUtils.replaceNodes(groundTruth, groundTruth.getNodes());
-
-        File[] filesArr = dir.listFiles();
-        List<File> files = new ArrayList<>();
-
-        for (File file : filesArr) {
-            if (!file.getName().startsWith(".")) {
-                files.add(file);
-            }
-        }
-
-        List<Algorithm> algorithms = new ArrayList<>();
-
-//        algorithms.add(new Fask(new edu.cmu.tetrad.algcomparison.score.SemBicScore()));
-//        algorithms.add(new Pc(new edu.cmu.tetrad.algcomparison.independence.SemBicTest()));
-//        algorithms.add(new Cpc(new edu.cmu.tetrad.algcomparison.independence.SemBicTest()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Fges(new SemBicScore()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Fci(new SemBicTest()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Gfci(new SemBicTest(), new SemBicScore()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.FaskGfci(new SemBicTest()));
-
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.multi.ImagesSemBic());
-
-
-        Parameters parameters = new Parameters();
-
-        double[] penalties = {2, 1, .5, .1}; // only do one at a time or the computer will freeze up!
-        boolean[] loggedArr = {true, false};
-
-        for (double penalty : penalties) {
-            for (boolean logged : loggedArr) {
-
-                parameters.set("penaltyDiscount", penalty);
-                parameters.set("twoCycleAlpha", 1e-6);
-                parameters.set("presumePositiveCoefficients", true);
-                parameters.set("numRuns", 1);
-                parameters.set("randomSelectionSize", 9);
-
-                File commonDir = new File("/Users/user/Downloads/sachsgraphs/test/tetrad2/penalty." + penalty + "/" + (logged ? "logged" : "raw"));
-                commonDir.mkdirs();
-
-                for (Algorithm alg : algorithms) {
-                    File algDir = new File(commonDir, alg.getDescription() + (logged ? ".logged" : ".raw"));
-                    algDir.mkdirs();
-
-                    File txtDir = new File(algDir, "txt");
-                    txtDir.mkdirs();
-
-                    File pngDir = new File(algDir, "png");
-                    pngDir.mkdirs();
-
-                    List<DataModel> dataSets = new ArrayList<>();
-
-                    for (int f = 0; f < files.size(); f++) {
-
-                        File file = new File(paths.get(f));
-
-                        System.out.println(file.getName());
-
-                        DataSet data1 = null;
-                        try {
-                            DataReader reader = new DataReader();
-                            reader.setVariablesSupplied(true);
-                            reader.setDelimiter(DelimiterType.WHITESPACE);
-                            data1 = reader.parseTabular(file);
-
-                            for (Node node : data1.getVariables()) {
-                                node.setName(node.getName().toLowerCase());
-                                if ("praf".equals(node.getName())) node.setName("raf");
-                                if ("pmek".equals(node.getName())) node.setName("mek");
-                                if ("plcg".equals(node.getName())) node.setName("plc");
-                                if ("p44/42".equals(node.getName())) node.setName("erk");
-                                if ("pakts473".equals(node.getName())) node.setName("akt");
-                                if ("pjnk".equals(node.getName())) node.setName("jnk");
-                            }
-
-                            if (logged) {
-                                for (int i = 0; i < data1.getNumRows(); i++) {
-                                    for (int j = 0; j < data1.getNumColumns(); j++) {
-                                        data1.setDouble(i, j, log(0.0001 + data1.getDouble(i, j)));
-                                    }
-                                }
-                            }
-
-                            dataSets.add(data1);
-                        } catch (IOException e) {
-                            e.printStackTrace();
-                        }
-                    }
-
-                    SemBicScoreImages imagesScore = new SemBicScoreImages(dataSets);
-                    imagesScore.setPenaltyDiscount(penalty);
-
-                    edu.cmu.tetrad.search.Fges fges = new edu.cmu.tetrad.search.Fges(imagesScore);
-
-                    Graph combinedGraph = fges.search();
-
-                    System.out.println(combinedGraph.getNodes());
-
-//                    for (Node node : combinedGraph.getNodes()) {
-//                        node.setName(node.getName().toLowerCase());
-//                        if ("praf".equals(node.getName())) node.setName("raf");
-//                        if ("pmek".equals(node.getName())) node.setName("mek");
-//                        if ("plcg".equals(node.getName())) node.setName("plc");
-//                        if ("p44/42".equals(node.getName())) node.setName("erk");
-//                        if ("pakts473".equals(node.getName())) node.setName("akt");
-//                        if ("pjnk".equals(node.getName())) node.setName("jnk");
-//                    }
-
-                    combinedGraph = GraphUtils.replaceNodes(combinedGraph, groundTruth.getNodes());
-
-                    System.out.println(groundTruth);
-                    System.out.println(combinedGraph);
-
-                    System.out.println("AP = " + ap.getValue(groundTruth, combinedGraph));
-                    System.out.println("AR = " + ar.getValue(groundTruth, combinedGraph));
-                    System.out.println("AHP = " + ahp.getValue(groundTruth, combinedGraph));
-                    System.out.println("AHR = " + ahr.getValue(groundTruth, combinedGraph));
-
-                    for (Edge edge : combinedGraph.getEdges()) {
-                        if (!combinedGraph.containsEdge(edge)) combinedGraph.addEdge(edge);
-                    }
-
-                    String name = "combined";
-
-                    if (new File(algDir, name + ".png").exists()) {
-                        continue;
-                    }
-
-                    GraphUtils.circleLayout(combinedGraph, 200, 200, 175);
-
-                    GraphUtils.saveGraph(combinedGraph, new File(txtDir, name + ".txt"), false);
-
-                    PngWriter.writePng(combinedGraph, new File(pngDir, name + ".png"));
-                }
-            }
-        }
-    }
-
-    @Test
-    public void test6() {
-        File centeredLoggedFile = new File("/Users/user/Downloads/sachsgraphs/data/combined.centered.data/concat.main.result.logged.centered.txt");
-        File centeredFile = new File("/Users/user/Downloads/sachsgraphs/data/combined.centered.data/concat.main.result.centered.txt");
-
-        List<Algorithm> algorithms = new ArrayList<>();
-
-//        algorithms.add(new Fask(new edu.cmu.tetrad.algcomparison.score.BdeuScore()));
-        algorithms.add(new Pc(new edu.cmu.tetrad.algcomparison.independence.BDeuTest()));
-        algorithms.add(new Cpc(new edu.cmu.tetrad.algcomparison.independence.BDeuTest()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Fges(new BdeuScore()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Fci(new BDeuTest()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Gfci(new BDeuTest(), new BdeuScore()));
-//        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.FaskGfci(new BDeuTest()));
-
-        Parameters parameters = new Parameters();
-
-        boolean[] loggedArr = {true, false};
-
-        for (boolean logged : loggedArr) {
-
-            parameters.set("twoCycleAlpha", 1e-6);
-            parameters.set("presumePositiveCoefficients", true);
-
-            File commonDir = new File("/Users/user/Downloads/sachsgraphs/test/tetrad2/centeredcombined/discrete/" + (logged ? "logged" : "raw"));
-            commonDir.mkdirs();
-
-            for (Algorithm alg : algorithms) {
-                File algDir = new File(commonDir, alg.getDescription() + (logged ? ".logged" : ".raw"));
-                algDir.mkdirs();
-
-                File txtDir = new File(algDir, "txt");
-                txtDir.mkdirs();
-
-                File pngDir = new File(algDir, "png");
-                pngDir.mkdirs();
-
-                DataSet data1 = null;
-                try {
-                    DataReader reader = new DataReader();
-                    reader.setVariablesSupplied(true);
-                    reader.setDelimiter(DelimiterType.TAB);
-
-                    if (logged) {
-                        data1 = reader.parseTabular(centeredLoggedFile);
-                        data1 = DataUtils.discretize(data1, 3, false);
-                    } else {
-                        data1 = reader.parseTabular(centeredFile);
-                        data1 = DataUtils.discretize(data1, 3, false);
-                    }
-                } catch (IOException e) {
-                    e.printStackTrace();
-                }
-
-                Graph combinedGraph = alg.search(data1, parameters);
-
-                System.out.println(combinedGraph.getNodes());
-
-                for (Node node : combinedGraph.getNodes()) {
-                    node.setName(node.getName().toLowerCase());
-                    if ("praf".equals(node.getName())) node.setName("raf");
-                    if ("pmek".equals(node.getName())) node.setName("mek");
-                    if ("plcg".equals(node.getName())) node.setName("plc");
-                    if ("p44/42".equals(node.getName())) node.setName("erk");
-                    if ("pakts473".equals(node.getName())) node.setName("akt");
-                    if ("pjnk".equals(node.getName())) node.setName("jnk");
-                }
-
-                String name = "combined";
-
-                if (new File(algDir, name + ".png").exists()) {
-                    continue;
-                }
-
-                GraphUtils.circleLayout(combinedGraph, 200, 200, 175);
-
-                GraphUtils.saveGraph(combinedGraph, new File(txtDir, name + ".txt"), false);
-
-                PngWriter.writePng(combinedGraph, new File(pngDir, name + ".png"));
-
-                GraphUtils.circleLayout(combinedGraph, 200, 200, 175);
-                PngWriter.writePng(combinedGraph, new File(pngDir, name + ".png"));
-            }
-        }
-    }
-
-    @Test
-    public void test7() {
-        Parameters parameters = new Parameters();
-        parameters.set("penaltyDiscount", .5, 1, 2);
-        parameters.set("twoCycleAlpha", 1e-6);
-        parameters.set("alpha", 1e-4);
-        parameters.set("presumePositiveCoefficients", true);
-//        parameters.set("doNonparanormalTransform", true);
-
-
-        List<String> filenames = new ArrayList<>();
-
-//        filenames.add("raw.concatenated.txt");
-        filenames.add("raw.concatenated.log.plus0.0001.txt");
-//        filenames.add("raw.concatenated.log.plus10.txt");
-//        filenames.add("raw.concatenated.log.plus100.txt");
-//        filenames.add("raw.concatenated.log.plus300.txt");
-//        filenames.add("raw.concatenated.nonparanormal.txt");
-//        filenames.add("raw.log.plus0.0001.concatenated.txt");
-//        filenames.add("raw.log.plus10.concatenated.txt");
-//        filenames.add("raw.log.plus100.concatenated.txt");
-//        filenames.add("raw.raw.plus300.concatenated.txt");
-//        filenames.add("raw.centered.concatenated.txt");
-//        filenames.add("raw.standardized.concatenated.txt");
-//        filenames.add("raw.nonparanormal.concatenated.txt");
-
-
-        Statistics statistics = new Statistics();
-
-        statistics.add(new ParameterColumn("penaltyDiscount"));
-        statistics.add(new AdjacencyPrecision());
-        statistics.add(new AdjacencyRecall());
-        statistics.add(new ArrowheadPrecisionIgnore2c());
-        statistics.add(new ArrowheadRecall());
-        statistics.add(new AncestorPrecision());
-        statistics.add(new AncestorRecall());
-        statistics.add(new TwoCycleFalsePositive());
-        statistics.add(new TwoCycleFalseNegative());
-//        statistics.add(new MathewsCorrAdj());
-        statistics.add(new MathewsCorrArrow());
-//        statistics.add(new F1Adj());
-//        statistics.add(new F1Arrow());
-//        statistics.add(new SHD());
-//        statistics.add(new ElapsedTime());
-
-//        statistics.setWeight("AP", 1.0);
-//        statistics.setWeight("AR", 0.5);
-
-        File file = new File("/Users/user/Downloads/sachsgraphs/groundtruth/sachsgraph.txt");
-        Graph sachsGraph = GraphUtils.loadGraphTxt(file);
-
-        Algorithms algorithms = new Algorithms();
-
-        algorithms.add(new Fask(new edu.cmu.tetrad.algcomparison.score.SemBicScore()));
-        algorithms.add(new Pc(new edu.cmu.tetrad.algcomparison.independence.SemBicTest()));
-        algorithms.add(new Cpc(new edu.cmu.tetrad.algcomparison.independence.SemBicTest()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Fges(new SemBicScore()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Fci(new SemBicTest()));
-        algorithms.add(new edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Gfci(new SemBicTest(), new SemBicScore()));
-        algorithms.add(new SingleGraphAlg(sachsGraph));
-
-        Simulations simulations = new Simulations();
-
-        simulations.add(new LoadDataAndGraphsSachs(filenames.get(0)));
-
-        edu.cmu.tetrad.algcomparison.Comparison comparison = new edu.cmu.tetrad.algcomparison.Comparison();
-
-        comparison.setShowAlgorithmIndices(true);
-        comparison.setShowSimulationIndices(true);
-        comparison.setSortByUtility(false);
-        comparison.setShowUtilities(false);
-        comparison.setParallelized(true);
-        comparison.setSaveGraphs(true);
-        comparison.setComparisonGraph(Comparison.ComparisonGraph.true_DAG);
-
-//        comparison.setReplacePartialOrientedWithDirected(true);
-
-        comparison.compareFromSimulations("comparisonSachs", simulations, algorithms, statistics, parameters);
-    }
-
-    public class LoadDataAndGraphsSachs implements Simulation {
-        static final long serialVersionUID = 23L;
-        private final String dataFileName;
-        private List<Graph> graphs = new ArrayList<>();
-        private List<DataSet> dataSets = new ArrayList<>();
-        private List<String> usedParameters = new ArrayList<>();
-        private String description = "";
-
-        public LoadDataAndGraphsSachs(String dataFileName) {
-            this.dataFileName = dataFileName;
-        }
-
-        @Override
-        public void createData(Parameters parameters) {
-            this.dataSets = new ArrayList<>();
-
-            String datadir = "/Users/user/Downloads/sachsgraphs/sachs.data/prepared.concatenations";
-
-            List<String> paths = new ArrayList<>();
-
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/1. cd3cd28.txt");
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/2. cd3cd28icam2.txt");
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/3. cd3cd28+aktinhib.txt");
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/4. cd3cd28+g0076.txt");
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/5. cd3cd28+psitect.txt");
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/6. cd3cd28+u0126.txt");
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/7. cd3cd28+ly.txt");
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/8. pma.txt");
-//            paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/9. b2camp.txt");
-
-            File dir = new File("/Users/user/Downloads/sachs/data/Data Files/main.result/");
-
-//            File graphFile = new File("/Users/user/Downloads/sachsgraphs/groundtruth/biologist.view.txt");
-            File graphFile = new File("/Users/user/Downloads/sachsgraphs/groundtruth/ground.truth.txt");
-//            File graphFile = new File("/Users/user/Downloads/sachsgraphs/groundtruth/ground.truth.txt");
-//            File graphFile = new File("/Users/user/Downloads/sachsgraphs/groundtruth/som.figure.3.txt");
-//            File graphFile = new File("/Users/user/Downloads/sachsgraphs/groundtruth/modified.truth.txt");
-//        File file2 = new File("/Users/user/Downloads/sachs/graphs/biologist.view.txt");
-            Graph groundTruth = GraphUtils.loadGraphTxt(graphFile);
-
-
-            for (Node node : groundTruth.getNodes()) {
-                node.setName(node.getName().toLowerCase());
-                if ("plcg".equals(node.getName())) node.setName("plc");
-            }
-
-            groundTruth = GraphUtils.replaceNodes(groundTruth, groundTruth.getNodes());
-
-//            File[] filesArr = dir.listFiles();
-//            List<File> files = new ArrayList<>();
-//
-//            for (File file : filesArr) {
-//                if (!file.getName().startsWith(".")) {
-//                    files.add(file);
-//                }
-//            }
-
-
-//            List<DataSet> individualDataSets = new ArrayList<>();
-//
-//            for (int f = 0; f < files.size(); f++) {
-//                File file = new File(paths.get(f));
-//
-//                System.out.println(file.getName());
-//
-//                DataSet data1 = null;
-//
-//
-//                try {
-//                    DataReader reader = new DataReader();
-//                    reader.setVariablesSupplied(true);
-//                    reader.setDelimiter(DelimiterType.WHITESPACE);
-//                    data1 = reader.parseTabular(file);
-//
-//                    for (Node node : data1.getVariables()) {
-//                        node.setName(node.getName().toLowerCase());
-//                        if ("praf".equals(node.getName())) node.setName("raf");
-//                        if ("pmek".equals(node.getName())) node.setName("mek");
-//                        if ("plcg".equals(node.getName())) node.setName("plc");
-//                        if ("p44/42".equals(node.getName())) node.setName("erk");
-//                        if ("pakts473".equals(node.getName())) node.setName("akt");
-//                        if ("pjnk".equals(node.getName())) node.setName("jnk");
-//                    }
-//
-////                    data1 = DataUtils.center(data1);
-//
-////                    logData(data1, 300);
-//
-//                    data1 = DataUtils.getNonparanormalTransformed(data1);
-//
-////                    data1 = DataUtils.standardizeData(data1);
-//
-////                    data1 = removeExtremalValues(data1);
-//
-//                    individualDataSets.add(data1);
-//
-//                } catch (IOException e) {
-//                    e.printStackTrace();
-//                }
-//            }
-
-//            DataSet concatenate = DataUtils.concatenate(individualDataSets);
-
-//            logData(concatenate, 300);
-
-//            concatenate = DataUtils.getNonparanormalTransformed(concatenate);
-
-            DataSet concatenate;
-
-            try {
-                DataReader reader = new DataReader();
-                reader.setVariablesSupplied(true);
-                reader.setDelimiter(DelimiterType.WHITESPACE);
-                File file = new File(
-                        "/Users/user/Downloads/sachsgraphs/sachs.data/prepared.concatenations",
-                        dataFileName);
-                System.out.println(file.getAbsolutePath());
-
-                concatenate = reader.parseTabular(file);
-
-
-                for (Node node : concatenate.getVariables()) {
-                    node.setName(node.getName().toLowerCase());
-                    if ("praf".equals(node.getName())) node.setName("raf");
-                    if ("pmek".equals(node.getName())) node.setName("mek");
-                    if ("plcg".equals(node.getName())) node.setName("plc");
-                    if ("p44/42".equals(node.getName())) node.setName("erk");
-                    if ("pakts473".equals(node.getName())) node.setName("akt");
-                    if ("pjnk".equals(node.getName())) node.setName("jnk");
-                }
-
-                dataSets.add(concatenate);
-                graphs.add(groundTruth);
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-
-
-//            try {
-//                String datadir = "/Users/user/Downloads/sachsgraphs/sachs.data/prepared.concatenations.disable";
-//                File _datadir = new File(datadir);
-////                _datadir.mkdirs();
-//                String filename = "raw.nonparanormal.concatenated";
-//                PrintStream out = new PrintStream(new File(_datadir, filename));
-//                out.println(concatenate);
-//                out.close();
-//
-//            } catch (FileNotFoundException e) {
-//                e.printStackTrace();
-//            }
-
-        }
-
-
-        private DataSet removeExtremalValues(DataSet data1) {
-            double[][] data2 = data1.getDoubleData().transpose().toArray();
-            int[] keep = new int[data2[0].length];
-            Arrays.fill(keep, 1);
-
-            for (int j = 0; j < data2.length; j++) {
-                double[] col = data2[j];
-                double mean = mean(col);
-                double std = sd(col);
-
-                for (int i = 0; i < col.length; i++) {
-                    if (col[i] < mean - 3 * std || col[i] > mean + 3 * std) {
-                        keep[i] = 0;
-                    }
-                }
-            }
-
-            int sum = 0;
-            for (int i = 0; i < keep.length; i++) sum++;
-
-            int[] rows = new int[sum];
-            int t = 0;
-            for (int i = 0; i < keep.length; i++) {
-                rows[t++] = i;
-            }
-
-            data1 = data1.subsetRows(rows);
-            return data1;
-        }
-
-        @Override
-        public Graph getTrueGraph(int index) {
-            return graphs.get(index);
-        }
-
-        @Override
-        public DataModel getDataModel(int index) {
-            return dataSets.get(index);
-        }
-
-        @Override
-        public String getDescription() {
-            return "Load data sets and graphs from a directory" + (!("".equals(description)) ? ": " + description : "");
-
-//        try {
-//            File file = new File(path, "parameters.txt");
-//            BufferedReader r = new BufferedReader(new FileReader(file));
-//
-//            StringBuilder b = new StringBuilder();
-//            b.append("Load data sets and graphs from a directory.").append("\n\n");
-//            String line;
-//
-//            while ((line = r.readLine()) != null) {
-//                if (line.trim().isEmpty()) continue;
-//                b.append(line).append("\n");
-//            }
-//
-//            return b.toString();
-//        } catch (Exception e) {
-//            throw new RuntimeException(e);
-//        }
-        }
-
-        @Override
-        public List<String> getParameters() {
-            return usedParameters;
-        }
-
-        @Override
-        public int getNumDataModels() {
-            return dataSets.size();
-        }
-
-        @Override
-        public DataType getDataType() {
-            boolean continuous = false;
-            boolean discrete = false;
-            boolean mixed = false;
-
-            for (DataSet dataSet : dataSets) {
-                if (dataSet.isContinuous()) continuous = true;
-                if (dataSet.isDiscrete()) discrete = true;
-                if (dataSet.isMixed()) mixed = true;
-            }
-
-            if (mixed) return DataType.Mixed;
-            else if (continuous && discrete) return DataType.Mixed;
-            else if (continuous) return DataType.Continuous;
-            else if (discrete) return DataType.Discrete;
-
-            return DataType.Mixed;
-        }
-
-        public String getDataFileName() {
-            return dataFileName;
-        }
-    }
-
-    @Test
-    public void test8() {
-        List<String> paths = new ArrayList<>();
-
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/1. cd3cd28.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/2. cd3cd28icam2.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/3. cd3cd28+aktinhib.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/4. cd3cd28+g0076.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/5. cd3cd28+psitect.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/6. cd3cd28+u0126.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/7. cd3cd28+ly.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/8. pma.txt");
-        paths.add("/Users/user/Downloads/sachs/data/Data Files/txt/9. b2camp.txt");
-
-        String[] manipVars = {"cd3", "cd28", "icam2", "aktinhib", "g0076", "psitect", "u0126", "ly", "pma", "b2camp"};
-
-        String[][] manip = {
-                {"cd3", "cd28"},
-                {"cd3", "cd28", "icam2"},
-                {"cd3", "cd28", "aktinhib"},
-                {"cd3", "cd28", "g0076"},
-                {"cd3", "cd28", "psitect"},
-                {"cd3", "cd28", "u0126"},
-                {"cd3", "cd28", "ly"},
-                {"pma"},
-                {"cd3", "cd28", "b2camp"}
-        };
-
-        List<DataSet> allData = new ArrayList<>();
-
-        for (int f = 0; f < paths.size(); f++) {
-
-            File file = new File(paths.get(f));
-
-            System.out.println(file.getName());
-
-            DataSet data1;
-
-            try {
-                DataReader reader = new DataReader();
-                reader.setVariablesSupplied(true);
-                reader.setDelimiter(DelimiterType.WHITESPACE);
-                data1 = reader.parseTabular(file);
-
-                for (Node node : data1.getVariables()) {
-                    node.setName(node.getName().toLowerCase());
-                    if ("praf".equals(node.getName())) node.setName("raf");
-                    if ("pmek".equals(node.getName())) node.setName("mek");
-                    if ("plcg".equals(node.getName())) node.setName("plc");
-                    if ("p44/42".equals(node.getName())) node.setName("erk");
-                    if ("pakts473".equals(node.getName())) node.setName("akt");
-                    if ("pjnk".equals(node.getName())) node.setName("jnk");
-                }
-
-//                data1 = DataUtils.getNonparanormalTransformed(data1);
-                data1 = DataUtils.logData(data1, 10);
-
-                List<Node> allVars = new ArrayList<>();
-
-                allVars.addAll(data1.getVariables());
-
-                for (String var : manipVars) {
-                    allVars.add(new DiscreteVariable(var, 2));
-                }
-
-                DataSet data2 = new BoxDataSet(new DoubleDataBox(data1.getNumRows(), allVars.size()), allVars);
-
-                for (int i = 0; i < data1.getNumRows(); i++) {
-                    for (int j = 0; j < data1.getNumColumns(); j++) {
-                        data2.setDouble(i, j, data1.getDouble(i, j));
-                    }
-
-                    for (String s : manipVars) {
-                        int col = data2.getColumn(data2.getVariable(s));
-                        data2.setInt(i, col, 0);
-                    }
-
-                    for (String s : manip[f]) {
-                        int col = data2.getColumn(data2.getVariable(s));
-                        data2.setInt(i, col, 1);
-                    }
-                }
-
-                allData.add(data2);
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-
-
-        }
-
-        DataSet concatenate = DataUtils.concatenate(allData);
-
-        System.out.println(concatenate);
-
-        try {
-            String name = "data.with.discrete.latents.individually.log0";
-
-            String datadir = "/Users/user/Downloads/sachsgraphs/sachs.data/" + name;
-            File _datadir = new File(datadir);
-            _datadir.mkdirs();
-            PrintStream out = new PrintStream(new File(_datadir, name));
-            out.println(concatenate);
-            out.close();
-
-        } catch (FileNotFoundException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test9() {
-        try {
-            String dir = "/Users/user/Documents/MATLAB";
-
-            List<Node> nodes = new ArrayList<>();
-
-            String[] nodeNames = {"raf", "mek", "plc", "pip2", "pip3", "erk", "akt", "pka", "pkc", "p38", "jnk"};
-
-            int[][] pos = {
-                    {345, 120},
-                    {360, 210},
-                    {45, 180},
-                    {60, 380},
-                    {120, 300},
-                    {345, 285},
-                    {285, 360},
-                    {105, 105},
-                    {240, 30},
-                    {200, 270},
-                    {120, 210}
-            };
-
-            for (int i = 0; i < 11; i++) {
-                ContinuousVariable node = new ContinuousVariable(nodeNames[i]);
-                node.setCenter(pos[i][0], pos[i][1]);
-                nodes.add(node);
-            }
-
-            for (int index = 1; index <= 9; index++) {
-                Graph g = new EdgeListGraph(nodes);
-
-                File file = new File(dir, "sachs.new.B" + index + ".txt");
-
-                DataReader reader = new DataReader();
-                reader.setVariablesSupplied(false);
-                reader.setDelimiter(DelimiterType.COMMA);
-
-                DataSet dataSet = reader.parseTabular(file);
-
-                for (int j = 0; j < 11; j++) {
-                    for (int i = 0; i < 11; i++) {
-                        if (abs(dataSet.getDouble(i, j)) > 0.00) {
-                            g.addDirectedEdge(nodes.get(j), nodes.get(i));
-                        }
-                    }
-                }
-
-//                GraphUtils.circleLayout(g, 200, 200, 175);
-
-                final File dir1 = new File("/Users/user/Downloads/sachsgraphs/twostepindividual3");
-                dir1.mkdirs();
-
-                GraphUtils.saveGraph(g, new File(dir1, "A" + index + ".txt"), false);
-
-                PngWriter.writePng(g, new File(dir1, "A" + index + ".png"));
-
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-
-    }
-
-    @Test
-    public void test10() {
-        List<String> paths = new ArrayList<>();
-
-        final String dir0 = "/Users/user/Downloads/sachsgraphs/sachs.data";
-        final String dir = dir0 + "/main.result";
-
-        paths.add("1. cd3cd28.txt");
-        paths.add("2. cd3cd28icam2.txt");
-        paths.add("3. cd3cd28+aktinhib.txt");
-        paths.add("4. cd3cd28+g0076.txt");
-        paths.add("5. cd3cd28+psitect.txt");
-        paths.add("6. cd3cd28+u0126.txt");
-        paths.add("7. cd3cd28+ly.txt");
-        paths.add("8. pma.txt");
-        paths.add("9. b2camp.txt");
-
-        try {
-            for (String path : paths) {
-
-                DataReader reader = new DataReader();
-                reader.setVariablesSupplied(true);
-                reader.setDelimiter(DelimiterType.TAB);
-                DataSet data = reader.parseTabular(new File(dir, path));
-
-                data = DataUtils.logData(data, 1);
-
-//                data = DataUtils.center(data);
-
-                File dir2 = new File(dir0 + "/logged1");
-                dir2.mkdirs();
-
-                final File file = new File(dir2, path);
-                System.out.println(file.getAbsolutePath());
-                DataWriter.writeRectangularData(data, new FileWriter(file), '\t');
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-
-
-    }
-
-    @Test
-    public void testMakeALittleTable() {
-//        final String trueName = "ground.truth.sachs.txt";
-        final String trueName = "supplemented.ground.truth.txt";
-
-        System.out.println("Comparing to " + trueName);
-
-        final File dir = new File("/Users/user/Downloads/files.for.fask.sachs.report/txt");
-        Graph trueGraph = GraphUtils.loadGraphTxt(new File(dir, trueName));
-
-        List<Statistic> statistics = new ArrayList<>();
-
-        String[] estNames = new String[]{
-                "sachs.model.txt",
-                "figure7.txt",
-                "figure11.txt",
-                "glasso.txt",
-                "aragam.continuous.txt",
-                "aragam.discrete.txt",
-                "henao.txt",
-                "miller.txt",
-                "desgranges.txt",
-                "mooij.txt",
-                "cgnn.txt",
-                "sam.txt"
-        };
-
-        statistics.add(new AdjacencyPrecision());
-        statistics.add(new AdjacencyRecall());
-        statistics.add(new ArrowheadPrecisionIgnore2c());
-        statistics.add(new ArrowheadRecall());
-
-        for (String estName : estNames) {
-            Graph estGraph = GraphUtils.loadGraphTxt(new File(dir, estName));
-            estGraph = GraphUtils.replaceNodes(estGraph, trueGraph.getNodes());
-
-            double adjFp = statistics.get(0).getValue(trueGraph, estGraph);
-            double adjFn = statistics.get(1).getValue(trueGraph, estGraph);
-            double ahTp = statistics.get(2).getValue(trueGraph, estGraph);
-            double ahFp = statistics.get(3).getValue(trueGraph, estGraph);
-
-            System.out.println(estName + "\t" + adjFp + "\t" + adjFn + "\t" + ahTp + "\t" + ahFp);
-
-        }
-
-    }
-}
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/study/imme/TestImme.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/study/imme/TestImme.java
deleted file mode 100644
index 76aab793..00000000
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/study/imme/TestImme.java
+++ /dev/null
@@ -1,174 +0,0 @@
-package edu.cmu.tetradapp.study.imme;
-
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-import edu.cmu.tetrad.data.CovarianceMatrix;
-import edu.cmu.tetrad.data.DataSet;
-import edu.cmu.tetrad.data.DataUtils;
-import edu.cmu.tetrad.data.DataWriter;
-import edu.cmu.tetrad.graph.Edge;
-import edu.cmu.tetrad.graph.EdgeListGraph;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.search.Score;
-import edu.cmu.tetrad.search.SemBicScore;
-import edu.cmu.tetrad.util.DataConvertUtils;
-import edu.cmu.tetradapp.workbench.GraphWorkbench;
-import edu.pitt.dbmi.data.Dataset;
-import edu.pitt.dbmi.data.Delimiter;
-import edu.pitt.dbmi.data.reader.tabular.ContinuousTabularDataFileReader;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import javax.imageio.ImageIO;
-import javax.swing.*;
-import java.awt.*;
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.util.ArrayList;
-
-
-/**
- * @author Joseph Ramsey
- */
-@Ignore
-public class TestImme {
-
-    @Test
-    public void test1() {
-        try {
-            File dir = new File("/Users/user/Box Sync/data/imme/");
-            DataSet data = readInContinuousData(dir, "ADV_AND_DIFF_CIRCULAR_30_65_TIME_SERIES_DATA.txt");
-//            DataSet data = readInContinuousData(dir, "ADV_AND_DIFF_CIRCULAR_30_65_TIME_SERIES_DATA.nonparanormal.txt");
-
-            int priorN = data.getNumRows();
-            int newN = 8000;
-            int offset2 = 4000;
-
-            int[] rows = new int[newN];
-            for (int i = 0; i < newN; i++) rows[i] = offset2 + i - 1;
-
-//            data = data.subsetRows(rows);
-
-            System.out.println("rows = " + data.getNumRows() + " columns = " + data.getNumColumns());
-
-
-            DataSet grid = readInContinuousData(dir, "ADV_AND_DIFF_CIRCULAR_30_65_Grid_1.txt");
-
-            Score score = new SemBicScore(new CovarianceMatrix(data));
-
-            edu.cmu.tetrad.search.Fask fask = new edu.cmu.tetrad.search.Fask(data, score);
-            fask.setPenaltyDiscount(20);
-            fask.setDepth(3);
-            fask.setAlpha(.001);
-            fask.setDelta(-1);
-            fask.setExtraEdgeThreshold(9.0);
-            Graph graph = fask.search();
-
-//            final EdgeListGraph graph = new EdgeListGraph();
-
-            int scale = 15;
-            int offset = 50;
-
-            java.util.List<Node> nodes = graph.getNodes();
-
-            for (int i = 0; i < 400; i++) {
-                final Node node = nodes.get(i);
-                final int x = offset + scale * grid.getInt(i, 0);
-                final int y = offset + scale * grid.getInt(i, 1);
-                node.setCenter(x, y);
-            }
-
-            writePng(graph, new File(dir, "outgraph.png"));
-
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public static DataSet readInContinuousData(File dir, String s) throws IOException {
-        Dataset dataset1 = new ContinuousTabularDataFileReader(new File(dir, s), Delimiter.WHITESPACE).readInData();
-        return (DataSet) DataConvertUtils.toDataModel(dataset1);
-    }
-
-    public static void main(String... args) {
-        new TestImme().test1();
-        ;
-    }
-
-    public void writePng(Graph graph, File file) {
-//        circleLayout(graph, 200, 200, 175);
-
-        JPanel panel = new JPanel();
-        panel.setLayout(new BorderLayout());
-
-        // Remove self-loops.
-        graph = new EdgeListGraph(graph);
-
-        for (Node node : graph.getNodes()) {
-            for (Edge edge : new ArrayList<>(graph.getEdges(node, node))) {
-                graph.removeEdge(edge);
-            }
-        }
-
-        final GraphWorkbench workbench = new GraphWorkbench(graph);
-
-        int maxx = 0;
-        int maxy = 0;
-
-        for (Node node : graph.getNodes()) {
-            if (node.getCenterX() > maxx) {
-                maxx = node.getCenterX();
-            }
-
-            if (node.getCenterY() > maxy) {
-                maxy = node.getCenterY();
-            }
-        }
-
-        workbench.setSize(new Dimension(maxx + 50, maxy + 50));
-        panel.add(workbench, BorderLayout.CENTER);
-
-        JDialog dialog = new JDialog();
-        dialog.add(workbench);
-        dialog.pack();
-
-        Dimension size = workbench.getSize();
-        BufferedImage image = new BufferedImage(size.width, size.height,
-                BufferedImage.TYPE_BYTE_INDEXED);
-        Graphics2D graphics = image.createGraphics();
-        workbench.paint(graphics);
-        image.flush();
-
-        // Write the image to resultFile.
-        try {
-            ImageIO.write(image, "PNG", file);
-        } catch (IOException e1) {
-            throw new RuntimeException("Could not write to " + file, e1);
-        }
-    }
-}
-
-
-
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/ui/model/AlgorithmModel.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/ui/model/AlgorithmModel.java
index a4d29e39..f3f67f35 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/ui/model/AlgorithmModel.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/ui/model/AlgorithmModel.java
@@ -22,7 +22,6 @@ import edu.cmu.tetrad.algcomparison.utils.TakesIndependenceWrapper;
 import edu.cmu.tetrad.algcomparison.utils.UsesScoreWrapper;
 import edu.cmu.tetrad.annotation.Algorithm;
 import edu.cmu.tetrad.annotation.AnnotatedClass;
-import edu.cmu.tetrad.util.AlgorithmDescriptions;
 import java.io.Serializable;
 
 /**
@@ -38,7 +37,6 @@ public class AlgorithmModel implements Serializable, Comparable<AlgorithmModel>
     private final AnnotatedClass<Algorithm> algorithm;
     private final boolean requiredScore;
     private final boolean requiredTest;
-    private final String description;
 
     public AlgorithmModel(AnnotatedClass<Algorithm> algorithm) {
         if (algorithm == null) {
@@ -48,7 +46,6 @@ public class AlgorithmModel implements Serializable, Comparable<AlgorithmModel>
         this.algorithm = algorithm;
         this.requiredScore = UsesScoreWrapper.class.isAssignableFrom(algorithm.getClazz());
         this.requiredTest = TakesIndependenceWrapper.class.isAssignableFrom(algorithm.getClazz());
-        this.description = AlgorithmDescriptions.getInstance().get(algorithm.getAnnotation().command());
     }
 
     @Override
@@ -73,8 +70,4 @@ public class AlgorithmModel implements Serializable, Comparable<AlgorithmModel>
         return requiredTest;
     }
 
-    public String getDescription() {
-        return description;
-    }
-
 }
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/workbench/AbstractWorkbench.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/workbench/AbstractWorkbench.java
index c98d70b7..2a701649 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/workbench/AbstractWorkbench.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/workbench/AbstractWorkbench.java
@@ -64,7 +64,9 @@ import java.util.Set;
 import java.util.prefs.Preferences;
 import javax.swing.AbstractAction;
 import javax.swing.Action;
+import javax.swing.BorderFactory;
 import javax.swing.JComponent;
+import javax.swing.JLabel;
 import javax.swing.JOptionPane;
 import javax.swing.JPopupMenu;
 import javax.swing.KeyStroke;
@@ -575,16 +577,16 @@ public abstract class AbstractWorkbench extends JComponent implements WorkbenchM
 	 */
 	public final void setEdgeLabel(Edge modelEdge, JComponent label) {
 		if (modelEdge == null) {
-		    throw new NullPointerException("Attempt to set a label on a " + "null model edge: " + modelEdge);
+			throw new NullPointerException("Attempt to set a label on a " + "null model edge: " + modelEdge);
 		} else if (!getModelEdgesToDisplay().containsKey(modelEdge)) {
-		    throw new IllegalArgumentException("Attempt to set a label on " + "a model edge that's not " + "in the editor: " + modelEdge);
+			throw new IllegalArgumentException(
+					"Attempt to set a label on " + "a model edge that's not " + "in the editor: " + modelEdge);
 		}
 
 		// retrieve display edge from map, or create one if not
 		// there...
 		DisplayEdge displayEdge = (DisplayEdge) getModelEdgesToDisplay().get(modelEdge);
-                
-                GraphEdgeLabel oldLabel = getEdgeLabel(displayEdge);
+		GraphEdgeLabel oldLabel = getEdgeLabel(displayEdge);
 
 		if (oldLabel != null) {
 			remove(oldLabel);
@@ -601,24 +603,6 @@ public abstract class AbstractWorkbench extends JComponent implements WorkbenchM
 		repaint();
 	}
 
-        /**
-         * Edge tooltip to show the edge type and probabilities - Added by Zhou
-         * 
-         * @param modelEdge
-         * @param toolTipText 
-         */
-        public final void setEdgeToolTip(Edge modelEdge, String toolTipText) {
-		if (modelEdge == null) {
-		    throw new NullPointerException("Attempt to set a label on a " + "null model edge: " + modelEdge);
-		} else if (!getModelEdgesToDisplay().containsKey(modelEdge)) {
-		    throw new IllegalArgumentException("Attempt to set a label on " + "a model edge that's not " + "in the editor: " + modelEdge);
-		}
-
-		DisplayEdge displayEdge = (DisplayEdge) getModelEdgesToDisplay().get(modelEdge);
-
-                displayEdge.setToolTipText(toolTipText);
-	}
-        
 	/**
 	 * Sets the label for a node to a particular JComponent. The label will be
 	 * displayed slightly off to the right of the node.
@@ -2130,19 +2114,17 @@ public abstract class AbstractWorkbench extends JComponent implements WorkbenchM
 						case "Star" : endpoint1 = "&#42;"; break;
 						case "Null" : endpoint1 = "Null"; break;
 					}
-                                        
 					String endpoint2 = edge.getEndpoint2().toString();
 					switch(endpoint2){
-                                            case "Tail" : endpoint2 = "-"; break;
-                                            case "Arrow" : endpoint2 = "&gt;"; break;
-                                            case "Circle" : endpoint2 = "o"; break;
-                                            case "Star" : endpoint2 = "&#42;"; break;
-                                            case "Null" : endpoint2 = "Null"; break;
-                                        }
-                                        
-					String text = "<html>" + edge.getNode1().getName() + 
+					case "Tail" : endpoint2 = "-"; break;
+					case "Arrow" : endpoint2 = "&gt;"; break;
+					case "Circle" : endpoint2 = "o"; break;
+					case "Star" : endpoint2 = "&#42;"; break;
+					case "Null" : endpoint2 = "Null"; break;
+				}
+					String text = "<html><b>" + edge.getNode1().getName() + 
 							" " + endpoint1 + "-" + endpoint2 + " " + 
-							edge.getNode2().getName() + "<br>";
+							edge.getNode2().getName() + "</b><br>";
 					String n1 = edge.getNode1().getName();
 					String n2 = edge.getNode2().getName();
 					List<String> nodes = new ArrayList<>();
@@ -2191,36 +2173,30 @@ public abstract class AbstractWorkbench extends JComponent implements WorkbenchM
 							text += "<br>";
 						}
 					}
+					JLabel edgeTypeDistLabel = new JLabel(text);
+					edgeTypeDistLabel.setOpaque(true);
+					edgeTypeDistLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
+					setEdgeLabel(edge, edgeTypeDistLabel);
 
-                                        // Commented out by Zhou
-//					JLabel edgeTypeDistLabel = new JLabel(text);
-//					edgeTypeDistLabel.setOpaque(true);
-//					edgeTypeDistLabel.setBorder(BorderFactory.createLineBorder(Color.BLACK));
-//					setEdgeLabel(edge, edgeTypeDistLabel);
-
-                                        // Use tooltip instead of label - Added by Zhou
-                                        setEdgeToolTip(edge, text);
 				}
 			}
 		}
 	}
 
-        // SInce we use tooltip to show edge type and probablitites, 
-        // we no longer need this call. - Commented out by Zhou
-//	private void handleMouseExited(MouseEvent e) {
-//		Object source = e.getSource();
-//
-//		if (source instanceof DisplayEdge) {
-//			IDisplayEdge displayEdge = (IDisplayEdge) source;
-//			Edge edge = displayEdge.getModelEdge();
-//			if (graph.containsEdge(edge)) {
-//				List<EdgeTypeProbability> edgeProb = edge.getEdgeTypeProbabilities();
-//				if (edgeProb != null) {
-//					setEdgeLabel(edge, null);
-//				}
-//			}
-//		}
-//	}
+	private void handleMouseExited(MouseEvent e) {
+		Object source = e.getSource();
+
+		if (source instanceof DisplayEdge) {
+			IDisplayEdge displayEdge = (IDisplayEdge) source;
+			Edge edge = displayEdge.getModelEdge();
+			if (graph.containsEdge(edge)) {
+				List<EdgeTypeProbability> edgeProb = edge.getEdgeTypeProbabilities();
+				if (edgeProb != null) {
+					setEdgeLabel(edge, null);
+				}
+			}
+		}
+	}
 
 	private void snapSingleNodeFromNegative(Object source) {
 		DisplayNode node = (DisplayNode) source;
@@ -2746,8 +2722,7 @@ public abstract class AbstractWorkbench extends JComponent implements WorkbenchM
 		}
 
 		public final void mouseExited(MouseEvent e) {
-                    // Commented out by Zhou
-			//workbench.handleMouseExited(e);
+			workbench.handleMouseExited(e);
 		}
 	}
 
diff --git a/tetrad-gui/src/main/java/edu/cmu/tetradapp/workbench/PngWriter.java b/tetrad-gui/src/main/java/edu/cmu/tetradapp/workbench/PngWriter.java
index 674be304..37268c57 100644
--- a/tetrad-gui/src/main/java/edu/cmu/tetradapp/workbench/PngWriter.java
+++ b/tetrad-gui/src/main/java/edu/cmu/tetradapp/workbench/PngWriter.java
@@ -35,9 +35,9 @@ import java.io.IOException;
 import java.util.ArrayList;
 
 /**
- * Writes PNG files. Uses the given layout.
+ * Writes PNG files.
  */
-public class PngWriter {
+class PngWriter {
     public static void writePng(Graph graph, File file) {
 //        circleLayout(graph, 200, 200, 175);
 
diff --git a/tetrad-gui/src/main/resources/config/devConfig.xml b/tetrad-gui/src/main/resources/config/devConfig.xml
index 7fcb8b03..1fdb53af 100644
--- a/tetrad-gui/src/main/resources/config/devConfig.xml
+++ b/tetrad-gui/src/main/resources/config/devConfig.xml
@@ -413,7 +413,7 @@
             <!--</model-class>-->
             <!--<editor-class>edu.cmu.tetradapp.editor.DataEditor</editor-class>-->
             <!--</model>-->
-            <model name="Collect Data Sets In One Box" acronym="Collect Data Sets In One Box"
+            <model name="Merge Datasets" acronym="Merge Datasets"
                    help="mergedatasets" category="Manipulation of Data">
                 <logger>
                     <event id="info" description="Information" default="on"/>
@@ -520,7 +520,7 @@
                     edu.cmu.tetradapp.editor.datamanip.TimeSeriesParamsEditor
                 </params-editor-class>
             </model>
-            <model name="Add an index variable" acronym="Add Index"
+            <model name="Convert to Time Lag Data with Index" acronym="Time Lag w Index"
                    help="data" category="Conversion of Data">
                 <logger>
                     <event id="info" description="Information" default="on"/>
@@ -529,9 +529,9 @@
                 <model-class>edu.cmu.tetradapp.model.datamanip.TimeSeriesWrapper2
                 </model-class>
                 <editor-class>edu.cmu.tetradapp.editor.DataEditor</editor-class>
-                <!--<params-editor-class>-->
-                <!--edu.cmu.tetradapp.editor.datamanip.TimeSeriesParamsEditor-->
-                <!--</params-editor-class>-->
+                <params-editor-class>
+                    edu.cmu.tetradapp.editor.datamanip.TimeSeriesParamsEditor
+                </params-editor-class>
             </model>
             <model name="Convert to AR residuals" acronym="AR Residuals"
                    help="data" category="Conversion of Data">
@@ -1519,16 +1519,16 @@
 
             <!--Restored Mimbuild on 6/20/2017 -->          
             <model name="MIMBuild" acronym="MIMBuild" help="mimbuild"
-                   category="Multiple Indicator Model searches">
-                <logger>
-                    <event id="info" description="Information" default="on"/>
-                    <event id="details" description="Misc Fine Details" default="on"/>
-                    <event id="maxmodel" description="Max P Value Model" default="on"/>
-                </logger>
-                <model-class>edu.cmu.tetradapp.model.MimBuildRunner
-                </model-class>
-                <editor-class>edu.cmu.tetradapp.editor.MimbuildEditor
-                </editor-class>
+            category="Multiple Indicator Model searches">
+            <logger>
+            <event id="info" description="Information" default="on"/>
+            <event id="details" description="Misc Fine Details" default="on"/>
+            <event id="maxmodel" description="Max P Value Model" default="on"/>
+            </logger>
+            <model-class>edu.cmu.tetradapp.model.MimBuildRunner
+            </model-class>
+            <editor-class>edu.cmu.tetradapp.editor.MimbuildEditor
+            </editor-class>
             </model>
 
             <!--<model name="MIMTrekBuild" acronym="MIMTrekBuild" help="mimbuild"-->
diff --git a/tetrad-gui/src/main/resources/config/prodConfig.xml b/tetrad-gui/src/main/resources/config/prodConfig.xml
index 7fcb8b03..1fdb53af 100644
--- a/tetrad-gui/src/main/resources/config/prodConfig.xml
+++ b/tetrad-gui/src/main/resources/config/prodConfig.xml
@@ -413,7 +413,7 @@
             <!--</model-class>-->
             <!--<editor-class>edu.cmu.tetradapp.editor.DataEditor</editor-class>-->
             <!--</model>-->
-            <model name="Collect Data Sets In One Box" acronym="Collect Data Sets In One Box"
+            <model name="Merge Datasets" acronym="Merge Datasets"
                    help="mergedatasets" category="Manipulation of Data">
                 <logger>
                     <event id="info" description="Information" default="on"/>
@@ -520,7 +520,7 @@
                     edu.cmu.tetradapp.editor.datamanip.TimeSeriesParamsEditor
                 </params-editor-class>
             </model>
-            <model name="Add an index variable" acronym="Add Index"
+            <model name="Convert to Time Lag Data with Index" acronym="Time Lag w Index"
                    help="data" category="Conversion of Data">
                 <logger>
                     <event id="info" description="Information" default="on"/>
@@ -529,9 +529,9 @@
                 <model-class>edu.cmu.tetradapp.model.datamanip.TimeSeriesWrapper2
                 </model-class>
                 <editor-class>edu.cmu.tetradapp.editor.DataEditor</editor-class>
-                <!--<params-editor-class>-->
-                <!--edu.cmu.tetradapp.editor.datamanip.TimeSeriesParamsEditor-->
-                <!--</params-editor-class>-->
+                <params-editor-class>
+                    edu.cmu.tetradapp.editor.datamanip.TimeSeriesParamsEditor
+                </params-editor-class>
             </model>
             <model name="Convert to AR residuals" acronym="AR Residuals"
                    help="data" category="Conversion of Data">
@@ -1519,16 +1519,16 @@
 
             <!--Restored Mimbuild on 6/20/2017 -->          
             <model name="MIMBuild" acronym="MIMBuild" help="mimbuild"
-                   category="Multiple Indicator Model searches">
-                <logger>
-                    <event id="info" description="Information" default="on"/>
-                    <event id="details" description="Misc Fine Details" default="on"/>
-                    <event id="maxmodel" description="Max P Value Model" default="on"/>
-                </logger>
-                <model-class>edu.cmu.tetradapp.model.MimBuildRunner
-                </model-class>
-                <editor-class>edu.cmu.tetradapp.editor.MimbuildEditor
-                </editor-class>
+            category="Multiple Indicator Model searches">
+            <logger>
+            <event id="info" description="Information" default="on"/>
+            <event id="details" description="Misc Fine Details" default="on"/>
+            <event id="maxmodel" description="Max P Value Model" default="on"/>
+            </logger>
+            <model-class>edu.cmu.tetradapp.model.MimBuildRunner
+            </model-class>
+            <editor-class>edu.cmu.tetradapp.editor.MimbuildEditor
+            </editor-class>
             </model>
 
             <!--<model name="MIMTrekBuild" acronym="MIMTrekBuild" help="mimbuild"-->
diff --git a/tetrad-gui/src/main/resources/resources/javahelp/manual/images/tetrad_menu1.html b/tetrad-gui/src/main/resources/resources/javahelp/manual/images/tetrad_menu1.html
index 79dc9b1a..8e2e4260 100644
Binary files a/tetrad-gui/src/main/resources/resources/javahelp/manual/images/tetrad_menu1.html and b/tetrad-gui/src/main/resources/resources/javahelp/manual/images/tetrad_menu1.html differ
diff --git a/tetrad-gui/src/main/resources/resources/javahelp/manual/tetrad_tutorial.html b/tetrad-gui/src/main/resources/resources/javahelp/manual/tetrad_tutorial.html
index e7ee90fb..78966c98 100644
--- a/tetrad-gui/src/main/resources/resources/javahelp/manual/tetrad_tutorial.html
+++ b/tetrad-gui/src/main/resources/resources/javahelp/manual/tetrad_tutorial.html
@@ -661,7 +661,7 @@ sup {
 <li>Other settings, like tuning parameters, which depend on the specific algorithm</li>
 </ul>
 
-<p>The output is a graph, or a set of graphs that are equally compatible with the data (a.perm.a. an &quot;equivalence class&quot; of graphs). The type of graph you get depends on the type of algorithm you use.</p>
+<p>The output is a graph, or a set of graphs that are equally compatible with the data (a.k.a. an &quot;equivalence class&quot; of graphs). The type of graph you get depends on the type of algorithm you use.</p>
 
 <h4 id="toc_10">Example</h4>
 
diff --git a/tetrad-lib/pom.xml b/tetrad-lib/pom.xml
index 4734fa20..4c1fc072 100644
--- a/tetrad-lib/pom.xml
+++ b/tetrad-lib/pom.xml
@@ -6,7 +6,7 @@
     <parent>
         <groupId>edu.cmu</groupId>
         <artifactId>tetrad</artifactId>
-        <version>6.5.0-SNAPSHOT</version>
+        <version>6.4.0-SNAPSHOT</version>
     </parent>
 
     <artifactId>tetrad-lib</artifactId>
@@ -22,27 +22,33 @@
                     <target>1.8</target>
                 </configuration>
             </plugin>
-
             <plugin>
-                <artifactId>maven-antrun-plugin</artifactId>
-                <version>1.8</version>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-shade-plugin</artifactId>
+                <version>3.1.0</version>
                 <executions>
                     <execution>
-                        <phase>compile</phase>
+                        <phase>package</phase>
                         <goals>
-                            <goal>run</goal>
+                            <goal>shade</goal>
                         </goals>
                         <configuration>
-                            <target>
-                                <copy file="../docs/manual/index.html"
-                                      tofile="${project.build.outputDirectory}/manual/index.html"/>
-                            </target>
+                            <transformers>
+                                <transformer
+                                    implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
+                                    <manifestEntries>
+                                        <Main-Class>edu.cmu.tetrad.cmd.TetradCmd</Main-Class>
+                                        <Permissions>all-permissions</Permissions>
+                                    </manifestEntries>
+                                </transformer>
+                            </transformers>
+                            <minimizeJar>true</minimizeJar>
+                            <shadedArtifactAttached>true</shadedArtifactAttached>
+                            <shadedClassifierName>tetradcmd</shadedClassifierName> <!-- Any name that makes sense -->
                         </configuration>
                     </execution>
                 </executions>
             </plugin>
-
-
             <!--<plugin> -->
             <!--<groupId>org.apache.maven.plugins</groupId> -->
             <!--<artifactId>maven-gpg-plugin</artifactId> -->
@@ -147,13 +153,6 @@
             <version>2.3.0</version>
         </dependency>
 
-        <!-- For parsing Tetrad single-page HTML manual to get algorithm descriptions -->
-        <dependency>
-            <groupId>org.jsoup</groupId>
-            <artifactId>jsoup</artifactId>
-            <version>1.11.2</version>
-        </dependency>
-
     </dependencies>
 
     <!--<distributionManagement> -->
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/Comparison.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/Comparison.java
index cadff6a6..f5ae9fe1 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/Comparison.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/Comparison.java
@@ -25,7 +25,6 @@ import edu.cmu.tetrad.algcomparison.algorithm.Algorithm;
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
 import edu.cmu.tetrad.algcomparison.algorithm.ExternalAlgorithm;
 import edu.cmu.tetrad.algcomparison.algorithm.MultiDataSetAlgorithm;
-import edu.cmu.tetrad.algcomparison.algorithm.multi.PassesInGraph;
 import edu.cmu.tetrad.algcomparison.independence.FisherZ;
 import edu.cmu.tetrad.algcomparison.independence.IndependenceWrapper;
 import edu.cmu.tetrad.algcomparison.score.BdeuScore;
@@ -47,7 +46,6 @@ import edu.cmu.tetrad.search.DagToPag;
 import edu.cmu.tetrad.search.DagToPag2;
 import edu.cmu.tetrad.search.SearchGraphUtils;
 import edu.cmu.tetrad.util.*;
-import edu.pitt.dbmi.data.reader.DataReader;
 import org.reflections.Reflections;
 
 import java.io.*;
@@ -67,9 +65,7 @@ import java.util.concurrent.RecursiveTask;
 public class Comparison {
 
 
-    public enum ComparisonGraph {
-        true_DAG, Pattern_of_the_true_DAG, PAG_of_the_true_DAG
-    }
+        public enum ComparisonGraph {true_DAG, Pattern_of_the_true_DAG, PAG_of_the_true_DAG}
 
     private boolean[] graphTypeUsed;
     private PrintStream out;
@@ -87,8 +83,6 @@ public class Comparison {
     private boolean savePags = false;
     private ArrayList<String> dirs = null;
     private ComparisonGraph comparisonGraph = ComparisonGraph.true_DAG;
-    private boolean replacePartialOrientedWithDirected = false;
-
 
     public void compareFromFiles(String filePath, Algorithms algorithms,
                                  Statistics statistics, Parameters parameters) {
@@ -1070,9 +1064,6 @@ public class Comparison {
         this.comparisonGraph = comparisonGraph;
     }
 
-    public void setReplacePartialOrientedWithDirected(boolean replacePartialOrientedWithDirected) {
-        this.replacePartialOrientedWithDirected = replacePartialOrientedWithDirected;
-    }
 
     private class AlgorithmTask extends RecursiveTask<Boolean> {
         private List<AlgorithmSimulationWrapper> algorithmSimulationWrappers;
@@ -1182,7 +1173,6 @@ public class Comparison {
             }
 
             if (algorithm instanceof MultiDataSetAlgorithm) {
-
                 List<Integer> indices = new ArrayList<>();
                 int numDataModels = simulationWrapper.getSimulation().getNumDataModels();
                 for (int i = 0; i < numDataModels; i++) indices.add(i);
@@ -1196,12 +1186,7 @@ public class Comparison {
                 }
 
                 Parameters _params = algorithmWrapper.getAlgorithmSpecificParameters();
-
-                if (algorithm instanceof PassesInGraph) {
-                    out = ((PassesInGraph) algorithm).search(dataModels, _params, simulation.getTrueGraph(0));
-                } else {
-                    out = ((MultiDataSetAlgorithm) algorithm).search(dataModels, _params);
-                }
+                out = ((MultiDataSetAlgorithm) algorithm).search(dataModels, _params);
             } else {
                 DataModel dataModel = copyData ? data.copy() : data;
                 Parameters _params = algorithmWrapper.getAlgorithmSpecificParameters();
@@ -1213,11 +1198,6 @@ public class Comparison {
             return;
         }
 
-
-        if (replacePartialOrientedWithDirected) {
-            out = replaceHalfDirectedWithDirected(out);
-        }
-
         int simIndex = simulationWrappers.indexOf(simulationWrapper) + 1;
         int algIndex = algorithmWrappers.indexOf(algorithmWrapper) + 1;
 
@@ -1304,26 +1284,6 @@ public class Comparison {
         }
     }
 
-    private Graph replaceHalfDirectedWithDirected(Graph graph) {
-        EdgeListGraph graph2 = new EdgeListGraph(graph);
-
-        for (Edge edge : graph2.getEdges()) {
-            if (Edges.isPartiallyOrientedEdge(edge)) {
-                graph2.removeEdge(edge);
-
-                if (edge.pointsTowards(edge.getNode1())) {
-                    graph2.addDirectedEdge(edge.getNode2(), edge.getNode1());
-                }
-
-                if (edge.pointsTowards(edge.getNode2())) {
-                    graph2.addDirectedEdge(edge.getNode1(), edge.getNode2());
-                }
-            }
-        }
-
-        return graph2;
-    }
-
     private void saveGraph(String resultsPath, Graph graph, int i, int simIndex, int algIndex,
                            AlgorithmWrapper algorithmWrapper, long elapsed) {
         if (!saveGraphs) {
@@ -1760,8 +1720,8 @@ public class Comparison {
         }
 
         @Override
-        public Graph search(DataModel dataModel, Parameters parameters) {
-            return algorithmWrapper.getAlgorithm().search(dataModel, parameters);
+        public Graph search(DataModel DataModel, Parameters parameters) {
+            return algorithmWrapper.getAlgorithm().search(DataModel, parameters);
         }
 
         @Override
@@ -1853,9 +1813,9 @@ public class Comparison {
         }
 
         public void setValue(String name, Object value) {
-//            if (!(value instanceof Number)) {
-//                throw new IllegalArgumentException();
-//            }
+            if (!(value instanceof Number)) {
+                throw new IllegalArgumentException();
+            }
 
             parameters.set(name, value);
         }
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/MIMBuild.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/MIMBuild.java
index 637d59ad..fbe55c06 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/MIMBuild.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/MIMBuild.java
@@ -36,7 +36,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "MIMBuild",
         command = "mimbuild",
-        algoType = AlgType.search_for_structure_over_latents
+        algoType = AlgType.search_for_structure_over_latents,
+        description = ""
 )
 @Nonexecutable
 public class MIMBuild implements Algorithm {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Bpc.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Bpc.java
index 136651f4..9e0b2031 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Bpc.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Bpc.java
@@ -22,9 +22,10 @@ import java.util.List;
  * @author jdramsey
  */
 @edu.cmu.tetrad.annotation.Algorithm(
-        name = "BPC",
+        name = "Bpc",
         command = "bpc",
-        algoType = AlgType.search_for_structure_over_latents
+        algoType = AlgType.search_for_structure_over_latents,
+        description = ""
 )
 public class Bpc implements Algorithm, TakesInitialGraph, HasKnowledge, ClusterAlgorithm {
 
@@ -95,7 +96,7 @@ public class Bpc implements Algorithm, TakesInitialGraph, HasKnowledge, ClusterA
 
     @Override
     public String getDescription() {
-        return "BPC (Build Pure Clusters)";
+        return "FOFC (Find One Factor Clusters)";
     }
 
     @Override
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Fofc.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Fofc.java
index dd2cb6d6..c50f1660 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Fofc.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Fofc.java
@@ -22,9 +22,10 @@ import java.util.List;
  * @author jdramsey
  */
 @edu.cmu.tetrad.annotation.Algorithm(
-        name = "FOFC",
+        name = "Fofc",
         command = "fofc",
-        algoType = AlgType.search_for_structure_over_latents
+        algoType = AlgType.search_for_structure_over_latents,
+        description = ""
 )
 public class Fofc implements Algorithm, TakesInitialGraph, HasKnowledge, ClusterAlgorithm {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Ftfc.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Ftfc.java
index f4383c6c..e56217fc 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Ftfc.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/cluster/Ftfc.java
@@ -20,9 +20,10 @@ import java.util.List;
  * @author jdramsey
  */
 @edu.cmu.tetrad.annotation.Algorithm(
-        name = "FTFC",
+        name = "Ftfc",
         command = "ftfc",
-        algoType = AlgType.search_for_structure_over_latents
+        algoType = AlgType.search_for_structure_over_latents,
+        description = ""
 )
 public class Ftfc implements Algorithm, HasKnowledge, ClusterAlgorithm {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/mixed/Mgm.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/mixed/Mgm.java
index 68c46f6f..407900e6 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/mixed/Mgm.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/mixed/Mgm.java
@@ -24,7 +24,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "MGM",
         command = "mgm",
-        algoType = AlgType.produce_undirected_graphs
+        algoType = AlgType.produce_undirected_graphs,
+        description = ""
 )
 public class Mgm implements Algorithm {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/Fask.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/Fask.java
index 18d1a6b1..380b14bd 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/Fask.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/Fask.java
@@ -11,6 +11,7 @@ import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.util.Parameters;
 import edu.pitt.dbmi.algo.bootstrap.BootstrapEdgeEnsemble;
 import edu.pitt.dbmi.algo.bootstrap.GeneralBootstrapTest;
+
 import java.util.List;
 
 /**
@@ -24,7 +25,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "FASK",
         command = "fask",
-        algoType = AlgType.forbid_latent_common_causes
+        algoType = AlgType.forbid_latent_common_causes,
+        description = ""
 )
 public class Fask implements Algorithm, HasKnowledge, UsesScoreWrapper {
     static final long serialVersionUID = 23L;
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/FaskConcatenated.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/FaskConcatenated.java
index 693a9a80..c06b9eab 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/FaskConcatenated.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/FaskConcatenated.java
@@ -12,6 +12,7 @@ import edu.cmu.tetrad.search.Fask;
 import edu.cmu.tetrad.util.Parameters;
 import edu.pitt.dbmi.algo.bootstrap.BootstrapEdgeEnsemble;
 import edu.pitt.dbmi.algo.bootstrap.GeneralBootstrapTest;
+
 import java.text.DecimalFormat;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -29,7 +30,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "FASK Concatenated",
         command = "fask-concatenated",
-        algoType = AlgType.forbid_latent_common_causes
+        algoType = AlgType.forbid_latent_common_causes,
+        description = ""
 )
 public class FaskConcatenated implements MultiDataSetAlgorithm, HasKnowledge, UsesScoreWrapper {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/ImagesBDeu.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/ImagesBDeu.java
index c94d1f28..a4715333 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/ImagesBDeu.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/ImagesBDeu.java
@@ -29,7 +29,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "IMaGES Discrete",
         command = "imgs_disc",
-        algoType = AlgType.forbid_latent_common_causes
+        algoType = AlgType.forbid_latent_common_causes,
+        description = ""
 )
 public class ImagesBDeu implements MultiDataSetAlgorithm, HasKnowledge {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/ImagesSemBic.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/ImagesSemBic.java
index f724f3aa..99f6ca71 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/ImagesSemBic.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/ImagesSemBic.java
@@ -28,7 +28,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "IMaGES Continuous",
         command = "imgs_cont",
-        algoType = AlgType.forbid_latent_common_causes
+        algoType = AlgType.forbid_latent_common_causes,
+        description = ""
 )
 public class ImagesSemBic implements MultiDataSetAlgorithm, HasKnowledge {
 
@@ -79,7 +80,7 @@ public class ImagesSemBic implements MultiDataSetAlgorithm, HasKnowledge {
 
     @Override
     public Graph search(DataModel dataSet, Parameters parameters) {
-        if (parameters.getInt("bootstrapSampleSize") < 1) {
+        if (!parameters.getBoolean("bootstrapping")) {
             return search(Collections.singletonList((DataModel) DataUtils.getContinuousDataSet(dataSet)), parameters);
         } else {
             ImagesSemBic imagesSemBic = new ImagesSemBic();
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/Lofs.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/Lofs.java
deleted file mode 100644
index 18617c42..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/Lofs.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package edu.cmu.tetrad.algcomparison.algorithm.multi;
-
-import edu.cmu.tetrad.algcomparison.algorithm.Algorithm;
-import edu.cmu.tetrad.algcomparison.graph.RandomGraph;
-import edu.cmu.tetrad.algcomparison.utils.HasKnowledge;
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.EdgeListGraph;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.search.Lofs2;
-import edu.cmu.tetrad.util.Parameters;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Wraps the IMaGES algorithm for continuous variables.
- * </p>
- * Requires that the parameter 'randomSelectionSize' be set to indicate how many
- * datasets should be taken at a time (randomly). This cannot given multiple values.
- *
- * @author jdramsey
- */
-public class Lofs implements Algorithm, HasKnowledge, PassesInGraph {
-    static final long serialVersionUID = 23L;
-    private final Lofs2.Rule rule;
-    private RandomGraph initialGraph;
-    private IKnowledge knowledge = new Knowledge2();
-
-    public Lofs(Lofs2.Rule rule) {
-        this.rule = rule;
-    }
-
-    public Lofs(Lofs2.Rule rule, RandomGraph initialGraph) {
-        this.rule = rule;
-        this.initialGraph = initialGraph;
-    }
-
-    @Override
-    public Graph search(DataModel dataSet, Parameters parameters) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public Graph search(List<DataModel> dataSet, Parameters parameters, Graph graph) {
-        edu.cmu.tetrad.search.FasLofs search = new edu.cmu.tetrad.search.FasLofs((DataSet) dataSet, rule);
-        search.setDepth(parameters.getInt("depth"));
-        search.setPenaltyDiscount(parameters.getDouble("penaltyDiscount"));
-        search.setKnowledge(knowledge);
-        return search.orient(graph);
-    }
-
-    @Override
-    public Graph getComparisonGraph(Graph graph) {
-        return new EdgeListGraph(graph);
-    }
-
-    @Override
-    public String getDescription() {
-        return "True graph oriented by " + rule;
-    }
-
-    @Override
-    public DataType getDataType() {
-        return DataType.Continuous;
-    }
-
-    @Override
-    public List<String> getParameters() {
-        List<String> parameters = new ArrayList<>();
-        parameters.add("depth");
-        parameters.add("penaltyDiscount");
-
-        return parameters;
-    }
-
-    @Override
-    public IKnowledge getKnowledge() {
-        return knowledge;
-    }
-
-    @Override
-    public void setKnowledge(IKnowledge knowledge) {
-        this.knowledge = knowledge;
-    }
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/LofsConcatenated.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/LofsConcatenated.java
deleted file mode 100644
index ad6eaa47..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/LofsConcatenated.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package edu.cmu.tetrad.algcomparison.algorithm.multi;
-
-import edu.cmu.tetrad.algcomparison.algorithm.MultiDataSetAlgorithm;
-import edu.cmu.tetrad.algcomparison.graph.RandomGraph;
-import edu.cmu.tetrad.algcomparison.utils.HasKnowledge;
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.EdgeListGraph;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.search.Lofs2;
-import edu.cmu.tetrad.util.Parameters;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Wraps the IMaGES algorithm for continuous variables.
- * </p>
- * Requires that the parameter 'randomSelectionSize' be set to indicate how many
- * datasets should be taken at a time (randomly). This cannot given multiple values.
- *
- * @author jdramsey
- */
-public class LofsConcatenated implements MultiDataSetAlgorithm, HasKnowledge, PassesInGraph {
-    static final long serialVersionUID = 23L;
-    private final Lofs2.Rule rule;
-    private RandomGraph initialGraph;
-    private IKnowledge knowledge = new Knowledge2();
-
-    public LofsConcatenated(Lofs2.Rule rule) {
-        this.rule = rule;
-    }
-
-    public LofsConcatenated(Lofs2.Rule rule, RandomGraph initialGraph) {
-        this.rule = rule;
-        this.initialGraph = initialGraph;
-    }
-
-    @Override
-    public Graph search(List<DataModel> dataSets, Parameters parameters, Graph graph) {
-
-        List<DataSet> centered = new ArrayList<>();
-
-        for (DataModel dataSet : dataSets) {
-            centered.add(DataUtils.center((DataSet) dataSet));
-        }
-
-        DataSet dataSet = DataUtils.concatenate(centered);
-        edu.cmu.tetrad.search.FasLofs search = new edu.cmu.tetrad.search.FasLofs((DataSet) dataSet, rule);
-        search.setDepth(parameters.getInt("depth"));
-        search.setPenaltyDiscount(parameters.getDouble("penaltyDiscount"));
-        search.setKnowledge(knowledge);
-        return search.orient(graph);
-    }
-
-    @Override
-    public Graph search(DataModel dataSet, Parameters parameters) {
-        return search(Collections.singletonList((DataModel) DataUtils.getContinuousDataSet(dataSet)), parameters);
-    }
-
-    @Override
-    public Graph getComparisonGraph(Graph graph) {
-        return new EdgeListGraph(graph);
-    }
-
-    @Override
-    public String getDescription() {
-        return "True graph oriented by " + rule + " using concatenated data";
-    }
-
-    @Override
-    public DataType getDataType() {
-        return DataType.Continuous;
-    }
-
-    @Override
-    public List<String> getParameters() {
-        List<String> parameters = new ArrayList<>();
-        parameters.add("depth");
-        parameters.add("penaltyDiscount");
-        parameters.add("twoCycleAlpha");
-        parameters.add("numRuns");
-        parameters.add("randomSelectionSize");
-
-        return parameters;
-    }
-
-    @Override
-    public IKnowledge getKnowledge() {
-        return knowledge;
-    }
-
-    @Override
-    public void setKnowledge(IKnowledge knowledge) {
-        this.knowledge = knowledge;
-    }
-
-    @Override
-    public Graph search(List<DataModel> dataSet, Parameters parameters) {
-        throw new UnsupportedOperationException();
-    }
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/PassesInGraph.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/PassesInGraph.java
deleted file mode 100644
index 1639a754..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/multi/PassesInGraph.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package edu.cmu.tetrad.algcomparison.algorithm.multi;
-
-import edu.cmu.tetrad.data.DataModel;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.util.Parameters;
-
-import java.util.List;
-
-public interface PassesInGraph {
-    Graph search(List<DataModel> dataSet, Parameters parameters, Graph graph);
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Fci.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Fci.java
index 18c5d277..2048c262 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Fci.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Fci.java
@@ -27,7 +27,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "FCI",
         command = "fci",
-        algoType = AlgType.allow_latent_common_causes
+        algoType = AlgType.allow_latent_common_causes,
+        description = ""
 )
 public class Fci implements Algorithm, TakesInitialGraph, HasKnowledge, TakesIndependenceWrapper {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Gfci.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Gfci.java
index 3d36137a..43a1135d 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Gfci.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Gfci.java
@@ -25,7 +25,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "GFCI",
         command = "gfci",
-        algoType = AlgType.allow_latent_common_causes
+        algoType = AlgType.allow_latent_common_causes,
+        description = ""
 )
 public class Gfci implements Algorithm, HasKnowledge, UsesScoreWrapper, TakesIndependenceWrapper {
 
@@ -108,14 +109,7 @@ public class Gfci implements Algorithm, HasKnowledge, UsesScoreWrapper, TakesInd
     @Override
     public List<String> getParameters() {
         List<String> parameters = test.getParameters();
-        List<String> parameters1 = score.getParameters();
-
-        for (String param : parameters1) {
-            if (!parameters.contains(param)) {
-                parameters.add(param);
-            }
-        }
-
+        parameters.addAll(score.getParameters());
         parameters.add("faithfulnessAssumed");
         parameters.add("maxDegree");
 //        parameters.add("printStream");
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Rfci.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Rfci.java
index 6c81ba08..36626be2 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Rfci.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/Rfci.java
@@ -26,7 +26,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "RFCI",
         command = "rfci",
-        algoType = AlgType.allow_latent_common_causes
+        algoType = AlgType.allow_latent_common_causes,
+        description = ""
 )
 public class Rfci implements Algorithm, HasKnowledge, TakesIndependenceWrapper {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsFci.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsFci.java
index 0b93b9d4..6d6270c8 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsFci.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsFci.java
@@ -10,6 +10,7 @@ import edu.cmu.tetrad.data.DataModel;
 import edu.cmu.tetrad.data.DataSet;
 import edu.cmu.tetrad.data.DataType;
 import edu.cmu.tetrad.data.IKnowledge;
+import edu.cmu.tetrad.data.TimeSeriesData;
 import edu.cmu.tetrad.graph.EdgeListGraph;
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.search.TsDagToPag;
@@ -27,7 +28,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "TsFCI",
         command = "ts-fci",
-        algoType = AlgType.allow_latent_common_causes
+        algoType = AlgType.allow_latent_common_causes,
+        description = ""
 )
 public class TsFci implements Algorithm, TakesInitialGraph, HasKnowledge, TakesIndependenceWrapper {
 
@@ -51,14 +53,17 @@ public class TsFci implements Algorithm, TakesInitialGraph, HasKnowledge, TakesI
 
     @Override
     public Graph search(DataModel dataSet, Parameters parameters) {
-//    	if (!(dataSet instanceof TimeSeriesData)) {
-//            throw new IllegalArgumentException("You need a (labeled) time series data set to run TsFCI.");
-//        }
+    	if (!(dataSet instanceof TimeSeriesData)) {
+            throw new IllegalArgumentException("You need a (labeled) time series data set to run TsFCI.");
+        } 
         
         if (parameters.getInt("bootstrapSampleSize") < 1) {
             edu.cmu.tetrad.search.TsFci search = new edu.cmu.tetrad.search.TsFci(test.getTest(dataSet, parameters));
             search.setDepth(parameters.getInt("depth"));
-            search.setKnowledge(dataSet.getKnowledge());
+
+            IKnowledge _knowledge = getKnowledge() != null ? getKnowledge() : dataSet.getKnowledge();
+
+            search.setKnowledge(_knowledge);
             return search.search();
         } else {
             TsFci tsFci = new TsFci(test, algorithm);
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsGfci.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsGfci.java
index b8f39952..95d8825c 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsGfci.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsGfci.java
@@ -8,7 +8,11 @@ import edu.cmu.tetrad.algcomparison.utils.TakesIndependenceWrapper;
 import edu.cmu.tetrad.algcomparison.utils.TakesInitialGraph;
 import edu.cmu.tetrad.algcomparison.utils.UsesScoreWrapper;
 import edu.cmu.tetrad.annotation.AlgType;
-import edu.cmu.tetrad.data.*;
+import edu.cmu.tetrad.data.DataModel;
+import edu.cmu.tetrad.data.DataSet;
+import edu.cmu.tetrad.data.DataType;
+import edu.cmu.tetrad.data.IKnowledge;
+import edu.cmu.tetrad.data.TimeSeriesData;
 import edu.cmu.tetrad.graph.EdgeListGraph;
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.search.TsDagToPag;
@@ -26,7 +30,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "TsGFCI",
         command = "ts-gfci",
-        algoType = AlgType.allow_latent_common_causes
+        algoType = AlgType.allow_latent_common_causes,
+        description = ""
 )
 public class TsGfci implements Algorithm, TakesInitialGraph, HasKnowledge, TakesIndependenceWrapper, UsesScoreWrapper {
 
@@ -47,14 +52,13 @@ public class TsGfci implements Algorithm, TakesInitialGraph, HasKnowledge, Takes
 
     @Override
     public Graph search(DataModel dataSet, Parameters parameters) {
-//    	if (!(dataSet instanceof TimeSeriesData)) {
-//            throw new IllegalArgumentException("You need a (labeled) time series data set to run TsGFCI.");
-//        }
+    	if (!(dataSet instanceof TimeSeriesData)) {
+            throw new IllegalArgumentException("You need a (labeled) time series data set to run TsGFCI.");
+        } 
         
         if (parameters.getInt("bootstrapSampleSize") < 1) {
             edu.cmu.tetrad.search.TsGFci search = new edu.cmu.tetrad.search.TsGFci(test.getTest(dataSet, parameters),
                     score.getScore(dataSet, parameters));
-            IKnowledge _knowledge = dataSet.getKnowledge() != null ? dataSet.getKnowledge() : new Knowledge2();
             search.setKnowledge(dataSet.getKnowledge());
             return search.search();
         } else {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsImages.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsImages.java
index 5bdd254d..8898aad7 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsImages.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pag/TsImages.java
@@ -2,25 +2,14 @@ package edu.cmu.tetrad.algcomparison.algorithm.oracle.pag;
 
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithm;
 import edu.cmu.tetrad.algcomparison.algorithm.MultiDataSetAlgorithm;
-import edu.cmu.tetrad.algcomparison.score.BdeuScore;
 import edu.cmu.tetrad.algcomparison.score.ScoreWrapper;
-import edu.cmu.tetrad.algcomparison.score.SemBicScore;
 import edu.cmu.tetrad.algcomparison.utils.HasKnowledge;
 import edu.cmu.tetrad.algcomparison.utils.UsesScoreWrapper;
 import edu.cmu.tetrad.annotation.AlgType;
-import edu.cmu.tetrad.data.DataModel;
-import edu.cmu.tetrad.data.DataSet;
-import edu.cmu.tetrad.data.DataType;
-import edu.cmu.tetrad.data.IKnowledge;
+import edu.cmu.tetrad.data.*;
 import edu.cmu.tetrad.graph.EdgeListGraph;
 import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.search.BdeuScoreImages;
-import edu.cmu.tetrad.search.IndTestScore;
-import edu.cmu.tetrad.search.IndependenceTest;
-import edu.cmu.tetrad.search.Score;
-import edu.cmu.tetrad.search.SemBicScoreImages;
-import edu.cmu.tetrad.search.TsDagToPag;
-import edu.cmu.tetrad.search.TsGFci;
+import edu.cmu.tetrad.search.*;
 import edu.cmu.tetrad.util.Parameters;
 import edu.pitt.dbmi.algo.bootstrap.BootstrapEdgeEnsemble;
 import edu.pitt.dbmi.algo.bootstrap.GeneralBootstrapTest;
@@ -34,9 +23,10 @@ import java.util.List;
  * @author Daniel Malinsky
  */
 @edu.cmu.tetrad.annotation.Algorithm(
-        name = "TsIMaGES",
+        name = "TsImages",
         command = "ts-imgs",
-        algoType = AlgType.forbid_latent_common_causes
+        algoType = AlgType.forbid_latent_common_causes,
+        description = ""
 )
 public class TsImages implements Algorithm, HasKnowledge, MultiDataSetAlgorithm, UsesScoreWrapper {
 
@@ -49,7 +39,7 @@ public class TsImages implements Algorithm, HasKnowledge, MultiDataSetAlgorithm,
     }
 
     public TsImages(ScoreWrapper score) {
-        if (!(score instanceof SemBicScore || score instanceof BdeuScore)) {
+        if (!(score instanceof SemBicScore || score instanceof BDeuScore)) {
             throw new IllegalArgumentException("Only SEM BIC score or BDeu score can be used with this, sorry.");
         }
 
@@ -58,7 +48,7 @@ public class TsImages implements Algorithm, HasKnowledge, MultiDataSetAlgorithm,
 
     @Override
     public Graph search(DataModel dataModel, Parameters parameters) {
-        if (parameters.getInt("bootstrapSampleSize") < 1) {
+    	if (parameters.getInt("bootstrapSampleSize") < 1) {
             DataSet dataSet = (DataSet) dataModel;
             TsGFci search;
             Score score1 = score.getScore(dataSet, parameters);
@@ -110,13 +100,11 @@ public class TsImages implements Algorithm, HasKnowledge, MultiDataSetAlgorithm,
     @Override
     public List<String> getParameters() {
         List<String> parameters = score.getParameters();
-        parameters.add("numRuns");
-        parameters.add("randomSelectionSize");
         // Bootstrapping
         parameters.add("bootstrapSampleSize");
         parameters.add("bootstrapEnsemble");
         parameters.add("verbose");
-        return parameters;
+        return score.getParameters();
     }
 
     @Override
@@ -144,7 +132,7 @@ public class TsImages implements Algorithm, HasKnowledge, MultiDataSetAlgorithm,
             gesScore.setPenaltyDiscount(parameters.getDouble("penaltyDiscount"));
             IndependenceTest test = new IndTestScore(gesScore);
             search = new TsGFci(test, gesScore);
-        } else if (score instanceof BdeuScore) {
+        } else if (score instanceof BDeScore) {
             double samplePrior = parameters.getDouble("samplePrior", 1);
             double structurePrior = parameters.getDouble("structurePrior", 1);
             BdeuScoreImages score = new BdeuScoreImages(dataModels);
@@ -165,5 +153,4 @@ public class TsImages implements Algorithm, HasKnowledge, MultiDataSetAlgorithm,
     public void setScoreWrapper(ScoreWrapper score) {
         this.score = score;
     }
-
 }
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/FAS.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/FAS.java
index 3433caca..98181532 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/FAS.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/FAS.java
@@ -26,7 +26,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "FAS",
         command = "fas",
-        algoType = AlgType.produce_undirected_graphs
+        algoType = AlgType.produce_undirected_graphs,
+        description = ""
 )
 public class FAS implements Algorithm, HasKnowledge, TakesIndependenceWrapper {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/Fges.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/Fges.java
index b925f2ad..62e41b4b 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/Fges.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/Fges.java
@@ -28,7 +28,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "FGES",
         command = "fges",
-        algoType = AlgType.forbid_latent_common_causes
+        algoType = AlgType.forbid_latent_common_causes,
+        description = ""
 )
 public class Fges implements Algorithm, TakesInitialGraph, HasKnowledge, UsesScoreWrapper {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/FgesMb.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/FgesMb.java
index 224e1336..5a5233fc 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/FgesMb.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/FgesMb.java
@@ -24,9 +24,10 @@ import java.util.List;
  * @author jdramsey
  */
 @edu.cmu.tetrad.annotation.Algorithm(
-        name = "FGES-MB",
+        name = "FgesMb",
         command = "fges-mb",
-        algoType = AlgType.search_for_Markov_blankets
+        algoType = AlgType.search_for_Markov_blankets,
+        description = ""
 )
 public class FgesMb implements Algorithm, TakesInitialGraph, HasKnowledge, UsesScoreWrapper {
 
@@ -119,7 +120,6 @@ public class FgesMb implements Algorithm, TakesInitialGraph, HasKnowledge, UsesS
     public List<String> getParameters() {
         List<String> parameters = score.getParameters();
         parameters.add("targetName");
-        parameters.add("adjacentsOnly");
         parameters.add("faithfulnessAssumed");
         // Bootstrapping
         parameters.add("bootstrapSampleSize");
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/MBFS.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/MBFS.java
index 4feb6967..a717c3ab 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/MBFS.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/MBFS.java
@@ -28,7 +28,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "MBFS",
         command = "mbfs",
-        algoType = AlgType.search_for_Markov_blankets
+        algoType = AlgType.search_for_Markov_blankets,
+        description = ""
 )
 public class MBFS implements Algorithm, HasKnowledge, TakesIndependenceWrapper {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/Pc.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/Pc.java
index 3c842745..f62adb52 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/Pc.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/Pc.java
@@ -5,7 +5,6 @@ import edu.cmu.tetrad.algcomparison.independence.IndependenceWrapper;
 import edu.cmu.tetrad.algcomparison.utils.HasKnowledge;
 import edu.cmu.tetrad.algcomparison.utils.TakesIndependenceWrapper;
 import edu.cmu.tetrad.algcomparison.utils.TakesInitialGraph;
-import edu.cmu.tetrad.annotation.AlgType;
 import edu.cmu.tetrad.data.DataModel;
 import edu.cmu.tetrad.data.DataSet;
 import edu.cmu.tetrad.data.DataType;
@@ -21,11 +20,11 @@ import edu.pitt.dbmi.algo.bootstrap.GeneralBootstrapTest;
 
 import java.util.List;
 
-@edu.cmu.tetrad.annotation.Algorithm(
-        name = "PC",
-        command = "pc",
-        algoType = AlgType.forbid_latent_common_causes
-)
+/**
+ * PC.
+ *
+ * @author jdramsey
+ */
 public class Pc implements Algorithm, TakesInitialGraph, HasKnowledge, TakesIndependenceWrapper {
 
     static final long serialVersionUID = 23L;
@@ -57,9 +56,12 @@ public class Pc implements Algorithm, TakesInitialGraph, HasKnowledge, TakesInde
             if (algorithm != null) {
 //            	initialGraph = algorithm.search(dataSet, parameters);
             }
-            edu.cmu.tetrad.search.Pc search = new edu.cmu.tetrad.search.Pc(test.getTest(dataSet, parameters));
+            edu.cmu.tetrad.search.PcAll search = new edu.cmu.tetrad.search.PcAll(test.getTest(dataSet, parameters), initialGraph);
             search.setDepth(parameters.getInt("depth"));
             search.setKnowledge(knowledge);
+            search.setFasRule(PcAll.FasRule.FAS);
+            search.setColliderDiscovery(PcAll.ColliderDiscovery.FAS_SEPSETS);
+            search.setConflictRule(PcAll.ConflictRule.PRIORITY);
             search.setVerbose(parameters.getBoolean("verbose"));
             return search.search();
         }else{
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/PcAll.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/PcAll.java
index c7735bb9..9f33ec4b 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/PcAll.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/PcAll.java
@@ -27,7 +27,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "PC All",
         command = "pc-all",
-        algoType = AlgType.forbid_latent_common_causes
+        algoType = AlgType.forbid_latent_common_causes,
+        description = ""
 )
 public class PcAll implements Algorithm, TakesInitialGraph, HasKnowledge, TakesIndependenceWrapper {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/PcStableMax.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/PcStableMax.java
index d5c4cc80..b0d6bfe2 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/PcStableMax.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/oracle/pattern/PcStableMax.java
@@ -5,6 +5,7 @@ import edu.cmu.tetrad.algcomparison.independence.IndependenceWrapper;
 import edu.cmu.tetrad.algcomparison.utils.HasKnowledge;
 import edu.cmu.tetrad.algcomparison.utils.TakesIndependenceWrapper;
 import edu.cmu.tetrad.algcomparison.utils.TakesInitialGraph;
+import edu.cmu.tetrad.annotation.AlgType;
 import edu.cmu.tetrad.data.DataModel;
 import edu.cmu.tetrad.data.DataSet;
 import edu.cmu.tetrad.data.DataType;
@@ -27,7 +28,8 @@ import java.util.List;
 //@edu.cmu.tetrad.annotation.Algorithm(
 //        name = "PcStableMax",
 //        command = "pc-stable-max",
-//        algoType = AlgType.forbid_latent_common_causes
+//        algoType = AlgType.forbid_latent_common_causes,
+//        description = "A revision (Ramsey, 2016). \"Improving Accuracy and Scalability of the PC Algorithm by Maximizing P-value.\" arXiv preprint arXiv:1610.00378 (2016).) of the PC algorithm (Spirtes, Glymour and Scheines, 2000) in which colliders are oriented following the regime of CPC (Ramsey et al. (2012)), except instead of looking for conflicts among orientation for independence judgements, one picks the separating set with the maximal p-value and judges collider orientation with respect to this set."
 //)
 public class PcStableMax implements Algorithm, TakesInitialGraph, HasKnowledge, TakesIndependenceWrapper {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/other/Glasso.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/other/Glasso.java
index ce76dd24..2f89da63 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/other/Glasso.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/other/Glasso.java
@@ -22,7 +22,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "GLASSO",
         command = "glasso",
-        algoType = AlgType.produce_undirected_graphs
+        algoType = AlgType.produce_undirected_graphs,
+        description = ""
 )
 public class Glasso implements Algorithm {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/EB.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/EB.java
index 597a1471..475fc984 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/EB.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/EB.java
@@ -27,7 +27,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "EB",
         command = "eb",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class EB implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/FaskOrientation.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/FaskOrientation.java
deleted file mode 100644
index 77d40492..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/FaskOrientation.java
+++ /dev/null
@@ -1,171 +0,0 @@
-package edu.cmu.tetrad.algcomparison.algorithm.pairwise;
-
-import edu.cmu.tetrad.algcomparison.algorithm.Algorithm;
-import edu.cmu.tetrad.algcomparison.utils.TakesInitialGraph;
-import edu.cmu.tetrad.annotation.AlgType;
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.EdgeListGraph;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.graph.GraphUtils;
-import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.util.Parameters;
-import edu.pitt.dbmi.algo.bootstrap.BootstrapEdgeEnsemble;
-import edu.pitt.dbmi.algo.bootstrap.GeneralBootstrapTest;
-
-import java.util.LinkedList;
-import java.util.List;
-
-/**
- * R3.
- *
- * @author jdramsey
- */
-@edu.cmu.tetrad.annotation.Algorithm(
-        name = "Fask Orientation",
-        command = "fask_orientation",
-        algoType = AlgType.orient_pairwise
-//        description = "These are algorithms that orient edges X—Y for continuous variables pairwise based on non-Gaussian information. (If the variables are all Gaussian, one cannot orient these edges. That is, these rules will orient left or right randomly.) For EB, RSkew, RSkewE, Skew and SkewE, see Hyvarinen and Smith (2013). For R1, R2, R3 and R4, see Ramsey et al., 2014.\n" +
-//                "\n" +
-//                "The principles governing these rules vary. R1 and R2 appeal directly to the Central Limit Theorem to judge which of various conditioning sets yields the greatest non-Gaussianity measure. (The measure for non-Gaussianity measure used is Anderson-Darling.) R4 does as well, but allows coefficients for relevant parameters to be adjusted to achieve maximum non-Gaussianity. EB works by appealing to entropy for the orientation. R3 uses the same rule as EB except using the Anderson-Darling score for a measure of non-Gaussianity. RSkew and Skew appeal to measures of skew for the variables and assume positive skewness for all variables. The rules for the two are different; please see Hyvarinen and Smith for details. SkewE and RSkewE adjust the signs of variables by the signs of their skewnesses to ensure that the assumption of positive skewness holds. FaskOrientation uses the left-right rule from FASK\n" +
-//                "\n" +
-//                "A comparison of all of these methods is given in Ramsey et al., 2014. In general, for fMRI data, we find that the RSkew method works the best, followed by the R3 method. Cycles can be oriented using these methods, since each edge is oriented independently of the others.\n" +
-//                "\n" +
-//                "Input Assumptions: Continuous data in which the variables are non-Gaussian. Non-Gaussianity can be assessed using the Anderson-Darling score, which is available in the Data box.\n" +
-//                "\n" +
-//                "Output Format: Orients all of the edges in the input graph using the selected score. \n" +
-//                "\n" +
-//                "Parameters:\n" +
-//                "- Cutoff for p-values (alpha). Conditional independence tests with p-values greater than this will be judged to be independent (H0).\n" +
-//                "- Maximum size of conditioning set (depth). PC in the adjacency phase will consider conditioning sets for conditional independences of increasing size, up to this value. For instance, for depth 3, the maximum size of a conditioning set considered will be 3."
-)
-public class FaskOrientation implements Algorithm, TakesInitialGraph {
-
-    static final long serialVersionUID = 23L;
-    private Algorithm algorithm = null;
-    private Graph initialGraph = null;
-    private IKnowledge knowledge;
-
-    public FaskOrientation() {
-    }
-
-    public FaskOrientation(Algorithm algorithm) {
-        this.algorithm = algorithm;
-    }
-
-    @Override
-    public Graph search(DataModel dataSet, Parameters parameters) {
-        if (parameters.getInt("bootstrapSampleSize") < 1) {
-            initialGraph = algorithm.search(dataSet, parameters);
-
-//            if (initialGraph != null) {
-//                initialGraph = algorithm.search(dataSet, parameters);
-//            } else {
-//                throw new IllegalArgumentException("This R3 algorithm needs both data and a graph source as inputs; it \n"
-//                        + "will orient the edges in the input graph using the data");
-//            }
-
-            List<String> nodes = initialGraph.getNodeNames();
-
-            initialGraph = GraphUtils.replaceNodes(initialGraph, dataSet.getVariables());
-
-            for (Node node : initialGraph.getNodes()){
-                if (!nodes.contains(node.getName())) {
-                    initialGraph.removeNode(node);
-                }
-            }
-
-            dataSet = ((DataSet) dataSet).subsetColumns(initialGraph.getNodes());
-
-            edu.cmu.tetrad.search.SemBicScore score = new edu.cmu.tetrad.search.SemBicScore(new CovarianceMatrixOnTheFly((DataSet) dataSet, false));
-            score.setPenaltyDiscount(parameters.getDouble("penaltyDiscount"));
-            edu.cmu.tetrad.search.Fask search = new edu.cmu.tetrad.search.Fask((DataSet) dataSet, score);
-            search.setInitialGraph(initialGraph);
-            search.setExtraEdgeThreshold(parameters.getDouble("extraEdgeThreshold"));
-            return search.search();
-        } else {
-            FaskOrientation r3 = new FaskOrientation(algorithm);
-            if (initialGraph != null) {
-                r3.setInitialGraph(initialGraph);
-            }
-
-            DataSet data = (DataSet) dataSet;
-            GeneralBootstrapTest search = new GeneralBootstrapTest(data, r3,
-                    parameters.getInt("bootstrapSampleSize"));
-
-            BootstrapEdgeEnsemble edgeEnsemble = BootstrapEdgeEnsemble.Highest;
-            switch (parameters.getInt("bootstrapEnsemble", 1)) {
-                case 0:
-                    edgeEnsemble = BootstrapEdgeEnsemble.Preserved;
-                    break;
-                case 1:
-                    edgeEnsemble = BootstrapEdgeEnsemble.Highest;
-                    break;
-                case 2:
-                    edgeEnsemble = BootstrapEdgeEnsemble.Majority;
-            }
-            search.setEdgeEnsemble(edgeEnsemble);
-            search.setParameters(parameters);
-            search.setVerbose(parameters.getBoolean("verbose"));
-            return search.search();
-        }
-    }
-
-    @Override
-    public Graph getComparisonGraph(Graph graph) {
-        return new EdgeListGraph(graph);
-    }
-
-    @Override
-    public String getDescription() {
-        return "R3, entropy based pairwise orientation" + (algorithm != null ? " with initial graph from "
-                + algorithm.getDescription() : "");
-    }
-
-    @Override
-    public DataType getDataType() {
-        return DataType.Continuous;
-    }
-
-    @Override
-    public List<String> getParameters() {
-        List<String> parameters = new LinkedList<>();
-
-        if (algorithm != null && !algorithm.getParameters().isEmpty()) {
-            parameters.addAll(algorithm.getParameters());
-        }
-
-        // Bootstrapping
-        parameters.add("twoCycleAlpha");
-        parameters.add("extraEdgeThreshold");
-        parameters.add("bootstrapSampleSize");
-        parameters.add("bootstrapEnsemble");
-        parameters.add("verbose");
-
-        return parameters;
-    }
-
-    public void setKnowledge(IKnowledge knowledge) {
-        this.knowledge = knowledge;
-    }
-
-    @Override
-    public Graph getInitialGraph() {
-        return initialGraph;
-    }
-
-    @Override
-    public void setInitialGraph(Graph initialGraph) {
-        this.initialGraph = initialGraph;
-    }
-
-    @Override
-    public void setInitialGraph(Algorithm algorithm) {
-        if (algorithm == null) {
-            throw new IllegalArgumentException("This R3 algorithm needs both data and a graph source as inputs; it \n"
-                    + "will orient the edges in the input graph using the data.");
-        }
-
-        this.algorithm = algorithm;
-    }
-
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R1.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R1.java
index 27308190..94714153 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R1.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R1.java
@@ -25,7 +25,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "R1",
         command = "r1",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class R1 implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R2.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R2.java
index 48acdb94..998415a2 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R2.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R2.java
@@ -25,7 +25,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "R2",
         command = "r2",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class R2 implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R3.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R3.java
index be7892c4..da06a1bf 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R3.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R3.java
@@ -22,7 +22,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "R3",
         command = "r3",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class R3 implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R4.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R4.java
index aecf9d29..6e65b00a 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R4.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/R4.java
@@ -27,7 +27,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "R4",
         command = "r4",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class R4 implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/RSkew.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/RSkew.java
index 52b236a4..4abb1913 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/RSkew.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/RSkew.java
@@ -25,7 +25,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "RSkew",
         command = "r-skew",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class RSkew implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/RSkewE.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/RSkewE.java
index 7ff8433f..181765ea 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/RSkewE.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/RSkewE.java
@@ -25,7 +25,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "RSkewE",
         command = "r-skew-e",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class RSkewE implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/Skew.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/Skew.java
index b50036e1..0a42f794 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/Skew.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/Skew.java
@@ -25,7 +25,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "Skew",
         command = "skew",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class Skew implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/SkewE.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/SkewE.java
index ebb7e3d9..14716896 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/SkewE.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/algorithm/pairwise/SkewE.java
@@ -25,7 +25,8 @@ import java.util.List;
 @edu.cmu.tetrad.annotation.Algorithm(
         name = "SkewE",
         command = "skew-e",
-        algoType = AlgType.orient_pairwise
+        algoType = AlgType.orient_pairwise,
+        description = ""
 )
 public class SkewE implements Algorithm, TakesInitialGraph {
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/CompareExternalAlgorithms.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/CompareExternalAlgorithms.java
index 5403ccc7..73d031b8 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/CompareExternalAlgorithms.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/CompareExternalAlgorithms.java
@@ -26,6 +26,8 @@ import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
 import edu.cmu.tetrad.algcomparison.algorithm.external.ExternalAlgorithmBNTPc;
 import edu.cmu.tetrad.algcomparison.algorithm.external.ExternalAlgorithmPcalgPc;
 import edu.cmu.tetrad.algcomparison.algorithm.external.ExternalAlgorithmTetrad;
+import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Fges;
+import edu.cmu.tetrad.algcomparison.score.MVPBicScore;
 import edu.cmu.tetrad.algcomparison.statistic.*;
 import edu.cmu.tetrad.util.Parameters;
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/CompareFromFiles.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/CompareFromFiles.java
index c7f9ba2e..74b79bc7 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/CompareFromFiles.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/CompareFromFiles.java
@@ -23,8 +23,13 @@ package edu.cmu.tetrad.algcomparison.examples;
 
 import edu.cmu.tetrad.algcomparison.Comparison;
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
+import edu.cmu.tetrad.algcomparison.algorithm.mixed.Mgm;
 import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.*;
+import edu.cmu.tetrad.algcomparison.independence.ConditionalGaussianLRT;
+import edu.cmu.tetrad.algcomparison.independence.FisherZ;
 //import edu.cmu.tetrad.algcomparison.independence.MNLRLRT;
+import edu.cmu.tetrad.algcomparison.independence.MNLRLRT;
+import edu.cmu.tetrad.algcomparison.independence.MVPLRT;
 import edu.cmu.tetrad.algcomparison.score.*;
 import edu.cmu.tetrad.algcomparison.statistic.*;
 import edu.cmu.tetrad.util.Parameters;
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/ExampleCompareSimulation.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/ExampleCompareSimulation.java
index 323f948b..668ae79d 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/ExampleCompareSimulation.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/ExampleCompareSimulation.java
@@ -26,6 +26,7 @@ import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
 import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.*;
 import edu.cmu.tetrad.algcomparison.graph.RandomForward;
 import edu.cmu.tetrad.algcomparison.independence.FisherZ;
+import edu.cmu.tetrad.algcomparison.score.MVPBicScore;
 import edu.cmu.tetrad.algcomparison.score.SemBicScore;
 import edu.cmu.tetrad.algcomparison.simulation.SemSimulation;
 import edu.cmu.tetrad.algcomparison.simulation.Simulations;
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/ExampleCompareSimulationTimeSeries.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/ExampleCompareSimulationTimeSeries.java
index b78a5a67..79d9d118 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/ExampleCompareSimulationTimeSeries.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/examples/ExampleCompareSimulationTimeSeries.java
@@ -29,6 +29,10 @@ import edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.TsImages;
 import edu.cmu.tetrad.algcomparison.graph.RandomForward;
 import edu.cmu.tetrad.algcomparison.independence.FisherZ;
 import edu.cmu.tetrad.algcomparison.score.SemBicScore;
+import edu.cmu.tetrad.search.IndTestScore;
+import edu.cmu.tetrad.search.IndependenceTest;
+import edu.cmu.tetrad.search.Score;
+import edu.cmu.tetrad.search.ScoredIndTest;
 import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.algcomparison.simulation.Simulations;
 import edu.cmu.tetrad.algcomparison.simulation.TimeSeriesSemSimulation;
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/independence/SemBicTest.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/independence/SemBicTest.java
index c12436bb..dfc1f7c8 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/independence/SemBicTest.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/independence/SemBicTest.java
@@ -28,16 +28,7 @@ public class SemBicTest implements IndependenceWrapper {
             score = new SemBicScore((ICovarianceMatrix) dataSet);
             score.setPenaltyDiscount(parameters.getDouble("penaltyDiscount"));
         } else {
-            DataSet _data;
-
-//            if (parameters.getBoolean("doNonparanormalTransform")) {
-//                _data = DataUtils.getNonparanormalTransformed((DataSet) dataSet);
-//            } else {
-                _data = (DataSet) dataSet;
-//            }
-
-
-            score = new SemBicScore(new CovarianceMatrix(_data));
+            score = new SemBicScore(new CovarianceMatrix((DataSet) dataSet));
             score.setPenaltyDiscount(parameters.getDouble("penaltyDiscount"));
 
         }
@@ -59,7 +50,6 @@ public class SemBicTest implements IndependenceWrapper {
     public List<String> getParameters() {
         List<String> params = new ArrayList<>();
         params.add("penaltyDiscount");
-        params.add("doNonparanormalTransform");
         return params;
     }
 }
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/ConditionalGaussianBicScore.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/ConditionalGaussianBicScore.java
index d9ef4871..0af81fd5 100755
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/ConditionalGaussianBicScore.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/ConditionalGaussianBicScore.java
@@ -32,7 +32,6 @@ public class ConditionalGaussianBicScore implements ScoreWrapper {
                 = new ConditionalGaussianScore(DataUtils.getMixedDataSet(dataSet), parameters.getDouble("structurePrior"), parameters.getBoolean("discretize"));
 
         conditionalGaussianScore.setNumCategoriesToDiscretize(parameters.getInt("numCategoriesToDiscretize"));
-        conditionalGaussianScore.setPenaltyDiscount(parameters.getDouble("penaltyDiscount"));
         return conditionalGaussianScore;
     }
 
@@ -52,7 +51,6 @@ public class ConditionalGaussianBicScore implements ScoreWrapper {
 
         parameters.add("structurePrior");
         parameters.add("discretize");
-        parameters.add("penaltyDiscount");
         return parameters;
     }
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/SemBicScore.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/SemBicScore.java
index 24f30311..3d6722b6 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/SemBicScore.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/SemBicScore.java
@@ -1,14 +1,14 @@
 package edu.cmu.tetrad.algcomparison.score;
 
-import edu.cmu.tetrad.data.*;
+import edu.cmu.tetrad.data.DataModel;
+import edu.cmu.tetrad.data.DataType;
+import edu.cmu.tetrad.data.DataUtils;
 import edu.cmu.tetrad.graph.Node;
 import edu.cmu.tetrad.search.Score;
 import edu.cmu.tetrad.util.Parameters;
 import java.util.ArrayList;
 import java.util.List;
 
-import static java.lang.Math.log;
-
 /**
  * Wrapper for Fisher Z test.
  *
@@ -28,15 +28,6 @@ public class SemBicScore implements ScoreWrapper {
     @Override
     public Score getScore(DataModel dataSet, Parameters parameters) {
         this.dataSet = dataSet;
-
-//        DataModel _data;
-
-//        if (parameters.getBoolean("doNonparanormalTransform")) {
-//            _data = DataUtils.getNonparanormalTransformed((DataSet) dataSet);
-//        } else {
-//            _data = dataSet;
-//        }
-
         edu.cmu.tetrad.search.SemBicScore semBicScore
                 = new edu.cmu.tetrad.search.SemBicScore(DataUtils.getCovMatrix(dataSet));
         double penaltyDiscount = parameters.getDouble("penaltyDiscount");
@@ -59,7 +50,6 @@ public class SemBicScore implements ScoreWrapper {
     public List<String> getParameters() {
         List<String> parameters = new ArrayList<>();
         parameters.add("penaltyDiscount");
-//        parameters.add("doNonparanormalTransform");
         return parameters;
     }
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/SemBicScoreLinear.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/SemBicScoreLinear.java
deleted file mode 100644
index 77c99529..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/score/SemBicScoreLinear.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package edu.cmu.tetrad.algcomparison.score;
-
-import edu.cmu.tetrad.data.DataModel;
-import edu.cmu.tetrad.data.DataSet;
-import edu.cmu.tetrad.data.DataType;
-import edu.cmu.tetrad.data.DataUtils;
-import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.search.Score;
-import edu.cmu.tetrad.util.ParamDescription;
-import edu.cmu.tetrad.util.Parameters;
-
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Wrapper for Fisher Z test.
- *
- * @author jdramsey
- */
-@edu.cmu.tetrad.annotation.Score(
-        name = "Sem BIC Score Linear",
-        command = "sem-bic-linear",
-        dataType = {DataType.Continuous}
-)
-public class SemBicScoreLinear implements ScoreWrapper {
-
-    static final long serialVersionUID = 23L;
-    private DataModel dataSet;
-    private double penaltyDiscount = 2.0;
-
-    @Override
-    public Score getScore(DataModel dataSet, Parameters parameters) {
-        this.dataSet = dataSet;
-
-        DataModel _data;
-
-        if (parameters.getBoolean("doNonparanormalTransform")) {
-            _data = DataUtils.getNonparanormalTransformed((DataSet) dataSet);
-        } else {
-            _data = dataSet;
-        }
-
-        edu.cmu.tetrad.search.SemBicScoreLinear semBicScore
-                = new edu.cmu.tetrad.search.SemBicScoreLinear((DataSet)_data);
-        double penaltyDiscount = parameters.getDouble("penaltyDiscount");
-        this.penaltyDiscount = penaltyDiscount;
-        semBicScore.setPenaltyDiscount(penaltyDiscount);
-        semBicScore.setNumInBootstrap(parameters.getInt("numInBootstrapForLinearityTest"));
-        semBicScore.setNumBootstraps(parameters.getInt("numBootstrapsForLinearityTest"));
-        semBicScore.setBootstrapAlpha(parameters.getDouble("alphaForLinearityTest"));
-
-        return semBicScore;
-    }
-
-    @Override
-    public String getDescription() {
-        return "Sem BIC Score Linear";
-    }
-
-    @Override
-    public DataType getDataType() {
-        return DataType.Continuous;
-    }
-
-    @Override
-    public List<String> getParameters() {
-        List<String> parameters = new ArrayList<>();
-        parameters.add("penaltyDiscount");
-        parameters.add("doNonparanormalTransform");
-        parameters.add("numInBootstrapForLinearityTest");
-        parameters.add("numBootstrapsForLinearityTest");
-        parameters.add("alphaForLinearityTest");
-
-        return parameters;
-    }
-
-    @Override
-    public Node getVariable(String name) {
-        return dataSet.getVariable(name);
-    }
-
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/simulation/LoadDataAndGraphs.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/simulation/LoadDataAndGraphs.java
index 88613c2e..c6d5fe94 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/simulation/LoadDataAndGraphs.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/simulation/LoadDataAndGraphs.java
@@ -4,7 +4,6 @@ import edu.cmu.tetrad.data.*;
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.graph.GraphUtils;
 import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.graph.NodeType;
 import edu.cmu.tetrad.util.Parameters;
 import edu.pitt.dbmi.data.ContinuousTabularDataset;
 import edu.pitt.dbmi.data.Dataset;
@@ -68,12 +67,6 @@ public class LoadDataAndGraphs implements Simulation {
 
                     DataSet ds = dataReader.parseTabular(file1);
 
-//                    for (Node v : graphs.get(i).getNodes()) {
-//                        if (ds.getVariable(v.getName()) == null) {
-//                            v.setNodeType(NodeType.LATENT);
-//                        }
-//                    }
-
 //                    DataReader reader = new DataReader();
 //                    reader.setVariablesSupplied(true);
 //                    reader.setMaxIntegralDiscrete(parameters.getInt("maxDistinctValuesDiscrete"));
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/AncestorPrecision.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/AncestorPrecision.java
deleted file mode 100644
index 6aad6bd0..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/AncestorPrecision.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package edu.cmu.tetrad.algcomparison.statistic;
-
-import edu.cmu.tetrad.algcomparison.statistic.utils.AdjacencyConfusion;
-import edu.cmu.tetrad.algcomparison.statistic.utils.AncestorConfusion;
-import edu.cmu.tetrad.graph.Graph;
-
-/**
- * The adjacency precision. The true positives are the number of adjacencies in both
- * the true and estimated graphs.
- *
- * @author jdramsey
- */
-public class AncestorPrecision implements Statistic {
-    static final long serialVersionUID = 23L;
-
-    @Override
-    public String getAbbreviation() {
-        return "ANCP";
-    }
-
-    @Override
-    public String getDescription() {
-        return "Ancestor Precision";
-    }
-
-    @Override
-    public double getValue(Graph trueGraph, Graph estGraph) {
-        AncestorConfusion adjConfusion = new AncestorConfusion(trueGraph, estGraph);
-        int tp = adjConfusion.getTp();
-        int fp = adjConfusion.getFp();
-        return tp / (double) (tp + fp);
-    }
-
-    @Override
-    public double getNormValue(double value) {
-        return value;
-    }
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/AncestorRecall.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/AncestorRecall.java
deleted file mode 100644
index 55cee1a7..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/AncestorRecall.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package edu.cmu.tetrad.algcomparison.statistic;
-
-import edu.cmu.tetrad.algcomparison.statistic.utils.AncestorConfusion;
-import edu.cmu.tetrad.graph.Graph;
-
-/**
- * The adjacency precision. The true positives are the number of adjacencies in both
- * the true and estimated graphs.
- *
- * @author jdramsey
- */
-public class AncestorRecall implements Statistic {
-    static final long serialVersionUID = 23L;
-
-    @Override
-    public String getAbbreviation() {
-        return "ANCR";
-    }
-
-    @Override
-    public String getDescription() {
-        return "Ancestor Recall";
-    }
-
-    @Override
-    public double getValue(Graph trueGraph, Graph estGraph) {
-        AncestorConfusion adjConfusion = new AncestorConfusion(trueGraph, estGraph);
-        int tp = adjConfusion.getTp();
-        int fn = adjConfusion.getFn();
-        return tp / (double) (tp + fn);
-    }
-
-    @Override
-    public double getNormValue(double value) {
-        return value;
-    }
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/ArrowheadPrecisionIgnore2c.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/ArrowheadPrecisionIgnore2c.java
deleted file mode 100644
index 4654d2fe..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/ArrowheadPrecisionIgnore2c.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package edu.cmu.tetrad.algcomparison.statistic;
-
-import edu.cmu.tetrad.algcomparison.statistic.utils.ArrowConfusion;
-import edu.cmu.tetrad.algcomparison.statistic.utils.ArrowConfusionIgnore2c;
-import edu.cmu.tetrad.graph.Graph;
-
-/**
- * The arrow precision. This counts arrowheads maniacally, wherever they occur in the graphs.
- * The true positives are the number of arrowheads in both the true and estimated graphs.
- * Thus, if the true contains X*->Y and estimated graph either does not contain an edge from
- * X to Y or else does not contain an arrowhead at X for an edge from X to Y, one false
- * positive is counted. Similarly for false negatives.
- *
- * @author jdramsey
- */
-public class ArrowheadPrecisionIgnore2c implements Statistic {
-    static final long serialVersionUID = 23L;
-
-    @Override
-    public String getAbbreviation() {
-        return "AHPC";
-    }
-
-    @Override
-    public String getDescription() {
-        return "Arrowhead precision Ignore 2 cycles";
-    }
-
-    @Override
-    public double getValue(Graph trueGraph, Graph estGraph) {
-        ArrowConfusionIgnore2c confusion = new ArrowConfusionIgnore2c(trueGraph, estGraph);
-        double arrowsTp = confusion.getArrowsTp();
-        double arrowsFp = confusion.getArrowsFp();
-        return arrowsTp / (arrowsTp + arrowsFp);
-    }
-
-    @Override
-    public double getNormValue(double value) {
-        return value;
-    }
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/SHD.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/SHD.java
index 4aafb1fc..b9f3a582 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/SHD.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/SHD.java
@@ -25,7 +25,7 @@ public class SHD implements Statistic {
 
     @Override
     public double getValue(Graph trueGraph, Graph estGraph) {
-        GraphUtils.GraphComparison comparison = SearchGraphUtils.getGraphComparison3(estGraph, trueGraph);
+        GraphUtils.GraphComparison comparison = SearchGraphUtils.getGraphComparison3(estGraph, trueGraph, System.out);
         return comparison.getShd();
     }
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/AdjacencyConfusion.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/AdjacencyConfusion.java
index 2b9d0e5a..f99c6782 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/AdjacencyConfusion.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/AdjacencyConfusion.java
@@ -1,9 +1,10 @@
 package edu.cmu.tetrad.algcomparison.statistic.utils;
 
-import edu.cmu.tetrad.graph.*;
+import edu.cmu.tetrad.graph.Edge;
+import edu.cmu.tetrad.graph.Edges;
+import edu.cmu.tetrad.graph.Graph;
 
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 
 /**
@@ -12,47 +13,49 @@ import java.util.Set;
  * @author jdramsey
  */
 public class AdjacencyConfusion {
+    private Graph truth;
+    private Graph est;
     private int adjTp;
     private int adjFp;
     private int adjFn;
     private int adjTn;
 
     public AdjacencyConfusion(Graph truth, Graph est) {
+        this.truth = truth;
+        this.est = est;
         adjTp = 0;
         adjFp = 0;
         adjFn = 0;
-        adjTn = 0;
 
-        est = GraphUtils.replaceNodes(est, truth.getNodes());
-        truth = GraphUtils.replaceNodes(truth, est.getNodes());
-
-        List<Node> nodes = truth.getNodes();
-
-        for (int i = 0; i < nodes.size(); i++) {
-            for (int j = i + 1; j < nodes.size(); j++) {
-                Node x = nodes.get(i);
-                Node y = nodes.get(j);
-
-                boolean estAdj = est.isAdjacentTo(x, y);
-                boolean truthAdj = truth.isAdjacentTo(x, y);
+        Set<Edge> allUnoriented = new HashSet<>();
+        for (Edge edge : this.truth.getEdges()) {
+            allUnoriented.add(Edges.undirectedEdge(edge.getNode1(), edge.getNode2()));
+        }
 
-                if (estAdj && !truthAdj) {
-                    adjFp++;
-                }
+        for (Edge edge : this.est.getEdges()) {
+            allUnoriented.add(Edges.undirectedEdge(edge.getNode1(), edge.getNode2()));
+        }
 
-                if (truthAdj && !estAdj) {
-                    adjFn++;
-                }
+        for (Edge edge : allUnoriented) {
+            if (this.est.isAdjacentTo(edge.getNode1(), edge.getNode2()) &&
+                    !this.truth.isAdjacentTo(edge.getNode1(), edge.getNode2())) {
+                adjFp++;
+            }
 
-                if (truthAdj && estAdj) {
-                    adjTp++;
-                }
+            if (this.truth.isAdjacentTo(edge.getNode1(), edge.getNode2()) &&
+                    !this.est.isAdjacentTo(edge.getNode1(), edge.getNode2())) {
+                adjFn++;
+            }
 
-                if (!truthAdj && !estAdj) {
-                    adjTn++;
-                }
+            if (this.truth.isAdjacentTo(edge.getNode1(), edge.getNode2()) &&
+                    this.est.isAdjacentTo(edge.getNode1(), edge.getNode2())) {
+                adjTp++;
             }
         }
+
+        int allEdges = this.truth.getNumNodes() * (this.truth.getNumNodes() - 1) / 2;
+
+        adjTn = allEdges - adjFn;
     }
 
     public int getAdjTp() {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/AncestorConfusion.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/AncestorConfusion.java
deleted file mode 100644
index dd7ac6c4..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/AncestorConfusion.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package edu.cmu.tetrad.algcomparison.statistic.utils;
-
-import edu.cmu.tetrad.graph.*;
-
-import java.util.List;
-
-/**
- * A confusion matrix for ancestor relationships.
- *
- * @author jdramsey, rubens (November, 2016)
- */
-public class AncestorConfusion {
-
-    private int fp;
-    private int fn;
-    private int tp;
-    private int tn;
-
-    public AncestorConfusion(Graph truth, Graph est) {
-        est = GraphUtils.replaceNodes(est, truth.getNodes());
-        truth = GraphUtils.replaceNodes(truth, est.getNodes());
-
-
-        List<Node> nodes = truth.getNodes();
-
-        for (int i = 0; i < nodes.size(); i++) {
-            for (int j = 0; j < nodes.size(); j++){
-                if (i == j) continue;
-
-                boolean t = truth.isAncestorOf(nodes.get(i), nodes.get(j));
-                boolean e = est.isAncestorOf(nodes.get(i), nodes.get(j));
-
-                if (t & !e) setFn(getFn() + 1);
-                if (e & !t) setFp(getFp() + 1);
-                if (t & e) setTp(getTp() + 1);
-                if (!t & !e) setTn(getTn() + 1);
-            }
-        }
-    }
-
-    public int getFp() {
-        return fp;
-    }
-
-    public void setFp(int fp) {
-        this.fp = fp;
-    }
-
-    public int getFn() {
-        return fn;
-    }
-
-    public void setFn(int fn) {
-        this.fn = fn;
-    }
-
-    public int getTp() {
-        return tp;
-    }
-
-    public void setTp(int tp) {
-        this.tp = tp;
-    }
-
-    public int getTn() {
-        return tn;
-    }
-
-    public void setTn(int tn) {
-        this.tn = tn;
-    }
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/ArrowConfusion.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/ArrowConfusion.java
index dcfcf301..4b043590 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/ArrowConfusion.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/ArrowConfusion.java
@@ -1,6 +1,9 @@
 package edu.cmu.tetrad.algcomparison.statistic.utils;
 
-import edu.cmu.tetrad.graph.*;
+import edu.cmu.tetrad.graph.Edge;
+import edu.cmu.tetrad.graph.Endpoint;
+import edu.cmu.tetrad.graph.Graph;
+import edu.cmu.tetrad.graph.GraphUtils;
 
 import java.util.List;
 
@@ -76,7 +79,6 @@ public class ArrowConfusion {
 
             if (edges2.size() == 1) {
                 edge2 = edges2.get(0);
-                if (Edges.isUndirectedEdge(edge2)) continue;
             } else {
                 edge2 = this.truth.getDirectedEdge(edge.getNode1(), edge.getNode2());
             }
@@ -174,7 +176,6 @@ public class ArrowConfusion {
 
             if (edges2.size() == 1) {
                 edge2 = edges2.get(0);
-                if (Edges.isUndirectedEdge(edge2)) continue;
             } else {
                 edge2 = this.truth.getDirectedEdge(edge.getNode1(), edge.getNode2());
             }
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/ArrowConfusionIgnore2c.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/ArrowConfusionIgnore2c.java
deleted file mode 100644
index b75c2ea4..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/algcomparison/statistic/utils/ArrowConfusionIgnore2c.java
+++ /dev/null
@@ -1,318 +0,0 @@
-package edu.cmu.tetrad.algcomparison.statistic.utils;
-
-import edu.cmu.tetrad.graph.*;
-
-import java.util.List;
-
-/**
- * A confusion matrix for arrows--i.e. TP, FP, TN, FN for counts of arrow endpoints.
- * A true positive arrow is counted for X*->Y in the estimated graph if X is not adjacent
- * to Y or X--Y or X<--Y.
- *
- * @author jdramsey, rubens (November, 2016)
- */
-public class ArrowConfusionIgnore2c {
-
-    private Graph truth;
-    private Graph est;
-    private int arrowsTp;
-    private int arrowsTpc;
-    private int arrowsFp;
-    private int arrowsFpc;
-    private int arrowsFn;
-    private int arrowsFnc;
-    private int arrowsTn;
-    private int arrowsTnc;
-    private int TCtp;
-    private int TCfn;
-    private int TCfp;
-
-    public ArrowConfusionIgnore2c(Graph truth, Graph est) {
-        this.truth = truth;
-        this.est = est;
-        arrowsTp = 0;
-        arrowsTpc = 0;
-        arrowsFp = 0;
-        arrowsFpc = 0;
-        arrowsFn = 0;
-        arrowsFnc = 0;
-        TCtp = 0; //for the two-cycle accuracy
-        TCfn = 0;
-        TCfp = 0;
-
-
-        this.est = GraphUtils.replaceNodes(est, truth.getNodes());
-        this.truth = GraphUtils.replaceNodes(truth, est.getNodes());
-
-
-        // Get edges from the true Graph to compute TruePositives, TrueNegatives and FalseNeagtives
-        //    System.out.println(this.truth.getEdges());
-
-        for (Edge edge : this.truth.getEdges()) {
-
-            List<Edge> edges1 = this.est.getEdges(edge.getNode1(), edge.getNode2());
-            Edge edge1;
-
-            if (edges1.size() == 1) {
-                edge1 = edges1.get(0);
-            } else {
-                edge1 = this.est.getDirectedEdge(edge.getNode1(), edge.getNode2());
-            }
-
-            //      System.out.println(edge1 + "(est)");
-
-            Endpoint e1Est = null;
-            Endpoint e2Est = null;
-
-            if (edge1 != null) {
-                e1Est = edge1.getProximalEndpoint(edge.getNode1());
-                e2Est = edge1.getProximalEndpoint(edge.getNode2());
-            }
-            //      System.out.println(e1Est);
-            //      System.out.println(e2Est);
-
-            List<Edge> edges2 = this.truth.getEdges(edge.getNode1(), edge.getNode2());
-            Edge edge2;
-
-            if (edges2.size() == 1) {
-                edge2 = edges2.get(0);
-                if (Edges.isUndirectedEdge(edge2)) continue;
-            } else {
-                edge2 = this.truth.getDirectedEdge(edge.getNode1(), edge.getNode2());
-            }
-
-            //       System.out.println(edge2 + "(truth)");
-
-            Endpoint e1True = null;
-            Endpoint e2True = null;
-
-            if (edge2 != null) {
-                e1True = edge2.getProximalEndpoint(edge.getNode1());
-                e2True = edge2.getProximalEndpoint(edge.getNode2());
-            }
-            //       System.out.println(e1True);
-            //       System.out.println(e2True);
-
-
-            if (e1True == Endpoint.ARROW && e1Est != Endpoint.ARROW) {
-                arrowsFn++;
-            }
-
-            if (e2True == Endpoint.ARROW && e2Est != Endpoint.ARROW) {
-                arrowsFn++;
-            }
-
-            if (e1True == Endpoint.ARROW && e1Est != Endpoint.ARROW && edge1 != null && edge2 != null) {
-                arrowsFnc = getArrowsFnc() + 1;
-            }
-
-            if (e2True == Endpoint.ARROW && e2Est != Endpoint.ARROW && edge1 != null && edge2 != null) {
-                arrowsFnc = getArrowsFnc() + 1;
-            }
-
-
-            if (e1True == Endpoint.ARROW && e1Est == Endpoint.ARROW) {
-                arrowsTp++;
-            }
-
-            if (e2True == Endpoint.ARROW && e2Est == Endpoint.ARROW) {
-                arrowsTp++;
-            }
-
-            if (e1True == Endpoint.ARROW && e1Est == Endpoint.ARROW && edge1 != null && edge2 != null) {
-                arrowsTpc = getArrowsTpc() + 1;
-            }
-
-            if (e2True == Endpoint.ARROW && e2Est == Endpoint.ARROW && edge1 != null && edge2 != null) {
-                arrowsTpc = getArrowsTpc() + 1;
-            }
-
-            if (e1True != Endpoint.ARROW && e1Est != Endpoint.ARROW) {
-                arrowsTn++;
-            }
-
-            if (e2True != Endpoint.ARROW && e2Est != Endpoint.ARROW) {
-                arrowsTn++;
-            }
-
-            if (e1True != Endpoint.ARROW && e1Est != Endpoint.ARROW && edge1 != null && edge2 != null) {
-                arrowsTnc = getArrowsTnc() + 1;
-            }
-
-            if (e2True != Endpoint.ARROW && e2Est != Endpoint.ARROW && edge1 != null && edge2 != null) {
-                arrowsTnc = getArrowsTnc() + 1;
-            }
-        }
-// Get edges from the estimated graph to compute only FalsePositives
-        // System.out.println(this.est.getEdges());
-
-        for (Edge edge : this.est.getEdges()) {
-
-            List<Edge> edges1 = this.est.getEdges(edge.getNode1(), edge.getNode2());
-            Edge edge1;
-
-            if (edges1.size() == 1) {
-                edge1 = edges1.get(0);
-            } else {
-                edge1 = this.est.getDirectedEdge(edge.getNode1(), edge.getNode2());
-            }
-            //      System.out.println(edge1 + "(est)");
-
-            Endpoint e1Est = null;
-            Endpoint e2Est = null;
-
-            if (edge1 != null) {
-                e1Est = edge1.getProximalEndpoint(edge.getNode1());
-                e2Est = edge1.getProximalEndpoint(edge.getNode2());
-            }
-            //       System.out.println(e1Est);
-            //       System.out.println(e2Est);
-
-
-            List<Edge> edges2 = this.truth.getEdges(edge.getNode1(), edge.getNode2());
-            Edge edge2;
-
-            if (edges2.size() == 1) {
-                edge2 = edges2.get(0);
-                if (Edges.isUndirectedEdge(edge2)) continue;
-            } else {
-                edge2 = this.truth.getDirectedEdge(edge.getNode1(), edge.getNode2());
-            }
-
-            //          System.out.println(edge2 + "(truth)");
-
-            Endpoint e1True = null;
-            Endpoint e2True = null;
-
-            if (edge2 != null) {
-                e1True = edge2.getProximalEndpoint(edge.getNode1());
-                e2True = edge2.getProximalEndpoint(edge.getNode2());
-            }
-            //          System.out.println(e1True);
-            //          System.out.println(e2True);
-
-
-            if (e1Est == Endpoint.ARROW && e1True != Endpoint.ARROW && est.getEdges(edge.getNode1(), edge.getNode2()).size() == 1 && truth.getEdges(edge.getNode1(), edge.getNode2()).size() > 0) {
-                arrowsFp++;
-            }
-
-            if (e2Est == Endpoint.ARROW && e2True != Endpoint.ARROW && est.getEdges(edge.getNode2(), edge.getNode1()).size() == 1 && truth.getEdges(edge.getNode2(), edge.getNode1()).size() > 0) {
-                arrowsFp++;
-            }
-
-            if (e1Est == Endpoint.ARROW && e1True != Endpoint.ARROW && edge1 != null && edge2 != null) {
-                arrowsFpc = getArrowsFpc() + 1;
-            }
-
-            if (e2Est == Endpoint.ARROW && e2True != Endpoint.ARROW && edge1 != null && edge2 != null) {
-                arrowsFpc = getArrowsFpc() + 1;
-            }
-
-        }
-
-
-        // test for 2-cycle
-        //Set<Edge> allOriented = new HashSet<>();
-        //allOriented.addAll(this.truth.getEdges());
-        //allOriented.addAll(this.est.getEdges());
-
-        for (Edge edge : this.truth.getEdges()) {
-
-
-            List<Edge> TwoCycle1 = this.truth.getEdges(edge.getNode1(), edge.getNode2());
-            List<Edge> TwoCycle2 = this.est.getEdges(edge.getNode1(), edge.getNode2());
-
-            if (TwoCycle1.size() == 2 && TwoCycle2.size() == 2) {
-                //              System.out.println("2-cycle correctly inferred " + TwoCycle1);
-                TCtp++;
-            }
-
-            if (TwoCycle1.size() == 2 && TwoCycle2.size() != 2) {
-                //             System.out.println("2-cycle not inferred " + TwoCycle1);
-                TCfn++;
-            }
-        }
-
-        for (Edge edge : this.est.getEdges()) {
-
-            List<Edge> TwoCycle1 = this.truth.getEdges(edge.getNode1(), edge.getNode2());
-            List<Edge> TwoCycle2 = this.est.getEdges(edge.getNode1(), edge.getNode2());
-
-            if (TwoCycle1.size() != 2 && TwoCycle2.size() == 2) {
-                //              System.out.println("2-cycle falsely inferred" + TwoCycle2);
-                TCfp++;
-            }
-        }
-
-  /*      System.out.println(arrowsTp);
-        System.out.println(arrowsTn);
-        System.out.println(arrowsFn);
-        System.out.println(arrowsFp);
-*/
-        //divide by 2, the 2cycle accuracy is duplicated due to how getEdges is used
-        TCtp = TCtp / 2;
-        TCfn = TCfn / 2;
-        TCfp = TCfp / 2;
-        //       System.out.println(TCtp);
-        //       System.out.println(TCfn);
-        //       System.out.println(TCfp);
-
-    }
-
-
-    public int getArrowsTp() {
-        return arrowsTp;
-    }
-
-    public int getArrowsFp() {
-        return arrowsFp;
-    }
-
-    public int getArrowsFn() {
-        return arrowsFn;
-    }
-
-    public int getArrowsTn() {
-        return arrowsTn;
-    }
-
-    public int getTwoCycleTp() {
-        return TCtp;
-    }
-
-    public int getTwoCycleFp() {
-        return TCfp;
-    }
-
-    public int getTwoCycleFn() {
-        return TCfn;
-    }
-
-    /**
-     * Two positives for common edges.
-     */
-    public int getArrowsTpc() {
-        return arrowsTpc;
-    }
-
-    /**
-     * False positives for common edges.
-     */
-    public int getArrowsFpc() {
-        return arrowsFpc;
-    }
-
-    /**
-     * False negatives for common edges.
-     */
-    public int getArrowsFnc() {
-        return arrowsFnc;
-    }
-
-    /**
-     * True Negatives for common edges.
-     */
-    public int getArrowsTnc() {
-        return arrowsTnc;
-    }
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/annotation/AlgType.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/annotation/AlgType.java
index 6f3ca113..d80ce7b1 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/annotation/AlgType.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/annotation/AlgType.java
@@ -4,11 +4,11 @@ package edu.cmu.tetrad.annotation;
  * Author : Jeremy Espino MD Created 6/30/17 10:36 AM
  */
 public enum AlgType {
-    forbid_latent_common_causes, // PC_All, PcStableMax, FGES, IMaGES_Discrete, IMaGES_Continuous, TsIMaGES, FANG, EFANG
+    forbid_latent_common_causes, // PC_All, PcStableMax, FGES, IMaGES_Discrete, IMaGES_Continuous, TsImages, FANG, EFANG
     allow_latent_common_causes, // FCI, RFCI, GFCI, TsFCI, TsGFCI
     /*DAG, */
-    search_for_Markov_blankets, // FGES-MB, MBFS
+    search_for_Markov_blankets, // FgesMb, MBFS
     produce_undirected_graphs, // FAS, MGM, GLASSO
     orient_pairwise, // EB, R1, R2, R3, R4, RSkew, RSkewE, Skew, SkewE
-    search_for_structure_over_latents // BPC, FOFC, FTFC
+    search_for_structure_over_latents // Bpc, Fofc, Ftfc
 }
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/annotation/Algorithm.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/annotation/Algorithm.java
index 04d1c413..924e8e3d 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/annotation/Algorithm.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/annotation/Algorithm.java
@@ -39,6 +39,8 @@ public @interface Algorithm {
 
     String command();
 
+    String description() default "";
+
     AlgType algoType();
 
 }
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/AbstractExpressionDescriptor.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/AbstractExpressionDescriptor.java
index 93751ab2..bc72b302 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/AbstractExpressionDescriptor.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/AbstractExpressionDescriptor.java
@@ -124,14 +124,14 @@ abstract class AbstractExpressionDescriptor implements ExpressionDescriptor {
             // create signature string.
             if (!commulative) {
                 this.signature += "(";
-                for (int i = 1; i < arguments.length; i++) {
-                    if (i != 1) {
+                for (int i = 0; i < arguments.length; i++) {
+                    if (i != 0) {
                         this.signature += ", ";
                     }
                     this.signature += arguments[i];
                 }
                 if (unlimited) {
-                    if (arguments.length != 1) {
+                    if (arguments.length != 0) {
                         this.signature += ", ";
                     }
                     this.signature += "...";
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/ExpressionManager.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/ExpressionManager.java
index 33c6912c..f381cc04 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/ExpressionManager.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/ExpressionManager.java
@@ -142,7 +142,6 @@ public class ExpressionManager {
         descriptors.add(new MaxExpressionDescriptor());
         descriptors.add(new MinExpressionDescriptor());
         descriptors.add(new SignumExpressionDescriptor());
-        descriptors.add(new BoundExpressionDescriptor());
 
         descriptors.add(new AndExpressionDescriptor());
         descriptors.add(new OrExpressionDescriptor());
@@ -322,36 +321,6 @@ public class ExpressionManager {
         }
     }
 
-    private static class BoundExpressionDescriptor extends AbstractExpressionDescriptor {
-        static final long serialVersionUID = 23L;
-
-
-        public BoundExpressionDescriptor() {
-            super("Bound", "bound", Position.PREFIX, false);
-        }
-
-
-        public Expression createExpression(Expression... expressions) throws ExpressionInitializationException {
-            if (expressions.length != 3) {
-                throw new ExpressionInitializationException("Bound must have three arguments.");
-            }
-            return new AbstractExpression("signum", Position.PREFIX, expressions) {
-                static final long serialVersionUID = 23L;
-
-                public double evaluate(Context context) {
-                    List<Expression> expressions = getExpressions();
-                    final double x = expressions.get(0).evaluate(context);
-                    final double low = expressions.get(1).evaluate(context);
-                    final double high = expressions.get(2).evaluate(context);
-
-                    if (x < low) return low;
-                    else if (x > high) return high;
-                    else return x;
-                }
-            };
-        }
-    }
-
     /**
      * Cosine
      */
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/ExpressionSignature.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/ExpressionSignature.java
index d03304f6..6c366a23 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/ExpressionSignature.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/calculator/expression/ExpressionSignature.java
@@ -33,7 +33,7 @@ public interface ExpressionSignature extends TetradSerializable {
 
 
     /**
-     * @return the signature as a string.
+     * @return the sigature as a string.
      */
     String getSignature();
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/cmd/TetradCmd.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/cmd/TetradCmd.java
new file mode 100644
index 00000000..2966aac5
--- /dev/null
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/cmd/TetradCmd.java
@@ -0,0 +1,1074 @@
+///////////////////////////////////////////////////////////////////////////////
+// For information as to what this class does, see the Javadoc, below.       //
+// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
+// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
+// Ramsey, and Clark Glymour.                                                //
+//                                                                           //
+// This program is free software; you can redistribute it and/or modify      //
+// it under the terms of the GNU General Public License as published by      //
+// the Free Software Foundation; either version 2 of the License, or         //
+// (at your option) any later version.                                       //
+//                                                                           //
+// This program is distributed in the hope that it will be useful,           //
+// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
+// GNU General Public License for more details.                              //
+//                                                                           //
+// You should have received a copy of the GNU General Public License         //
+// along with this program; if not, write to the Free Software               //
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
+///////////////////////////////////////////////////////////////////////////////
+
+package edu.cmu.tetrad.cmd;
+
+import edu.cmu.tetrad.bayes.BayesIm;
+import edu.cmu.tetrad.bayes.BayesPm;
+import edu.cmu.tetrad.bayes.MlBayesEstimator;
+import edu.cmu.tetrad.data.*;
+import edu.cmu.tetrad.graph.Dag;
+import edu.cmu.tetrad.graph.Graph;
+import edu.cmu.tetrad.graph.GraphUtils;
+import edu.cmu.tetrad.graph.Node;
+import edu.cmu.tetrad.search.*;
+import edu.cmu.tetrad.util.RandomUtil;
+import edu.cmu.tetrad.util.TetradLogger;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Runs several algorithm from Tetrad. Documentation is available
+ * in the wiki of the Tetrad project on GitHub. This will be replaced by
+ * the package tetrad-cli.
+ *
+ * @author Joseph Ramsey
+ */
+public final class TetradCmd {
+    private String algorithmName;
+    private String dataFileName;
+    private String knowledgeFileName;
+    private String dataTypeName;
+    private String graphXmlFilename;
+    private String graphTxtFilename;
+    private String initialGraphTxtFilename;
+    private int depth = -1;
+    private double significance = 0.05;
+    private DataSet data;
+    private ICovarianceMatrix covarianceMatrix;
+    private String outputStreamPath;
+    private PrintStream out = System.out;
+    private String seed;
+    private String numNodes = "5";
+    private String numEdges = "5";
+    private IKnowledge knowledge = new Knowledge2();
+    private boolean whitespace = false;
+    private boolean verbose = false;
+    private double samplePrior = 1.0;
+    private double structurePrior = 1.0;
+    private double penaltyDiscount = 1.0;
+    private TestType testType = TestType.TETRAD_DELTA;
+    private Graph initialGraph;
+    private boolean rfciUsed = false;
+    private boolean nodsep = false;
+    private boolean useCovariance = true;
+    private boolean silent = false;
+    private boolean useConditionalCorrelation = false;
+
+    public TetradCmd(String[] argv) {
+        readArguments(new StringArrayTokenizer(argv));
+
+        setOutputStream();
+//        loadDataSelect();
+        runAlgorithm();
+
+        if (out != System.out) {
+            out.close();
+        }
+    }
+
+    private void setOutputStream() {
+        if (outputStreamPath == null) {
+            return;
+        }
+
+        File file = new File(outputStreamPath);
+
+        try {
+            out = new PrintStream(new FileOutputStream(file));
+        } catch (FileNotFoundException e) {
+            throw new IllegalStateException(
+                    "Could not create a logfile at location " +
+                            file.getAbsolutePath()
+            );
+        }
+    }
+
+    private void readArguments(StringArrayTokenizer tokenizer) {
+        while (tokenizer.hasToken()) {
+            String token = tokenizer.nextToken();
+
+            if ("-data".equalsIgnoreCase(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-data' tag must be followed " +
+                                    "by an argument indicating the path to the data " +
+                                    "file."
+                    );
+                }
+
+                dataFileName = argument;
+                useCovariance = false;
+            } else if ("-covariance".equalsIgnoreCase(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-data' tag must be followed " +
+                                    "by an argument indicating the path to the data " +
+                                    "file."
+                    );
+                }
+
+                dataFileName = argument;
+                useCovariance = true;
+                dataTypeName = "continuous";
+            } else if ("-datatype".equalsIgnoreCase(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-datatype' tag must be followed " +
+                                    "by either 'discrete' or 'continuous'."
+                    );
+                }
+
+                dataTypeName = argument;
+            } else if ("-algorithm".equalsIgnoreCase(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-algorithm' tag must be followed " +
+                                    "by an algorithm name."
+                    );
+                }
+
+                algorithmName = argument;
+            } else if ("-depth".equalsIgnoreCase(token)) {
+                try {
+                    String argument = tokenizer.nextToken();
+
+                    if (argument == null) {
+                        throw new NumberFormatException();
+                    }
+
+                    this.depth = Integer.parseInt(argument);
+
+                    if (this.depth < -1) {
+                        throw new IllegalArgumentException(
+                                "'depth' must be followed " +
+                                        "by an integer >= -1 (-1 means unlimited)."
+                        );
+                    }
+                } catch (NumberFormatException e) {
+                    throw new IllegalArgumentException(
+                            "'depth' must be followed " +
+                                    "by an integer >= -1 (-1 means unlimited)."
+                    );
+                }
+            } else if ("-significance".equalsIgnoreCase(token)) {
+                try {
+                    String argument = tokenizer.nextToken();
+
+                    if (argument.startsWith("-")) {
+                        throw new NumberFormatException();
+                    }
+
+                    this.significance = Double.parseDouble(argument);
+                } catch (NumberFormatException e) {
+                    throw new IllegalArgumentException(
+                            "'-significance' must be " +
+                                    "followed by a number in the range [0.0, 1.0]."
+                    );
+                }
+            } else if ("-verbose".equalsIgnoreCase(token)) {
+                this.verbose = true;
+            } else if ("-outfile".equalsIgnoreCase(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-outfile' tag must be " +
+                                    "followed  by an argument indicating the path to the " +
+                                    "data file."
+                    );
+                }
+
+                outputStreamPath = argument;
+            } else if ("-seed".equalsIgnoreCase(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "-seed must be followed by an integer (long) value."
+                    );
+                }
+
+                seed = argument;
+            } else if ("-numNodes".equals(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "-numNodes must be followed by an integer >= 3.");
+                }
+
+                numNodes = argument;
+            } else if ("-numEdges".equals(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "-numEdges must be followed by an integer >= 0.");
+                }
+
+                numEdges = argument;
+            } else if ("-knowledge".equals(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-knowledge' tag must be followed " +
+                                    "by an argument indicating the path to the knowledge " +
+                                    "file."
+                    );
+                }
+
+                knowledgeFileName = argument;
+            } else if ("-testtype".equals(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-testType' tag must be followed by 'delta' or 'wishart'");
+                }
+
+                switch (argument) {
+                    case "delta":
+                        testType = TestType.TETRAD_DELTA;
+                        break;
+                    case "wishart":
+                        testType = TestType.TETRAD_WISHART;
+                        break;
+                    default:
+                        throw new IllegalArgumentException("Expecting 'delta' or 'wishart'.");
+                }
+            } else if ("-graphxml".equals(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-graphxml' tag must be followed " +
+                                    "by an argument indicating the path to the file where the graph xml output " +
+                                    "is to be written."
+                    );
+                }
+
+                graphXmlFilename = argument;
+            } else if ("-graphtxt".equals(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-graphtxt' tag must be followed " +
+                                    "by an argument indicating the path to the file where the graph txt output " +
+                                    "is to be written."
+                    );
+                }
+
+                graphTxtFilename = argument;
+            } else if ("-initialgraphtxt".equals(token)) {
+                String argument = tokenizer.nextToken();
+
+                if (argument.startsWith("-")) {
+                    throw new IllegalArgumentException(
+                            "'-initialgraphtxt' tag must be followed " +
+                                    "by an argument indicating the path to the file where the graph txt output " +
+                                    "is to be written."
+                    );
+                }
+
+                initialGraphTxtFilename = argument;
+            } else if ("-whitespace".equals(token)) {
+                whitespace = true;
+            } else if ("-sampleprior".equals(token)) {
+                try {
+                    String argument = tokenizer.nextToken();
+
+                    if (argument.startsWith("-")) {
+                        throw new IllegalArgumentException(
+                                "'-sampleprior' tag must be followed " +
+                                        "by an argument indicating the BDEU structure prior."
+                        );
+                    }
+
+                    samplePrior = Double.parseDouble(argument);
+
+                    if (samplePrior < 0) {
+                        throw new IllegalArgumentException("Sample prior must be >= 0.");
+                    }
+                } catch (NumberFormatException e) {
+                    throw new IllegalArgumentException("Not a number.");
+                }
+            } else if ("-structureprior".equals(token)) {
+                try {
+                    String argument = tokenizer.nextToken();
+
+                    if (argument.startsWith("-")) {
+                        throw new IllegalArgumentException(
+                                "'-structureprior' tag must be followed " +
+                                        "by an argument indicating the BDEU sample prior."
+                        );
+                    }
+
+                    structurePrior = Double.parseDouble(argument);
+
+                    if (structurePrior < 0) {
+                        throw new IllegalArgumentException("Structure prior must be >= 0.");
+                    }
+                } catch (NumberFormatException e) {
+                    throw new IllegalArgumentException("Not a number.");
+                }
+            } else if ("-penaltydiscount".equals(token)) {
+                try {
+                    String argument = tokenizer.nextToken();
+
+                    if (argument.startsWith("-")) {
+                        throw new IllegalArgumentException(
+                                "'-penaltydiscount' tag must be followed " +
+                                        "by an argument indicating penalty discount."
+                        );
+                    }
+
+                    penaltyDiscount = Double.parseDouble(argument);
+
+                    if (penaltyDiscount <= 0) {
+                        throw new IllegalArgumentException("Penalty discount must be > 0.");
+                    }
+                } catch (NumberFormatException e) {
+                    throw new IllegalArgumentException("Not a number.");
+                }
+            } else if ("-rfci".equalsIgnoreCase(token)) {
+                this.rfciUsed = true;
+            } else if ("-nodsep".equalsIgnoreCase(token)) {
+                this.nodsep = true;
+            } else if ("-silent".equalsIgnoreCase(token)) {
+                this.silent = true;
+            } else if ("-condcorr".equalsIgnoreCase(token)) {
+                this.useConditionalCorrelation = true;
+            } else {
+                throw new IllegalArgumentException(
+                        "Unexpected argument: " + token);
+            }
+
+        }
+    }
+
+    private void loadData() {
+        if (dataFileName == null) {
+            throw new IllegalStateException("No data file was specified.");
+        }
+
+        if (dataTypeName == null) {
+            throw new IllegalStateException(
+                    "No data type (continuous/discrete) " + "was specified.");
+        }
+
+        outPrint("Loading data from " + dataFileName + ".");
+
+//        if ("continuous".equalsIgnoreCase(dataTypeName)) {
+//            outPrint("Data type = continuous.");
+//        } else if ("discrete".equalsIgnoreCase(dataTypeName)) {
+//            outPrint("Data type = discrete.");
+//        } else {
+//            throw new IllegalStateException(
+//                    "Data type was expected to be either " +
+//                            "'continuous' or 'discrete'."
+//            );
+//        }
+
+        File file = new File(dataFileName);
+
+        try {
+            try {
+//                    List<Node> knownVariables = null;
+//                    RectangularDataSet data = DataLoaders.loadDiscreteData(file,
+//                            DelimiterType.WHITESPACE_OR_COMMA, "//",
+//                            knownVariables);
+
+                DataReader reader = new DataReader();
+                reader.setMaxIntegralDiscrete(Integer.MAX_VALUE);
+
+                if (whitespace) {
+                    reader.setDelimiter(DelimiterType.WHITESPACE);
+                } else {
+                    reader.setDelimiter(DelimiterType.TAB);
+                }
+
+                if (useCovariance) {
+                    ICovarianceMatrix cov = reader.parseCovariance(file);
+                    this.covarianceMatrix = cov;
+                } else {
+                    DataSet data = reader.parseTabular(file);
+                    outPrint("# variables = " + data.getNumColumns() +
+                            ", # cases = " + data.getNumRows());
+                    this.data = data;
+                }
+
+//                systemPrint(data);
+
+                if (initialGraphTxtFilename != null) {
+                    initialGraph = GraphUtils.loadGraphTxt(new File(initialGraphTxtFilename));
+                }
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        } catch (RuntimeException e) {
+            throw new IllegalStateException(
+                    "Could not load file at " + file.getAbsolutePath());
+        }
+    }
+
+    private void loadKnowledge() {
+        if (knowledgeFileName == null) {
+            throw new IllegalStateException("No data file was specified.");
+        }
+
+        try {
+            File knowledgeFile = new File(knowledgeFileName);
+
+            CharArrayWriter writer = new CharArrayWriter();
+
+            FileReader fr = new FileReader(knowledgeFile);
+            int i;
+
+            while ((i = fr.read()) != -1) {
+                writer.append((char) i);
+            }
+
+            DataReader reader = new DataReader();
+            char[] chars = writer.toCharArray();
+
+            String x = new String(chars);
+            systemPrint(x);
+
+            this.knowledge = reader.parseKnowledge(chars);
+        } catch (Exception e) {
+            throw new RuntimeException("Couldn't read knowledge.");
+        }
+    }
+
+    private void systemPrint(String x) {
+        if (!silent) {
+            System.out.println(x);
+        }
+    }
+
+    private void outPrint(String x) {
+        if (!silent) {
+            out.println(x);
+        }
+    }
+
+    private void runAlgorithm() {
+
+        if (dataFileName != null) {
+            loadData();
+        }
+
+        if (knowledgeFileName != null) {
+            loadKnowledge();
+        }
+
+        if ("pc".equalsIgnoreCase(algorithmName)) {
+            runPc();
+        } else if ("fask".equalsIgnoreCase(algorithmName)) {
+            runFask();
+        } else if ("pc.stable".equalsIgnoreCase(algorithmName)) {
+            runPcStable();
+        } else if ("cpc".equalsIgnoreCase(algorithmName)) {
+            runCpc();
+        } else if ("fci".equalsIgnoreCase(algorithmName)) {
+            runFci();
+        } else if ("cfci".equalsIgnoreCase(algorithmName)) {
+            runCfci();
+        } else if ("ccd".equalsIgnoreCase(algorithmName)) {
+            runCcd();
+        } else if ("fges".equalsIgnoreCase(algorithmName)) {
+            runFges();
+        } else if ("bayes_est".equalsIgnoreCase(algorithmName)) {
+            runBayesEst();
+        } else if ("fofc".equalsIgnoreCase(algorithmName)) {
+            runFofc();
+        } else if ("randomDag".equalsIgnoreCase(algorithmName)) {
+            printRandomDag();
+        } else {
+            TetradLogger.getInstance().reset();
+            TetradLogger.getInstance().removeOutputStream(System.out);
+            throw new IllegalStateException("No algorithm was specified.");
+        }
+
+//        TetradLogger.getInstance().setForceLog(false);
+        TetradLogger.getInstance().removeOutputStream(System.out);
+
+    }
+
+    private void printRandomDag() {
+        if (seed != null) {
+            long _seed;
+
+            try {
+                _seed = Long.parseLong(seed);
+            } catch (NumberFormatException e) {
+                throw new RuntimeException("Seed must be an integer (actually, long) value.");
+            }
+
+            RandomUtil.getInstance().setSeed(_seed);
+        }
+
+        int _numNodes;
+
+        try {
+            _numNodes = Integer.parseInt(numNodes);
+        } catch (NumberFormatException e) {
+            throw new RuntimeException("numNodes must be an integer.");
+        }
+
+        int _numEdges;
+
+        try {
+            _numEdges = Integer.parseInt(numEdges);
+        } catch (NumberFormatException e) {
+            throw new RuntimeException("numEdges must be an integer.");
+        }
+
+        List<Node> nodes = new ArrayList<>();
+
+        for (int i = 0; i < _numNodes; i++) {
+            nodes.add(new ContinuousVariable("X" + (i + 1)));
+        }
+
+        Dag dag;
+
+        do {
+            dag = new Dag(GraphUtils.randomGraph(nodes, 0, _numEdges, 30,
+                    15, 15, false));
+        } while (dag.getNumEdges() < _numEdges);
+
+        String xml = GraphUtils.graphToXml(dag);
+        systemPrint(xml);
+    }
+
+    private void runPc() {
+        if (this.data == null && this.covarianceMatrix == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (verbose) {
+            systemPrint("PC");
+            systemPrint(getKnowledge().toString());
+            systemPrint(getVariables().toString());
+
+            TetradLogger.getInstance().addOutputStream(System.out);
+
+            TetradLogger.getInstance().setEventsToLog("info", "independencies", "knowledgeOrientations",
+                    "impliedOrientations", "graph");
+//            TetradLogger.getInstance().setForceLog(true);
+
+            TetradLogger.getInstance().log("info", "Testing it.");
+        }
+
+        Pc pc = new Pc(getIndependenceTest());
+        pc.setDepth(getDepth());
+        pc.setKnowledge(getKnowledge());
+        pc.setVerbose(verbose);
+
+        // Convert back to Graph..
+        Graph resultGraph = pc.search();
+
+        // PrintUtil outputStreamPath problem and graphs.
+        outPrint("\nResult graph:");
+        outPrint(resultGraph.toString());
+
+        writeGraph(resultGraph);
+    }
+
+    private void runFask() {
+        if (this.data == null && this.covarianceMatrix == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (verbose) {
+            systemPrint("FASK");
+            systemPrint(getKnowledge().toString());
+            systemPrint(getVariables().toString());
+
+            TetradLogger.getInstance().addOutputStream(System.out);
+
+            TetradLogger.getInstance().setEventsToLog("info", "independencies", "knowledgeOrientations",
+                    "impliedOrientations", "graph");
+//            TetradLogger.getInstance().setForceLog(true);
+
+            TetradLogger.getInstance().log("info", "Testing it.");
+        }
+
+        Fask pc = new Fask(data, new SemBicScore(new CovarianceMatrixOnTheFly(data)));
+        pc.setAlpha(significance);
+        pc.setPenaltyDiscount(penaltyDiscount);
+        pc.setDepth(depth);
+        pc.setKnowledge(getKnowledge());
+
+        // Convert back to Graph..
+        Graph resultGraph = pc.search();
+
+        // PrintUtil outputStreamPath problem and graphs.
+        outPrint("\nResult graph:");
+        outPrint(resultGraph.toString());
+
+        writeGraph(resultGraph);
+    }
+
+    private void runPcStable() {
+        if (this.data == null && this.covarianceMatrix == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (verbose) {
+            systemPrint("PC-Stable");
+            systemPrint(getKnowledge().toString());
+            systemPrint(getVariables().toString());
+
+            TetradLogger.getInstance().addOutputStream(System.out);
+
+            TetradLogger.getInstance().setEventsToLog("info", "independencies", "knowledgeOrientations",
+                    "impliedOrientations", "graph");
+//            TetradLogger.getInstance().setForceLog(true);
+
+            TetradLogger.getInstance().log("info", "Testing it.");
+        }
+
+        PcStable pc = new PcStable(getIndependenceTest());
+        pc.setDepth(getDepth());
+        pc.setKnowledge(getKnowledge());
+        pc.setVerbose(verbose);
+
+        // Convert back to Graph..
+        Graph resultGraph = pc.search();
+
+        // PrintUtil outputStreamPath problem and graphs.
+        outPrint("\nResult graph:");
+        outPrint(resultGraph.toString());
+
+        writeGraph(resultGraph);
+    }
+
+    private void runFges() {
+        if (this.data == null && this.covarianceMatrix == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (verbose) {
+            systemPrint("FGES");
+            systemPrint(getKnowledge().toString());
+            systemPrint(getVariables().toString());
+
+            TetradLogger.getInstance().addOutputStream(System.out);
+
+            TetradLogger.getInstance().setEventsToLog("info", "independencies", "knowledgeOrientations",
+                    "impliedOrientations", "graph");
+//            TetradLogger.getInstance().setForceLog(true);
+
+            TetradLogger.getInstance().log("info", "Testing it.");
+        }
+
+        Fges fges;
+
+        if (useCovariance) {
+            SemBicScore fgesScore = new SemBicScore(covarianceMatrix);
+            fgesScore.setPenaltyDiscount(penaltyDiscount);
+            fges = new Fges(fgesScore);
+
+        } else {
+            if (data.isDiscrete()) {
+                BDeuScore score = new BDeuScore(data);
+                score.setSamplePrior(samplePrior);
+                score.setStructurePrior(structurePrior);
+
+                fges = new Fges(score);
+            } else if (data.isContinuous()) {
+                SemBicScore score = new SemBicScore(new CovarianceMatrixOnTheFly(data));
+                score.setPenaltyDiscount(penaltyDiscount);
+                fges = new Fges(score);
+            } else {
+                throw new IllegalArgumentException();
+            }
+        }
+
+        if (initialGraph != null) {
+            fges.setInitialGraph(initialGraph);
+        }
+
+        fges.setKnowledge(getKnowledge());
+
+        // Convert back to Graph..
+        Graph resultGraph = fges.search();
+
+        // PrintUtil outputStreamPath problem and graphs.
+        outPrint("\nResult graph:");
+        outPrint(resultGraph.toString());
+
+        writeGraph(resultGraph);
+    }
+
+    private void runCpc() {
+        if (this.data == null && this.covarianceMatrix == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (verbose) {
+            systemPrint("CPC");
+            systemPrint(getKnowledge().toString());
+            systemPrint(getVariables().toString());
+
+            TetradLogger.getInstance().addOutputStream(System.out);
+
+            TetradLogger.getInstance().setEventsToLog("info", "independencies", "knowledgeOrientations",
+                    "impliedOrientations", "graph");
+//            TetradLogger.getInstance().setForceLog(true);
+
+            TetradLogger.getInstance().log("info", "Testing it.");
+        }
+
+        Cpc pc = new Cpc(getIndependenceTest());
+        pc.setDepth(getDepth());
+        pc.setKnowledge(getKnowledge());
+        pc.setVerbose(verbose);
+
+        // Convert back to Graph..
+        Graph resultGraph = pc.search();
+
+        // PrintUtil outputStreamPath problem and graphs.
+        outPrint("\nResult graph:");
+        outPrint(resultGraph.toString());
+
+        writeGraph(resultGraph);
+    }
+
+    private void runFci() {
+        if (this.data == null && this.covarianceMatrix == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (verbose) {
+            systemPrint("FCI");
+            systemPrint(getKnowledge().toString());
+            systemPrint(getVariables().toString());
+
+            TetradLogger.getInstance().addOutputStream(System.out);
+
+            TetradLogger.getInstance().setEventsToLog("info", "independencies", "knowledgeOrientations",
+                    "impliedOrientations", "graph");
+//            TetradLogger.getInstance().setForceLog(true);
+
+            TetradLogger.getInstance().log("info", "Testing it.");
+        }
+
+        if (rfciUsed) {
+            Rfci fci = new Rfci(getIndependenceTest());
+            fci.setDepth(getDepth());
+            fci.setKnowledge(getKnowledge());
+            fci.setVerbose(verbose);
+
+            // Convert back to Graph..
+            Graph resultGraph = fci.search();
+
+            // PrintUtil outputStreamPath problem and graphs.
+            outPrint("\nResult graph:");
+            outPrint(resultGraph.toString());
+
+            writeGraph(resultGraph);
+        } else {
+            Fci fci = new Fci(getIndependenceTest());
+            fci.setDepth(getDepth());
+            fci.setKnowledge(getKnowledge());
+            fci.setPossibleDsepSearchDone(!nodsep);
+            fci.setVerbose(verbose);
+
+            // Convert back to Graph..
+            Graph resultGraph = fci.search();
+
+            // PrintUtil outputStreamPath problem and graphs.
+            outPrint("\nResult graph:");
+            outPrint(resultGraph.toString());
+
+            writeGraph(resultGraph);
+
+        }
+    }
+
+    private void runCfci() {
+        if (this.data == null && this.covarianceMatrix == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (verbose) {
+            systemPrint("CFCI");
+            systemPrint(getKnowledge().toString());
+            systemPrint(getVariables().toString());
+
+            TetradLogger.getInstance().addOutputStream(System.out);
+
+            TetradLogger.getInstance().setEventsToLog("info", "independencies", "colliderOrientations",
+                    "impliedOrientations", "graph");
+//            TetradLogger.getInstance().setForceLog(true);
+
+            TetradLogger.getInstance().log("info", "Testing it.");
+        }
+
+        Cfci fci = new Cfci(getIndependenceTest());
+        fci.setDepth(getDepth());
+        fci.setKnowledge(getKnowledge());
+        fci.setDepth(depth);
+        fci.setVerbose(verbose);
+
+        // Convert back to Graph..
+        Graph resultGraph = fci.search();
+
+        // PrintUtil outputStreamPath problem and graphs.
+        outPrint("\nResult graph:");
+        outPrint(resultGraph.toString());
+
+        writeGraph(resultGraph);
+    }
+
+    private void runCcd() {
+        if (this.data == null && this.covarianceMatrix == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (verbose) {
+            systemPrint("CCD");
+            systemPrint(getKnowledge().toString());
+            systemPrint(getVariables().toString());
+
+            TetradLogger.getInstance().addOutputStream(System.out);
+
+            TetradLogger.getInstance().setEventsToLog("info", "independencies", "knowledgeOrientations",
+                    "impliedOrientations", "graph");
+//            TetradLogger.getInstance().setForceLog(true);
+
+            TetradLogger.getInstance().log("info", "Testing it.");
+        }
+
+        Ccd ccd = new Ccd(getIndependenceTest());
+        ccd.setDepth(getDepth());
+
+        // Convert back to Graph..
+        Graph resultGraph = ccd.search();
+
+        // PrintUtil outputStreamPath problem and graphs.
+        outPrint("\nResult graph:");
+        outPrint(resultGraph.toString());
+
+        writeGraph(resultGraph);
+    }
+
+    private void runBayesEst() {
+        if (this.data == null && this.covarianceMatrix != null) {
+            throw new IllegalStateException("Continuous tabular data required.");
+        }
+
+        if (this.data == null) {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        if (!this.data.isDiscrete()) {
+            outPrint("Please supply discrete data.");
+        }
+
+        IndependenceTest independence = new IndTestChiSquare(data, significance);
+
+        Cpc cpc = new Cpc(independence);
+        cpc.setVerbose(verbose);
+        Graph pattern = cpc.search();
+
+        outPrint("Found this pattern: " + pattern);
+
+        Dag dag = new Dag(SearchGraphUtils.dagFromPattern(pattern));
+
+        outPrint("Chose this DAG: " + dag);
+
+        BayesPm pm = new BayesPm(dag);
+
+        MlBayesEstimator est = new MlBayesEstimator();
+        BayesIm im = est.estimate(pm, data);
+
+        outPrint("Estimated IM: " + im);
+
+    }
+
+    private void runFofc() {
+        FindOneFactorClusters fofc;
+
+        if (this.data != null) {
+            fofc = new FindOneFactorClusters(this.data,
+                    this.testType, FindOneFactorClusters.Algorithm.GAP, significance);
+            if (!this.data.isContinuous()) {
+                outPrint("Please supply continuous data.");
+            }
+        } else if (this.covarianceMatrix != null) {
+            fofc = new FindOneFactorClusters(this.covarianceMatrix,
+                    this.testType, FindOneFactorClusters.Algorithm.GAP, significance);
+        } else {
+            throw new IllegalStateException("Data did not load correctly.");
+        }
+
+        fofc.search();
+        List<List<Node>> clusters = fofc.getClusters();
+
+        systemPrint("Clusters:");
+
+        for (int i = 0; i < clusters.size(); i++) {
+            systemPrint((i + 1) + ": " + clusters.get(i));
+        }
+    }
+
+    private void writeGraph(Graph resultGraph) {
+        if (graphXmlFilename != null) {
+            try {
+                String xml = GraphUtils.graphToXml(resultGraph);
+
+                File file = new File(graphXmlFilename);
+
+                PrintWriter out = new PrintWriter(file);
+
+                out.print(xml);
+                out.close();
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();
+            }
+        }
+
+        if (graphTxtFilename != null) {
+            try {
+                File file = new File(graphTxtFilename);
+
+                PrintWriter out = new PrintWriter(file);
+
+                out.print(resultGraph);
+                out.close();
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private IndependenceTest getIndependenceTest() {
+        IndependenceTest independence;
+
+        if (useCovariance) {
+            independence = new IndTestFisherZ(covarianceMatrix, significance);
+        } else {
+            if (this.data.isDiscrete()) {
+                independence = new IndTestChiSquare(data, significance);
+            } else if (this.data.isContinuous()) {
+                if (useConditionalCorrelation) {
+
+                    independence = new IndTestConditionalCorrelation(data, significance);
+                    System.err.println("Using Conditional Correlation");
+
+                } else {
+
+                    independence = new IndTestFisherZ(data, significance);
+                }
+
+
+            } else {
+                throw new IllegalStateException(
+                        "Data must be either continuous or " + "discrete.");
+            }
+        }
+        return independence;
+    }
+
+//    private Level convertToLevel(String level) {
+//        if ("severe".equalsIgnoreCase(level)) {
+//            return Level.SEVERE;
+//        } else if ("warning".equalsIgnoreCase(level)) {
+//            return Level.WARNING;
+//        } else if ("info".equalsIgnoreCase(level)) {
+//            return Level.INFO;
+//        } else if ("config".equalsIgnoreCase(level)) {
+//            return Level.CONFIG;
+//        } else if ("fine".equalsIgnoreCase(level)) {
+//            return Level.FINE;
+//        } else if ("finer".equalsIgnoreCase(level)) {
+//            return Level.FINER;
+//        } else if ("finest".equalsIgnoreCase(level)) {
+//            return Level.FINEST;
+//        }
+//
+//        throw new IllegalArgumentException("Level must be one of 'Severe', " +
+//                "'Warning', 'Info', 'Config', 'Fine', 'Finer', 'Finest'.");
+//    }
+
+    public static void main(final String[] argv) {
+        new TetradCmd(argv);
+    }
+
+    private int getDepth() {
+        return depth;
+    }
+
+    private IKnowledge getKnowledge() {
+        return knowledge;
+    }
+
+    private List<Node> getVariables() {
+        if (data != null) {
+            return data.getVariables();
+        } else if (covarianceMatrix != null) {
+            return covarianceMatrix.getVariables();
+        }
+
+        throw new IllegalArgumentException("Data nor covariance specified.");
+    }
+
+    /**
+     * Allows an array of strings to be treated as a tokenizer.
+     */
+    private static class StringArrayTokenizer {
+        String[] tokens;
+        int i = -1;
+
+        public StringArrayTokenizer(String[] tokens) {
+            this.tokens = tokens;
+        }
+
+        public boolean hasToken() {
+            return i < tokens.length - 1;
+        }
+
+        public String nextToken() {
+            return tokens[++i];
+        }
+    }
+}
+
+
+
+
+
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/ColtDataSet.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/ColtDataSet.java
index afaff18c..b91fec87 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/ColtDataSet.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/ColtDataSet.java
@@ -1174,13 +1174,13 @@ public final class ColtDataSet implements DataSet, TetradSerializable {
 //     * @see #isMulipliersCollapsed()
      */
     public final TetradMatrix getDoubleData() {
-        return tetradMatrix.copy();
+//        return tetradMatrix.copy();
 
 //        if (!isMulipliersCollapsed()) {
 //            CaseExpander expander = new CaseExpander();
 //            return ((ColtDataSet) expander.filter(this)).tetradMatrix;
 //        } else {
-//        return tetradMatrix;
+        return tetradMatrix;
 //        }
     }
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/CovarianceMatrix.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/CovarianceMatrix.java
index cfb3b587..3303914a 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/CovarianceMatrix.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/CovarianceMatrix.java
@@ -96,7 +96,6 @@ public class CovarianceMatrix implements ICovarianceMatrix {
     /**
      * Constructs a new covariance matrix from the given data set.
      *
-     * @param dataSet A cenetered dataset.
      * @throws IllegalArgumentException if this is not a continuous data set.
      */
     public CovarianceMatrix(DataSet dataSet) {
@@ -104,8 +103,6 @@ public class CovarianceMatrix implements ICovarianceMatrix {
             throw new IllegalArgumentException("Not a continuous data set.");
         }
 
-        dataSet = DataUtils.center(dataSet);
-
         this.matrix = new TetradMatrix(dataSet.getNumColumns(), dataSet.getNumColumns());
 
         this.variables = Collections.unmodifiableList(dataSet.getVariables());
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/DataUtils.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/DataUtils.java
index e0ae173d..edbbb9e9 100755
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/DataUtils.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/DataUtils.java
@@ -23,18 +23,10 @@ package edu.cmu.tetrad.data;
 
 import cern.colt.list.DoubleArrayList;
 import edu.cmu.tetrad.graph.*;
-import edu.cmu.tetrad.regression.RegressionCovariance;
-import edu.cmu.tetrad.regression.RegressionDataset;
-import edu.cmu.tetrad.regression.RegressionResult;
-import edu.cmu.tetrad.search.IndTestConditionalCorrelation;
-import edu.cmu.tetrad.search.IndTestFisherZ;
-import edu.cmu.tetrad.search.IndependenceTest;
 import edu.cmu.tetrad.util.*;
-import org.apache.commons.math3.distribution.ChiSquaredDistribution;
 import org.apache.commons.math3.distribution.NormalDistribution;
 import org.apache.commons.math3.linear.BlockRealMatrix;
 import org.apache.commons.math3.linear.RealMatrix;
-import org.apache.commons.math3.linear.SingularMatrixException;
 import org.apache.commons.math3.stat.correlation.Covariance;
 
 import java.rmi.MarshalledObject;
@@ -46,11 +38,6 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.TimeUnit;
 
-import static edu.cmu.tetrad.util.StatUtils.variance;
-import static java.lang.Math.abs;
-import static java.lang.Math.log;
-import static java.lang.Math.sqrt;
-
 /**
  * Some static utility methods for dealing with data sets.
  *
@@ -294,6 +281,7 @@ public final class DataUtils {
     }
 
     /**
+     *
      * Log or unlog data
      *
      * @param data
@@ -311,9 +299,9 @@ public final class DataUtils {
                     if (base == 0) {
                         copy.set(i, j, Math.exp(copy.get(i, j)) - a);
                     } else {
-                        copy.set(i, j, Math.pow(base, (copy.get(i, j))) - a);
+                        copy.set(i, j, Math.pow(base,(copy.get(i, j))) - a);
                     }
-                } else {
+                }  else {
                     if (base == 0) {
                         copy.set(i, j, Math.log(a + copy.get(i, j)));
                     } else {
@@ -425,21 +413,14 @@ public final class DataUtils {
         List<DataSet> outList = new ArrayList<>();
 
         for (DataSet dataSet : dataSets) {
-            DataSet data2 = dataSet.copy();
-
-            double[][] doubleData = dataSet.getDoubleData().transpose().toArray();
-
-            for (int j = 0; j < data2.getNumColumns(); j++) {
-                double[] std = DataUtils.standardizeData(doubleData[j]);
-
-                if (dataSet.getVariable(j) instanceof ContinuousVariable) {
-                    for (int i = 0; i < data2.getNumRows(); i++) {
-                        data2.setDouble(i, j, std[i]);
-                    }
-                }
+            if (!(dataSet.isContinuous())) {
+                throw new IllegalArgumentException("Not a continuous data set: " + dataSet.getName());
             }
 
-            outList.add(data2);
+            TetradMatrix data2 = DataUtils.standardizeData(dataSet.getDoubleData());
+
+            DataSet dataSet2 = ColtDataSet.makeContinuousData(dataSet.getVariables(), data2);
+            outList.add(dataSet2);
         }
 
         return outList;
@@ -1764,20 +1745,19 @@ public final class DataUtils {
 //    }
 
     public static DataSet getNonparanormalTransformed(DataSet dataSet) {
-        dataSet = DataUtils.center(dataSet);
         final TetradMatrix data = dataSet.getDoubleData();
         final TetradMatrix X = data.like();
         final double n = dataSet.getNumRows();
-        final double delta = 0.0001;//1.0 / (4.0 * Math.pow(n, 0.25) * Math.sqrt(Math.PI * Math.log(n)));
+        final double delta = 1.0 / (4.0 * Math.pow(n, 0.25) * Math.sqrt(Math.PI * Math.log(n)));
 
         final NormalDistribution normalDistribution = new NormalDistribution();
 
         double std = Double.NaN;
 
         for (int j = 0; j < data.columns(); j++) {
-            final double[] x1 = data.getColumn(j).copy().toArray();
-//            double std = StatUtils.sd(x1);
-            double mu = StatUtils.mean(x1);
+            final double[] x1 = data.getColumn(j).toArray();
+            double std1 = StatUtils.sd(x1);
+            double mu1 = StatUtils.mean(x1);
             double[] x = ranks(data, x1);
 
             for (int i = 0; i < x.length; i++) {
@@ -1785,8 +1765,6 @@ public final class DataUtils {
                 if (x[i] < delta) x[i] = delta;
                 if (x[i] > (1. - delta)) x[i] = 1. - delta;
                 x[i] = normalDistribution.inverseCumulativeProbability(x[i]);
-
-//                System.out.println();
             }
 
             if (Double.isNaN(std)) {
@@ -1795,8 +1773,8 @@ public final class DataUtils {
 
             for (int i = 0; i < x.length; i++) {
                 x[i] /= std;
-                x[i] *= std;
-                x[i] += mu;
+                x[i] *= std1;
+                x[i] += mu1;
             }
 
             X.assignColumn(j, new TetradVector(x));
@@ -1804,18 +1782,6 @@ public final class DataUtils {
         return ColtDataSet.makeContinuousData(dataSet.getVariables(), X);
     }
 
-    public static DataSet logData(DataSet dataSet, double offset) {
-        dataSet = dataSet.copy();
-
-        for (int i = 0; i < dataSet.getNumRows(); i++) {
-            for (int j = 0; j < dataSet.getNumColumns(); j++) {
-                dataSet.setDouble(i, j, log(offset + dataSet.getDouble(i, j)));
-            }
-        }
-
-        return dataSet;
-    }
-
     private static double[] ranks(TetradMatrix data, double[] x) {
         double[] ranks = new double[x.length];
 
@@ -1901,465 +1867,6 @@ public final class DataUtils {
 
         return (DataSet) dataSet;
     }
-
-    public static DataSet copycContinuousVariables(DataSet data) {
-        List<Node> variables = data.getVariables();
-
-        int n = 0;
-        for (Node variable : variables) {
-            if (variable instanceof ContinuousVariable) {
-                n++;
-            }
-        }
-        if (n == 0) {
-            return new ColtDataSet(0, new ArrayList<Node>());
-        }
-
-        int[] indices = new int[n];
-        int m = 0;
-        for (int i = 0; i < variables.size(); i++) {
-            if (variables.get(i) instanceof ContinuousVariable) {
-                indices[m++] = i;
-            }
-        }
-
-        return data.subsetColumns(indices);
-    }
-
-    public static DataSet copyDiscreteVariables(DataSet data) {
-        List<Node> variables = data.getVariables();
-
-        int n = 0;
-        for (Node variable : variables) {
-            if (variable instanceof DiscreteVariable) {
-                n++;
-            }
-        }
-
-        if (n == 0) {
-            return new ColtDataSet(0, new ArrayList<Node>());
-        }
-
-        int[] indices = new int[n];
-        int m = 0;
-        for (int i = 0; i < variables.size(); i++) {
-            if (variables.get(i) instanceof DiscreteVariable) {
-                indices[m++] = i;
-            }
-        }
-
-        return data.subsetColumns(indices);
-    }
-
-    /**
-     * Checking whether X->Z is linear and non-heteroskedastic given the parents of X.
-     */
-    public static boolean linear(double[] x, double[] y, double bootstrapSampleSize,
-                                 int numBootstraps, double sensitivity) {
-
-        int N = y.length;
-        int b = numBootstraps;
-        int dof = N - 1;
-
-        try {
-            List<Node> nodes = new ArrayList<>();
-            nodes.add(new ContinuousVariable("cov"));
-            nodes.add(new ContinuousVariable("cov1var"));
-
-            DataSet dataSet = new BoxDataSet(new VerticalDoubleDataBox(b, 2), nodes);
-
-            boolean[] mask = new boolean[N];
-            double[] covxys = new double[b];
-            double[] varxs = new double[b];
-
-            for (int _b = 0; _b < b; _b++) {
-                for (int i = 0; i < N; i++) {
-                    if (RandomUtil.getInstance().nextDouble() < bootstrapSampleSize / (double) N) {
-                        if (Double.isNaN(x[i])) continue;
-                        if (Double.isNaN(y[i])) continue;
-
-                        mask[i] = true;
-                    } else {
-                        mask[i] = false;
-                    }
-                }
-
-                final double covxy = covMask(y, x, mask)[0];
-                final double varx = covMask(x, x, mask)[0];
-
-//                double beta = covxy / varx;
-
-//                System.out.println(beta);
-
-                dataSet.setDouble(_b, 0, covxy);
-                dataSet.setDouble(_b, 1, varx);
-                covxys[_b] = covxy;
-                varxs[_b] = varx;
-            }
-
-            RegressionDataset regression = new RegressionDataset(dataSet);
-            List<Node> regressors = new ArrayList<>(nodes);
-            regressors.remove(nodes.get(0));
-
-            RegressionResult result = regression.regress(nodes.get(0), regressors);
-
-            double covxyvar = DataUtils.variance(covxys, 0);
-//            double varxvar = DataUtils.variance(varxs, 0);
-
-            final double[] array = result.getResiduals().toArray();
-
-            double residualVar = DataUtils.variance(array, 0);
-
-//            System.out.println(residualVar);
-
-            final double x2 = sensitivity * dof * (residualVar / (covxyvar));
-
-            double c = new ChiSquaredDistribution(dof).cumulativeProbability(x2);
-
-            if (Double.isNaN(c)) {
-                return false;
-            }
-
-            final double p = 1.0 - c;
-
-//            System.out.println("dof = " + dof + " x2 = " + x2 + " p = " + p);
-
-
-            return p > 0.01;
-        } catch (SingularMatrixException e) {
-            System.out.println("Singular");
-            return true;
-        }
-    }
-
-    public static boolean xydep(double[] x, double[] y) {
-
-        try {
-
-//            int N = y.length;
-//            int b = numBootstraps;
-//            int dof = b - 1;
-
-            double[][] all = new double[][]{x, y};
-
-            final ContinuousVariable X = new ContinuousVariable("X");
-            final ContinuousVariable Y = new ContinuousVariable("Y");
-            final ContinuousVariable R = new ContinuousVariable("R");
-
-            List<Node> nodes = new ArrayList<>();
-            nodes.add(X);
-            nodes.add(Y);
-
-            DataSet dataSet = new BoxDataSet(new VerticalDoubleDataBox(all), nodes);
-
-            RegressionDataset regression = new RegressionDataset(dataSet);
-
-            RegressionResult result = regression.regress(X, Collections.singletonList(Y));
-            double[] r = result.getResiduals().toArray();
-
-            // Is x _||_ r?
-            double[][] all2 = new double[][]{x, y, r};
-
-            List<Node> nodes2 = new ArrayList<>();
-            nodes2.add(X);
-            nodes2.add(Y);
-            nodes2.add(R);
-
-            DataSet dataSet2 = new BoxDataSet(new VerticalDoubleDataBox(all2), nodes2);
-
-            IndependenceTest test = new IndTestConditionalCorrelation(dataSet2, .2);
-
-            return !test.isIndependent(X, Y);
-        } catch (SingularMatrixException e) {
-            System.out.println("Singular");
-            return true;
-        }
-    }
-
-    public static boolean linear3(double[] x, double[] y, double bootstrapSampleSize,
-                                  int numBootstraps, double sensitivity) {
-
-        int N = y.length;
-        int b = numBootstraps;
-        int dof = N - 1;
-
-        try {
-            List<Node> nodes = new ArrayList<>();
-            nodes.add(new ContinuousVariable("cov"));
-            nodes.add(new ContinuousVariable("cov1var"));
-
-            DataSet dataSet = new BoxDataSet(new VerticalDoubleDataBox(b, 2), nodes);
-
-            boolean[] mask = new boolean[N];
-            double[] covxys = new double[b];
-            double[] varxs = new double[b];
-
-            for (int _b = 0; _b < b; _b++) {
-                for (int i = 0; i < N; i++) {
-                    if (RandomUtil.getInstance().nextDouble() < bootstrapSampleSize / (double) N) {
-                        if (Double.isNaN(x[i])) continue;
-                        if (Double.isNaN(y[i])) continue;
-
-                        mask[i] = true;
-                    } else {
-                        mask[i] = false;
-                    }
-                }
-
-                final double covxy = covMask(y, x, mask)[0];
-                final double varx = covMask(x, x, mask)[0];
-
-//                double beta = covxy / varx;
-
-//                System.out.println(beta);
-
-                dataSet.setDouble(_b, 0, covxy);
-                dataSet.setDouble(_b, 1, varx);
-                covxys[_b] = covxy;
-                varxs[_b] = varx;
-            }
-
-            RegressionDataset regression = new RegressionDataset(dataSet);
-            List<Node> regressors = new ArrayList<>(nodes);
-            regressors.remove(nodes.get(0));
-
-            RegressionResult result = regression.regress(nodes.get(0), regressors);
-
-            double covxyvar = DataUtils.variance(covxys, 0);
-//            double varxvar = DataUtils.variance(varxs, 0);
-
-            final double[] array = result.getResiduals().toArray();
-
-            double residualVar = DataUtils.variance(array, 0);
-
-//            System.out.println(residualVar);
-
-            final double x2 = sensitivity * dof * (residualVar / (covxyvar));
-
-            double c = new ChiSquaredDistribution(dof).cumulativeProbability(x2);
-
-            if (Double.isNaN(c)) {
-                return false;
-            }
-
-            final double p = 1.0 - c;
-
-//            System.out.println("dof = " + dof + " x2 = " + x2 + " p = " + p);
-
-
-            return p > 0.01;
-        } catch (SingularMatrixException e) {
-            System.out.println("Singular");
-            return true;
-        }
-    }
-
-    public static boolean linear4(double[] x, double[] y, double alpha) {
-
-        try {
-
-            List<Node> nodes = new ArrayList<>();
-
-            final Node X = new ContinuousVariable("X");
-            final Node Y = new ContinuousVariable("Y");
-
-            nodes.add(X);
-            nodes.add(Y);
-
-            final double[][] doubles = {x, y};
-            DataSet dataSet = new BoxDataSet(new VerticalDoubleDataBox(doubles), nodes);
-
-            RegressionDataset regression = new RegressionDataset(dataSet);
-
-            RegressionResult result = regression.regress(Y,
-                    Collections.singletonList(X));
-            double p = result.getP()[1];
-
-            return p < alpha;
-        } catch (SingularMatrixException e) {
-            System.out.println("Singular");
-            return true;
-        }
-    }
-
-    public static double linearPValue(double[] z, double[] x, double[][] p, double numInBootstrap,
-                                      int numBootstraps, double sensitivity) {
-
-        int N = z.length;
-        int m = p.length + 2;
-        int b = numBootstraps;
-        int dof = N - 1;
-
-        try {
-            List<Node> nodes = new ArrayList<>();
-            nodes.add(new ContinuousVariable("cov"));
-            nodes.add(new ContinuousVariable("var0"));
-
-            for (int j = 1; j <= p.length; j++) {
-                nodes.add(new ContinuousVariable("var" + j));
-            }
-
-            DataSet dataSet = new BoxDataSet(new VerticalDoubleDataBox(b, m), nodes);
-
-            boolean[] mask = new boolean[N];
-            double[] cov0s = new double[b];
-
-            for (int _b = 0; _b < b; _b++) {
-
-                I:
-                for (int i = 0; i < N; i++) {
-                    if (RandomUtil.getInstance().nextDouble() < numInBootstrap / (double) N) {
-                        if (Double.isNaN(x[i])) continue;
-                        if (Double.isNaN(z[i])) continue;
-
-                        for (double[] otherParent : p) {
-                            if (Double.isNaN(otherParent[i])) continue I;
-                        }
-
-                        mask[i] = true;
-                    } else {
-                        mask[i] = false;
-                    }
-                }
-
-                final double cov0 = covMask(z, x, mask)[0];
-                final double cov1 = covMask(x, x, mask)[0];
-                dataSet.setDouble(_b, 0, cov0);
-                dataSet.setDouble(_b, 1, cov1);
-                cov0s[_b] = cov0;
-
-                for (int j = 0; j < p.length; j++) {
-                    final double cov3 = covMask(x, p[j], mask)[0];
-                    dataSet.setDouble(_b, j + 2, cov3);
-                }
-            }
-
-            RegressionDataset regression = new RegressionDataset(dataSet);
-            List<Node> regressors = new ArrayList<>(nodes);
-            regressors.remove(nodes.get(0));
-
-            RegressionResult result = regression.regress(nodes.get(0), regressors);
-
-            double cov0var = DataUtils.variance(cov0s, 0);
-
-
-            final double[] array = result.getResiduals().toArray();
-
-            double residualVar = DataUtils.variance(array, 0);
-
-            final double x2 = sensitivity * dof * (residualVar / cov0var);
-
-            double c = new ChiSquaredDistribution(dof).cumulativeProbability(x2);
-
-            return 1.0 - c;
-        } catch (SingularMatrixException e) {
-            System.out.println("Singular");
-            throw e;
-        }
-    }
-
-    public static double variance(double array[], double meanValue) {
-
-        int i;
-        double difference;
-        double sum = 0.0;
-        int N = array.length;
-
-        for (i = 0; i < N; i++) {
-            difference = array[i] - meanValue;
-            sum += difference * difference;
-        }
-
-        return sum / (double) (N - 1);
-    }
-
-    public static double covWithoutNonlinear(double[] x, double[] z, double percentInBootstrap,
-                                             int numBootstraps, double cutoff) {
-
-        final ContinuousVariable cov = new ContinuousVariable("cov");
-        final ContinuousVariable var = new ContinuousVariable("var0");
-
-        List<Node> nodes = new ArrayList<>();
-        nodes.add(cov);
-        nodes.add(var);
-
-        List<Node> regressors = new ArrayList<>();
-        regressors.add(var);
-
-        DataSet dataSet = new BoxDataSet(new VerticalDoubleDataBox(numBootstraps, 2), nodes);
-
-        boolean[] mask = new boolean[x.length];
-        double[] cov0s = new double[numBootstraps];
-
-        for (int b = 0; b < numBootstraps; b++) {
-            for (int i = 0; i < mask.length; i++) {
-                if (RandomUtil.getInstance().nextDouble() < percentInBootstrap) {
-                    if (Double.isNaN(x[i])) continue;
-                    if (Double.isNaN(z[i])) continue;
-
-                    mask[i] = true;
-                } else {
-                    mask[i] = false;
-                }
-            }
-
-            final double cov0 = covMask(x, z, mask)[0];
-            final double cov1 = covMask(x, x, mask)[0];
-
-            dataSet.setDouble(b, 0, cov0);
-            dataSet.setDouble(b, 1, cov1);
-            cov0s[b] = cov0;
-        }
-
-        try {
-            RegressionDataset regression = new RegressionDataset(dataSet);
-            RegressionResult result = regression.regress(cov, regressors);
-
-            final double[] residuals = result.getResiduals().toArray();
-
-            for (int b = 0; b < numBootstraps; b++) {
-                cov0s[b] -= residuals[b];
-            }
-        } catch (SingularMatrixException e) {
-            //
-        }
-
-        return cov0s[0];
-    }
-
-    public static double[] covMask(double[] x, double[] y, boolean[] mask) {
-        double exy = 0.0;
-        double exx = 0.0;
-        double eyy = 0.0;
-
-        double ex = 0.0;
-        double ey = 0.0;
-
-        int n = 0;
-
-        for (int k = 0; k < mask.length; k++) {
-            if (mask[k]) {
-                exy += x[k] * y[k];
-                exx += x[k] * x[k];
-                eyy += y[k] * y[k];
-                ex += x[k];
-                ey += y[k];
-                n++;
-            }
-        }
-
-        exy /= n;
-        exx /= n;
-        eyy /= n;
-        ex /= n;
-        ey /= n;
-
-        double sxy = exy - ex * ey;
-        double sx = exx - ex * ex;
-        double sy = eyy - ey * ey;
-
-        return new double[]{sxy, sxy / sqrt(sx * sy), sx, sy, (double) n, ex, ey, sxy / sx};
-    }
 }
 
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/IKnowledge.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/IKnowledge.java
index 40269695..9e1eae15 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/IKnowledge.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/IKnowledge.java
@@ -18,20 +18,21 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetrad.data;
 
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.graph.Node;
 import edu.cmu.tetrad.util.TetradSerializable;
+
 import java.util.Iterator;
 import java.util.List;
 
 /**
- * Interface for knowledge of forbidden and required edges. Implemented in
- * different ways. See implementations.
+ * Interface for knowledge of forbidden and required edges. Implemented
+ * in different ways. See implementations.
  */
 public interface IKnowledge extends TetradSerializable {
-
     long serialVersionUID = 23L;
 
     void addToTier(int tier, String var);
@@ -115,13 +116,7 @@ public interface IKnowledge extends TetradSerializable {
     IKnowledge copy();
 
     int isInWhichTier(Node node); // added by DMalinsky for tsFCI 4/20/16
+}
 
-    public List<KnowledgeEdge> getListOfRequiredEdges();
-
-    public List<KnowledgeEdge> getListOfExplicitlyRequiredEdges();
-
-    public List<KnowledgeEdge> getListOfForbiddenEdges();
 
-    public List<KnowledgeEdge> getListOfExplicitlyForbiddenEdges();
 
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/Knowledge.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/Knowledge.java
index e9424090..f152abfc 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/Knowledge.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/Knowledge.java
@@ -18,6 +18,7 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetrad.data;
 
 import edu.cmu.tetrad.graph.Edge;
@@ -25,32 +26,18 @@ import edu.cmu.tetrad.graph.Edges;
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.graph.Node;
 import edu.cmu.tetrad.util.TetradSerializable;
-import java.io.BufferedReader;
-import java.io.CharArrayWriter;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.SortedSet;
-import java.util.TreeSet;
-import java.util.stream.Collectors;
+
+import java.io.*;
+import java.util.*;
 
 /**
  * Stores information about required and forbidden edges and common causes for
- * use in algorithm. This information can be set edge by edge or else globally
- * via temporal tiers. When setting temporal tiers, all edges from later tiers
+ * use in algorithm.  This information can be set edge by edge or else globally
+ * via temporal tiers.  When setting temporal tiers, all edges from later tiers
  * to earlier tiers are forbidden. </p> For this class, all varNames are
- * referenced by name only. This is because the same Knowledge object is
+ * referenced by name only.  This is because the same Knowledge object is
  * intended to plug into different graphs with nodes that possibly have the same
- * names. Thus, if the Knowledge object forbids the edge X --> Y, then it
+ * names.  Thus, if the Knowledge object forbids the edge X --> Y, then it
  * forbids any edge which connects a node named "X" to a node named "Y", even if
  * the underlying nodes themselves named "X" and "Y", respectively, are not the
  * same.
@@ -62,7 +49,6 @@ import java.util.stream.Collectors;
  * @author Tyler Gibson modifications 2/07
  */
 public final class Knowledge implements TetradSerializable, IKnowledge {
-
     static final long serialVersionUID = 23L;
 
     /**
@@ -72,10 +58,10 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
 
     /**
      * This is a representation of the temporal tiers, a map from Strings to
-     * Integers. Each variable name is mapped to exactly one tier (an Integer).
+     * Integers.  Each variable name is mapped to exactly one tier (an Integer).
      * To determine whether an edge v1 --> v2 is forbidden by the tiers, find
      * tierMap(v1) and tierMap(v2); if tierMap(v1) > tierMap(v2), the edge is
-     * forbidden by tiers. If either tierMap(v1) or tierMap(v2) is null, the
+     * forbidden by tiers.  If either tierMap(v1) or tierMap(v2) is null, the
      * edge is not forbidden by tiers, and if tierMap(v1) <= tierMap(v2), the
      * edge is not forbidden by tiers. In this representation, in order to get
      * all the varNames of a given tier, iterate through the domain of the map
@@ -88,16 +74,16 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     /**
      * This is the set of edges explicitly required by the user
      * <p>
-     * Note: Should really be called "explicitlyRequiredEdges" (can't change
-     * though).
+     * Note: Should really be called "explicitlyRequiredEdges" (can't change though).
      *
      * @serial
      */
     private Set<KnowledgeEdge> requiredEdges;
 
+
     /**
-     * This is the set of all edges that are required, including edges
-     * explicitly required and required by groups.
+     * This is the set of all edges that are required, including edges explicitly required and
+     * required by groups.
      *
      * @serial
      */
@@ -138,6 +124,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
      */
     private Set<Integer> tiersForbiddenWithin = new HashSet<>();
 
+
     /**
      * The knowledge groups, this contains all the grouping information.
      *
@@ -145,6 +132,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
      */
     private List<KnowledgeGroup> knowledgeGroups = new ArrayList<>();
 
+
     /**
      * When the graph for this knowledge is displayed, it defauls to the
      * knowledge layout if this is true.
@@ -155,6 +143,8 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     private boolean lagged = false;
 
     //================================CONSTRUCTORS========================//
+
+
     /**
      * Constructs a blank knowledge object.
      */
@@ -169,17 +159,17 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     private Knowledge(Knowledge knowledge) {
         this.tierMap = new HashMap<>(knowledge.tierMap);
         this.allRequiredEdges = new HashSet<>(knowledge.allRequiredEdges);
-        this.requiredEdges
-                = new HashSet<>(knowledge.requiredEdges);
+        this.requiredEdges =
+                new HashSet<>(knowledge.requiredEdges);
 //        this.setForbiddenEdges(new HashSet<KnowledgeEdge>(knowledge.getForbiddenEdges()));
-        this.explicitlyForbiddenEdges
-                = new HashSet<>(knowledge.explicitlyForbiddenEdges);
-        this.requiredCommonCauses
-                = new HashSet<>(knowledge.requiredCommonCauses);
-        this.forbiddenCommonCauses
-                = new HashSet<>(knowledge.forbiddenCommonCauses);
-        this.tiersForbiddenWithin
-                = new HashSet<>(knowledge.tiersForbiddenWithin);
+        this.explicitlyForbiddenEdges =
+                new HashSet<>(knowledge.explicitlyForbiddenEdges);
+        this.requiredCommonCauses =
+                new HashSet<>(knowledge.requiredCommonCauses);
+        this.forbiddenCommonCauses =
+                new HashSet<>(knowledge.forbiddenCommonCauses);
+        this.tiersForbiddenWithin =
+                new HashSet<>(knowledge.tiersForbiddenWithin);
         this.defaultToKnowledgeLayout = knowledge.defaultToKnowledgeLayout;
         this.knowledgeGroups = knowledge.knowledgeGroups;
         this.lagged = knowledge.lagged;
@@ -193,13 +183,14 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     }
 
     //===============================PUBLIC METHODS=======================//
+
     /**
-     * Adds the given variable to the given tier. If a variable is added which
+     * Adds the given variable to the given tier.  If a variable is added which
      * is already in a tier, it is moved to the new tier.
      *
      * @param tier a (usually) non-negative integer. Negative integers may be
-     * specified without breaking anything.
-     * @param var the name of a variable to put in that tier.
+     *             specified without breaking anything.
+     * @param var  the name of a variable to put in that tier.
      */
     public final void addToTier(int tier, String var) {
         if (!variables.contains(var)) {
@@ -219,19 +210,19 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
 
             if (tier2 < tier) {
                 if (isRequired(var, var2)) {
-                    throw new IllegalStateException("Edge " + var + "-->"
-                            + var2
-                            + " is a required edge. Please remove that requirement "
-                            + "or adjust \nthe tiers so that " + var + "-->"
-                            + var2 + " will not be forbidden.");
+                    throw new IllegalStateException("Edge " + var + "-->" +
+                            var2 +
+                            " is a required edge. Please remove that requirement " +
+                            "or adjust \nthe tiers so that " + var + "-->" +
+                            var2 + " will not be forbidden.");
                 }
             } else if (tier < tier2) {
                 if (isRequired(var2, var)) {
-                    throw new IllegalStateException("Edge " + var2 + "-->"
-                            + var
-                            + " is a required edge. Please remove that requirement "
-                            + "or adjust \nthe tiers so that " + var2 + "-->"
-                            + var + " will not be forbidden.");
+                    throw new IllegalStateException("Edge " + var2 + "-->" +
+                            var +
+                            " is a required edge. Please remove that requirement " +
+                            "or adjust \nthe tiers so that " + var2 + "-->" +
+                            var + " will not be forbidden.");
                 }
             }
         }
@@ -242,7 +233,8 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     }
 
     /**
-     * Puts a variable into tier i if its name is xxx:i for some xxx and some i.
+     * Puts a variable into tier i if its name is xxx:i for some xxx and some
+     * i.
      */
     public final void addToTiersByVarNames(List<String> varNames) {
         if (!variables.containsAll(varNames)) {
@@ -262,6 +254,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         }
     }
 
+
     /**
      * @return - all the knowledge groups.
      */
@@ -269,6 +262,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return Collections.unmodifiableList(this.knowledgeGroups);
     }
 
+
     /**
      * Removes the <code>KnowledgeGroup</code> at the given index.
      */
@@ -310,6 +304,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         }
     }
 
+
     /**
      * Replaces the <code>KnowledgeGroup</code> at the given index.
      */
@@ -319,8 +314,8 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
             if (i != index) {
                 KnowledgeGroup g = this.knowledgeGroups.get(i);
                 if (group.isConflict(g)) {
-                    throw new IllegalArgumentException("Changes to the knowedge group at " + (index + 1)
-                            + " conflict with the knowledge group at " + (i + 1));
+                    throw new IllegalArgumentException("Changes to the knowedge group at " + (index + 1) +
+                            " conflict with the knowledge group at " + (i + 1));
                 }
             }
         }
@@ -364,15 +359,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
 //        return Collections.unmodifiableSet(getForbiddenEdges()).iterator();
     }
 
-    @Override
-    public List<KnowledgeEdge> getListOfForbiddenEdges() {
-        return getForbiddenEdges().stream()
-                .collect(Collectors.toList());
-    }
 
-//    public List<KnowledgeEdge> getForbiddenEdges() {
-//        return get
-//    }
     /**
      * Iterator over the knowledge's explicitly forbidden edges.
      */
@@ -380,13 +367,6 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return Collections.unmodifiableSet(this.explicitlyForbiddenEdges).iterator();
     }
 
-    @Override
-    public List<KnowledgeEdge> getListOfExplicitlyForbiddenEdges() {
-        List<KnowledgeEdge> list = this.explicitlyForbiddenEdges.stream()
-                .collect(Collectors.toList());
-
-        return Collections.unmodifiableList(list);
-    }
 
     /**
      * @return the list of edges not in any tier.
@@ -444,6 +424,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return forbiddenCommonCauses.contains(new KnowledgeEdge(var1, var2));
     }
 
+
     /**
      * Determines whether the dge var1 --> var2 is explicitly required.
      */
@@ -451,6 +432,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return this.requiredEdges.contains(new KnowledgeEdge(var1, var2));
     }
 
+
     /**
      * Determines whether edge is explicitly required.
      */
@@ -458,9 +440,10 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return this.requiredEdges.contains(edge);
     }
 
+
     /**
-     * Determines whether the edge var1 --> var2 is forbidden, either
-     * explicitly, by tiers or by groups.
+     * Determines whether the edge var1 --> var2 is forbidden, either explicitly, by tiers
+     * or by groups.
      */
     public final boolean isForbidden(String var1, String var2) {
         if (isForbiddenByTiers(var1, var2)) {
@@ -472,17 +455,16 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     }
 
     /**
-     * Determines whether the edge var1 --> var2 is required either explicitly
-     * or by grups.
+     * Determines whether the edge var1 --> var2 is required either explicitly or by grups.
      */
     public final boolean isRequired(String var1, String var2) {
         KnowledgeEdge edge = new KnowledgeEdge(var1, var2);
         return this.allRequiredEdges.contains(edge);
     }
 
+
     /**
-     * Determines whether the edge var1 --> var2 is required by a knowledge
-     * group.
+     * Determines whether the edge var1 --> var2 is required by a knowledge group.
      */
     public final boolean isRequiredByGroups(String var1, String var2) {
         KnowledgeEdge edge = new KnowledgeEdge(var1, var2);
@@ -494,9 +476,9 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return false;
     }
 
+
     /**
-     * Determines whether the edge var1 --> var2 is forbidden by a knowledge
-     * group.
+     * Determines whether the edge var1 --> var2 is forbidden by a knowledge group.
      */
     public final boolean isForbiddenByGroups(String var1, String var2) {
         KnowledgeEdge edge = new KnowledgeEdge(var1, var2);
@@ -508,14 +490,16 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return false;
     }
 
+
     /**
      * @return true iff no edge between x and y is required.
      */
     public final boolean noEdgeRequired(String x, String y) {
-        return !(isCommonCauseRequired(x, y) || isRequired(x, y)
-                || isRequired(y, x));
+        return !(isCommonCauseRequired(x, y) || isRequired(x, y) ||
+                isRequired(y, x));
     }
 
+
     /**
      * Determines whether a common cause is required between two varNames.
      */
@@ -549,9 +533,9 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
      * @return true if there is no background knowledge recorded.
      */
     public final boolean isEmpty() {
-        return this.allRequiredEdges.isEmpty() && getForbiddenEdges().isEmpty()
-                && requiredCommonCauses.isEmpty()
-                && forbiddenCommonCauses.isEmpty() && this.isGroupKnowledgeEmpty();
+        return this.allRequiredEdges.isEmpty() && getForbiddenEdges().isEmpty() &&
+                requiredCommonCauses.isEmpty() &&
+                forbiddenCommonCauses.isEmpty() && this.isGroupKnowledgeEmpty();
     }
 
     /**
@@ -565,29 +549,31 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
      * 4 x5
      * </pre>
      */
-    public static void saveKnowledge(IKnowledge knowledge, Writer out) throws IOException {
+    public static void saveKnowledge(IKnowledge knowledge, Writer out)
+            throws IOException {
         StringBuilder buf = new StringBuilder();
         buf.append("/knowledge");
 
-        buf.append("\naddtemporal\n");
+        buf.append("\naddtemporal");
 
         for (int i = 0; i < knowledge.getNumTiers(); i++) {
-            String forbiddenWithin
-                    = knowledge.isTierForbiddenWithin(i) ? "*" : "";
+            String forbiddenWithin =
+                    knowledge.isTierForbiddenWithin(i) ? "*" : "";
 
-            buf.append("\n").append(i + 1).append(forbiddenWithin);
+            buf.append("\n").append(i + 1).append(forbiddenWithin).append(" ");
 
             List<String> tier = knowledge.getTier(i);
-            if (!(tier == null || tier.isEmpty())) {
-                buf.append(" ");
-                buf.append(tier.stream().collect(Collectors.joining(" ")));
+
+            for (Object aTier : tier) {
+                String name = (String) aTier;
+                buf.append(name).append(" ");
             }
         }
 
         buf.append("\n\nforbiddirect");
 
-        for (Iterator<KnowledgeEdge> i
-                = knowledge.forbiddenEdgesIterator(); i.hasNext();) {
+        for (Iterator<KnowledgeEdge> i =
+             knowledge.forbiddenEdgesIterator(); i.hasNext(); ) {
             KnowledgeEdge pair = i.next();
             String from = pair.getFrom();
             String to = pair.getTo();
@@ -601,8 +587,8 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
 
         buf.append("\n\nrequiredirect");
 
-        for (Iterator<KnowledgeEdge> i
-                = knowledge.requiredEdgesIterator(); i.hasNext();) {
+        for (Iterator<KnowledgeEdge> i =
+             knowledge.requiredEdgesIterator(); i.hasNext(); ) {
             KnowledgeEdge pair = i.next();
             String from = pair.getFrom();
             String to = pair.getTo();
@@ -613,6 +599,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         out.flush();
     }
 
+
     /**
      * Iterator over the KnowledgeEdge's representing required common causes.
      */
@@ -627,14 +614,6 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return Collections.unmodifiableSet(this.allRequiredEdges).iterator();
     }
 
-    @Override
-    public List<KnowledgeEdge> getListOfRequiredEdges() {
-        List<KnowledgeEdge> list = this.allRequiredEdges.stream()
-                .collect(Collectors.toList());
-
-        return Collections.unmodifiableList(list);
-    }
-
     /**
      * Iterator over the KnowledgeEdge's explicitly required edges.
      */
@@ -642,13 +621,6 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return Collections.unmodifiableSet(this.requiredEdges).iterator();
     }
 
-    @Override
-    public List<KnowledgeEdge> getListOfExplicitlyRequiredEdges() {
-        List<KnowledgeEdge> list = this.requiredEdges.stream()
-                .collect(Collectors.toList());
-
-        return Collections.unmodifiableList(list);
-    }
 
     /**
      * Marks the edge var1 --> var2 as forbid.
@@ -662,13 +634,13 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
             return;
         }
         if (this.isRequiredByGroups(var1, var2)) {
-            throw new IllegalStateException("The edge " + var1 + "-->" + var2
-                    + " is required by a knowledge group. Please remove that requirement first.");
+            throw new IllegalStateException("The edge " + var1 + "-->" + var2 +
+                    " is required by a knowledge group. Please remove that requirement first.");
         }
 
         if (isRequired(var1, var2)) {
-            throw new IllegalStateException("The edge " + var1 + "-->"
-                    + var2 + " is already required. Please first remove that requirement.");
+            throw new IllegalStateException("The edge " + var1 + "-->" +
+                    var2 + " is already required. Please first remove that requirement.");
         }
 
         explicitlyForbiddenEdges.add(new KnowledgeEdge(var1, var2));
@@ -685,8 +657,8 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         }
 
         if (isForbiddenByTiers(var1, var2)) {
-            throw new IllegalStateException("The edge " + var1 + "-->"
-                    + var2 + " is forbidden by tiers. Please adjust tiers first.");
+            throw new IllegalStateException("The edge " + var1 + "-->" +
+                    var2 + " is forbidden by tiers. Please adjust tiers first.");
         }
 
         explicitlyForbiddenEdges.remove(new KnowledgeEdge(var1, var2));
@@ -694,25 +666,26 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         generateForbiddenEdgeList();
     }
 
+
     /**
      * Marks the edge var1 --> var2 as required.
      */
     public final void setRequired(String var1, String var2) {
         if (isForbiddenByTiers(var1, var2)) {
-            throw new IllegalArgumentException("The edge " + var1
-                    + " --> " + var2
-                    + " is forbidden by temporal tiers. Please adjust tiers first.");
+            throw new IllegalArgumentException("The edge " + var1 +
+                    " --> " + var2 +
+                    " is forbidden by temporal tiers. Please adjust tiers first.");
         }
         if (this.isForbiddenByGroups(var1, var2)) {
-            throw new IllegalArgumentException("The edge " + var1 + " --> "
-                    + var2 + "is forbidden by a knowledge group. Please remove this requirement first");
+            throw new IllegalArgumentException("The edge " + var1 + " --> " +
+                    var2 + "is forbidden by a knowledge group. Please remove this requirement first");
         }
 
         if (isForbidden(var1, var2)) {
-            throw new IllegalArgumentException("The edge " + var1
-                    + " --> " + var2
-                    + " has been forbidden explicitly. Please adjust that "
-                    + "requirement first.");
+            throw new IllegalArgumentException("The edge " + var1 +
+                    " --> " + var2 +
+                    " has been forbidden explicitly. Please adjust that " +
+                    "requirement first.");
         }
 
         KnowledgeEdge edge = new KnowledgeEdge(var1, var2);
@@ -732,6 +705,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         }
     }
 
+
     /**
      * Removes the given variable from the given tier.
      */
@@ -741,6 +715,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
 //        generateForbiddenEdgeList();
     }
 
+
     public final void setTierForbiddenWithin(int tier, boolean forbidden) {
         if (forbidden) {
             Iterator<KnowledgeEdge> iterator = requiredEdgesIterator();
@@ -789,6 +764,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return defaultToKnowledgeLayout;
     }
 
+
     /**
      * Removes explicit knowledge and tier information.
      */
@@ -870,6 +846,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     }
 
     //===========================PRIVATE METHODS==========================//
+
     private boolean isGroupKnowledgeEmpty() {
         for (KnowledgeGroup group : this.knowledgeGroups) {
             if (!group.isEmpty()) {
@@ -879,34 +856,37 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         return true;
     }
 
+
     private void checkAgainstRequired(KnowledgeEdge edge) {
         if (this.requiredEdges.contains(edge)) {
-            throw new IllegalArgumentException("The edge " + edge.getFrom() + " --> " + edge.getTo()
-                    + " is already required. Please first remove that requirement.");
+            throw new IllegalArgumentException("The edge " + edge.getFrom() + " --> " + edge.getTo() +
+                    " is already required. Please first remove that requirement.");
         }
     }
 
+
     private void checkAgainstForbidden(KnowledgeEdge edge) {
         if (isForbiddenByTiers(edge.getFrom(), edge.getTo())) {
-            throw new IllegalArgumentException("The edge " + edge.getFrom()
-                    + " --> " + edge.getTo()
-                    + " is forbidden by temporal tiers. Please adjust tiers first.");
+            throw new IllegalArgumentException("The edge " + edge.getFrom() +
+                    " --> " + edge.getTo() +
+                    " is forbidden by temporal tiers. Please adjust tiers first.");
         }
 
         if (this.explicitlyForbiddenEdges.contains(edge)) {
-            throw new IllegalArgumentException("The edge " + edge.getFrom()
-                    + " --> " + edge.getTo()
-                    + " has been forbidden explicitly. Please adjust that "
-                    + "requirement first.");
+            throw new IllegalArgumentException("The edge " + edge.getFrom() +
+                    " --> " + edge.getTo() +
+                    " has been forbidden explicitly. Please adjust that " +
+                    "requirement first.");
         }
     }
 
+
     /**
      * Sets whether a common cause is forbidden along an edge connecting var1
      * and var2.
      */
     private void setCommonCauseForbidden(String var1, String var2,
-            boolean forbidden) {
+                                         boolean forbidden) {
         KnowledgeEdge edge1 = new KnowledgeEdge(var1, var2);
         KnowledgeEdge edge2 = new KnowledgeEdge(var2, var1);
 
@@ -925,7 +905,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
      * var2.
      */
     private void setCommonCauseRequired(String var1, String var2,
-            boolean required) {
+                                        boolean required) {
         KnowledgeEdge edge1 = new KnowledgeEdge(var1, var2);
         KnowledgeEdge edge2 = new KnowledgeEdge(var2, var1);
 
@@ -954,6 +934,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         tierMap = new HashMap<>();
     }
 
+
     /**
      * Generates the <code>allRequiredEdges</code> set.
      */
@@ -969,6 +950,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
         this.allRequiredEdges.addAll(this.requiredEdges);
     }
 
+
     /**
      * Method generateForbiddenEdgeList
      */
@@ -1005,7 +987,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     }
 
     private static String readLineSkippingComments(BufferedReader in,
-            String commentIndicator, int[] lineNo) throws IOException {
+                                                   String commentIndicator, int[] lineNo) throws IOException {
         if (commentIndicator == null) {
             lineNo[0]++;
             return in.readLine();
@@ -1055,6 +1037,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
 //        if (getForbiddenEdges() == null) {
 //            throw new NullPointerException();
 //        }
+
         if (explicitlyForbiddenEdges == null) {
             throw new NullPointerException();
         }
@@ -1092,6 +1075,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
 
     }
 
+
     public boolean isViolatedBy(Graph graph) {
         for (Edge edge : graph.getEdges()) {
             if (!edge.isDirected()) {
@@ -1165,6 +1149,7 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
 //    private void setForbiddenEdges(Set<KnowledgeEdge> forbiddenEdge) {
 //        this.forbiddenEdges = forbiddenEdge;
 //    }
+
     public boolean isLagged() {
         return lagged;
     }
@@ -1179,3 +1164,4 @@ public final class Knowledge implements TetradSerializable, IKnowledge {
     } // added by DMalinsky for tsFCI on 4/20/16
 
 }
+
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/Knowledge2.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/Knowledge2.java
index c1ce63a5..c582fbb6 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/Knowledge2.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/Knowledge2.java
@@ -22,6 +22,7 @@ package edu.cmu.tetrad.data;
 
 import edu.cmu.tetrad.graph.*;
 import edu.cmu.tetrad.util.TetradSerializable;
+
 import java.io.CharArrayWriter;
 import java.io.IOException;
 import java.io.Writer;
@@ -49,15 +50,15 @@ import java.util.regex.Matcher;
  *
  * @author Joseph Ramsey
  */
-public class Knowledge2 implements TetradSerializable, IKnowledge {
+public final class Knowledge2 implements TetradSerializable, IKnowledge {
 
     static final long serialVersionUID = 23L;
 
     private Set<MyNode> myNodes = new HashSet<>();
 
-    List<OrderedPair<Set<MyNode>>> forbiddenRulesSpecs;
-    List<OrderedPair<Set<MyNode>>> requiredRulesSpecs;
-    List<Set<MyNode>> tierSpecs;
+    private List<OrderedPair<Set<MyNode>>> forbiddenRulesSpecs;
+    private List<OrderedPair<Set<MyNode>>> requiredRulesSpecs;
+    private List<Set<MyNode>> tierSpecs;
 
     // Legacy.
     private final List<KnowledgeGroup> knowledgeGroups = new ArrayList<>();
@@ -292,25 +293,6 @@ public class Knowledge2 implements TetradSerializable, IKnowledge {
         return edges.iterator();
     }
 
-    @Override
-    public List<KnowledgeEdge> getListOfForbiddenEdges() {
-        List<KnowledgeEdge> edges = new LinkedList<>();
-
-        forbiddenRulesSpecs.forEach(e -> {
-            Set<MyNode> s1 = e.getFirst();
-            Set<MyNode> s2 = e.getSecond();
-            s1.forEach(e1 -> {
-                s2.forEach(e2 -> {
-                    if (!e1.equals(e2)) {
-                        edges.add(new KnowledgeEdge(e1.getName(), e2.getName()));
-                    }
-                });
-            });
-        });
-
-        return edges;
-    }
-
     /**
      * Iterator over the knowledge's explicitly forbidden edges.
      */
@@ -337,27 +319,6 @@ public class Knowledge2 implements TetradSerializable, IKnowledge {
         return edges.iterator();
     }
 
-    @Override
-    public List<KnowledgeEdge> getListOfExplicitlyForbiddenEdges() {
-        Set<OrderedPair<Set<MyNode>>> copy = new HashSet<>(forbiddenRulesSpecs);
-        copy.removeAll(forbiddenTierRules());
-
-        knowledgeGroups.forEach(e -> copy.remove(knowledgeGroupRules.get(e)));
-
-        List<KnowledgeEdge> edges = new LinkedList<>();
-        copy.forEach(e -> {
-            Set<MyNode> s1 = e.getFirst();
-            Set<MyNode> s2 = e.getSecond();
-            s1.forEach(e1 -> {
-                s2.forEach(e2 -> {
-                    edges.add(new KnowledgeEdge(e1.getName(), e2.getName()));
-                });
-            });
-        });
-
-        return edges;
-    }
-
     /**
      * @return the list of edges not in any tier.
      */
@@ -417,7 +378,7 @@ public class Knowledge2 implements TetradSerializable, IKnowledge {
         }
 
         if (isForbiddenByTiers(var1, var2)) {
-            return true;
+            return false;
         }
 
         return false;
@@ -673,25 +634,6 @@ public class Knowledge2 implements TetradSerializable, IKnowledge {
         return edges.iterator();
     }
 
-    @Override
-    public List<KnowledgeEdge> getListOfRequiredEdges() {
-        List<KnowledgeEdge> edges = new LinkedList<>();
-
-        requiredRulesSpecs.forEach(e -> {
-            Set<MyNode> s1 = e.getFirst();
-            Set<MyNode> s2 = e.getSecond();
-            s1.forEach(e1 -> {
-                s2.forEach(e2 -> {
-                    if (!e1.equals(e2)) {
-                        edges.add(new KnowledgeEdge(e1.getName(), e2.getName()));
-                    }
-                });
-            });
-        });
-
-        return edges;
-    }
-
     /**
      * Iterator over the KnowledgeEdge's explicitly required edges.
      */
@@ -699,11 +641,6 @@ public class Knowledge2 implements TetradSerializable, IKnowledge {
         return requiredEdgesIterator();
     }
 
-    @Override
-    public List<KnowledgeEdge> getListOfExplicitlyRequiredEdges() {
-        return getListOfRequiredEdges();
-    }
-
     /**
      * Marks the edge var1 --> var2 as forbid.
      *
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/VerticalDoubleDataBox.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/VerticalDoubleDataBox.java
index 09426a4b..9759b2f9 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/data/VerticalDoubleDataBox.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/data/VerticalDoubleDataBox.java
@@ -135,7 +135,7 @@ public class VerticalDoubleDataBox implements DataBox {
             System.arraycopy(data[i], 0, copy[i], 0, data[0].length);
         }
 
-        return new VerticalDoubleDataBox(copy);
+        return new VerticalDoubleDataBox(data);
     }
 
     /**
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/graph/GraphUtils.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/graph/GraphUtils.java
index 321812a0..c8e0ae9f 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/graph/GraphUtils.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/graph/GraphUtils.java
@@ -2456,9 +2456,8 @@ public final class GraphUtils {
             if (xml) {
                 out.print(graphToXml(graph));
             } else {
-                out.print(graph);
+                out.println(graph);
             }
-            out.flush();
             out.close();
         } catch (IOException e1) {
             throw new IllegalArgumentException(
@@ -2541,7 +2540,7 @@ public final class GraphUtils {
                 break;
             }
 
-//            System.out.println(line);
+            System.out.println(line);
 
             String[] tokens = line.split("\\s+");
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/graph/MisclassificationUtils.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/graph/MisclassificationUtils.java
index 640218bd..5516c431 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/graph/MisclassificationUtils.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/graph/MisclassificationUtils.java
@@ -129,9 +129,6 @@ public class MisclassificationUtils {
     public static String edgeMisclassifications(Graph estGraph, Graph refGraph) {
         StringBuilder builder = new StringBuilder();
 
-        estGraph = GraphUtils.replaceNodes(estGraph, refGraph.getNodes());
-        refGraph = GraphUtils.replaceNodes(refGraph, estGraph.getNodes());
-
         TextTable table2 = new TextTable(9, 7);
 
         table2.setToken(1, 0, "---");
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/AlassoRegression.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/AlassoRegression.java
deleted file mode 100644
index 57c050b4..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/AlassoRegression.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package edu.cmu.tetrad.search;
-
-// I am translating this from Kun's matlab code.
-
-import edu.cmu.tetrad.util.StatUtils;
-import edu.cmu.tetrad.util.TetradMatrix;
-import edu.cmu.tetrad.util.TetradVector;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class AlassoRegression {
-
-    public AlassoRegression(TetradMatrix x, TetradMatrix y, double varNoise, double lambda) {
-
-        x = x.transpose();
-        y = y.transpose();
-
-//        var_noise_back = var_noise;
-
-        double varNoiseBack = varNoise;
-
-//
-//        Trad1 = 0.2; Trad2 = 1 - Trad1;
-
-        double trad1 = 0.2;
-        double trad2 = 1 - trad1;
-        int N = x.columns();
-        int T = x.rows();
-
-//[N,T] = size(x);
-
-        double tol = 1e-2;
-
-        double betaMin = 1e-12;
-        double betaMin2 = 1e-2;
-
-        List<Double> sumAdjustBeta = new ArrayList<>();
-        List<Double> pl = new ArrayList<>();
-
-//        tol = 1E-2; % 1E-10; %%% temp: Aug 5, 17:27
-//        beta_min = 1E-12;
-//        beta_min2 = 1E-2;
-//        sum_adjust_beta = [];
-//        pl = [];
-
-        TetradMatrix betaHat = (x.transpose()).times((x.times(x.transpose())).inverse()).times(y);
-
-//
-//        beta_hat = y*x' * inv(x*x');
-
-        if (varNoise == 0) {
-            StatUtils.variance(y.minus(betaHat.times(x)).toArray()[0]); // maybe transpose.
-        }
-
-
-//        if var_noise == 0
-//        var_noise = var(y - beta_hat*x);
-//        end
-
-
-        TetradMatrix xNew = betaHat.diag().diag().times(x);
-
-//        x_new = diag(beta_hat) * x;
-
-        double error = 1;
-//        Error = 1;
-
-        TetradMatrix betaNeoO = ones(N, 1);
-
-//        beta_new_o = ones(N,1);
-//% beta_new_o = 1E-5 * ones(N,1);
-//
-//% store for curve plotting
-//        sum_adjust_beta = [sum_adjust_beta sum(abs(beta_new_o))];
-//        pl = [pl (y-beta_new_o'*x_new)*(y-beta_new_o'*x_new)'/2/var_noise + lambda * sum(abs(beta_new_o))];
-//
-//        while Error > tol
-//        Sigma = diag(1./abs(beta_new_o));
-//    %     Sigma = diag(1./beta_new_o); % this is wrong?
-//    %     beta_new_n = inv(x_new*x_new' + var_noise*lambda * Sigma) * (x_new*y');
-//    % % with gradient trad-off!
-//                beta_new_n = inv(x_new*x_new' + var_noise*lambda * Sigma) * (x_new*y') * Trad1 + beta_new_o * Trad2 ;
-//        beta_new_n = sign(beta_new_n) .* max(abs(beta_new_n),beta_min);
-//        Error = norm(beta_new_n - beta_new_o);
-//        beta_new_o = beta_new_n;
-//        sum_adjust_beta = [sum_adjust_beta sum(abs(beta_new_n))];
-//        pl = [pl (y-beta_new_n'*x_new)*(y-beta_new_n'*x_new)'/2/var_noise + lambda * sum(abs(beta_new_n))];
-//        end
-
-
-    }
-
-    private TetradMatrix ones(int r, int c) {
-        TetradMatrix ones = new TetradMatrix(r, c);
-        for (int i = 0; i < r; i++) {
-            for (int j = 0; j < c; j++) {
-                ones.set(i, j, 1);
-            }
-        }
-
-        return ones;
-    }
-
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Cci.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Cci.java
index 434ca460..2d4c14ad 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Cci.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Cci.java
@@ -21,6 +21,7 @@
 
 package edu.cmu.tetrad.search;
 
+import edu.cmu.tetrad.util.StatUtils;
 import org.apache.commons.math3.distribution.NormalDistribution;
 import org.apache.commons.math3.linear.RealMatrix;
 
@@ -68,6 +69,16 @@ public final class Cci {
      */
     private NormalDistribution normal = new NormalDistribution(0, 1);
 
+    /**
+     * the most recent list of P values, for calculating Q.
+     */
+    private List<Double> scores;
+
+    /**
+     * Z cutoff corresponding to the desired alpha.
+     */
+    private final double cutoff;
+
     //==================CONSTRUCTORS====================//
 
     /**
@@ -86,6 +97,7 @@ public final class Cci {
         }
 
         this.alpha = alpha;
+        this.cutoff = StatUtils.getZForAlpha(alpha);
         this.data = data;
 
         indices = new HashMap<>();
@@ -120,8 +132,15 @@ public final class Cci {
         return score;
     }
 
-    public double getAlpha() {
-        return alpha;
+    /**
+     * @return FDR Q, if calculated, otherwise Double.NaN.
+     */
+    private double getQ(List<Double> p) {
+        return calculateFdrQ(p);
+    }
+
+    public double getQ() {
+        return getQ(scores);
     }
 
     /**
@@ -165,23 +184,33 @@ public final class Cci {
         double[] _x = new double[x.length];
         double[] _y = new double[x.length];
 
-        double minScore = Double.POSITIVE_INFINITY;
+        List<Double> scores = new ArrayList<>();
 
-        for (int m = 1; m <= getNumFunctions(); m++) {
-            for (int n = 1; n <= getNumFunctions(); n++) {
+        for (int m = 0; m < getNumFunctions(); m++) {
+            for (int n = 0; n < getNumFunctions(); n++) {
                 for (int i = 0; i < x.length; i++) {
                     _x[i] = function(m, x[i]);
                     _y[i] = function(n, y[i]);
                 }
 
-                final double score = calcScore(_x, _y);
-                if (score < minScore) minScore = score;
+                scores.add(calcScore(_x, _y));
             }
         }
 
-        this.score = 1.0 - minScore;
+        Collections.sort(scores);
+//        double cutoff = fdr(alpha, scores, true);
+        double max = scores.size() == 0 ? Double.NaN : scores.get(scores.size() - 1);
+        this.score = max;
+
+        this.scores = scores;
 
-        return minScore > alpha;
+//        if (Double.isNaN(min)) {
+//            this.score = Double.NaN;
+//            return true; // No basis on which to remove an edge for PC.
+//        }
+
+        return score < 0;
+//        return getQ(scores) > alpha;
     }
 
     private double calcScore(double[] _x, double[] _y) {
@@ -191,17 +220,23 @@ public final class Cci {
 
         double r = sigmaXY / sqrt(sigmaXX * sigmaYY);
 
+        if (r > 1) r = 1;
+        if (r < -1) r = -1;
+
         // Non-parametric Fisher Z test.
         double _z = 0.5 * (log(1.0 + r) - log(1.0 - r));
-        final double N = _x.length;
-        double w = sqrt(N) * _z;
+        double w = sqrt(_x.length) * _z;
 
         // Testing the hypothesis that _x and _y are uncorrelated and assuming that 4th moments of _x and _y
         // are finite and that the sample is large.
-        _x = standardize(_x);
-        _y = standardize(_y);
+        standardize(_x);
+        standardize(_y);
 
-        return 2.0 * (1.0 - normalCdf(0.0, sqrt(moment22(_x, _y)), abs(w)));
+        double t2 = moment22(_x, _y);
+
+        double t = sqrt(t2);
+        return abs(w / t) - cutoff;
+//        return 2.0 * (1.0 - normalCdf(0.0 , t, abs));
     }
 
     /**
@@ -311,11 +346,9 @@ public final class Cci {
 
     // Polynomial basis. The 1 is left out according to Daudin.
     private double function(int index, double x) {
-//        return sin((index) * x) + cos((index) * x); // This would be a sin cosine basis.
-
         double g = 1.0;
 
-        for (int i = 1; i <= index; i++) {
+        for (int i = 0; i <= index; i++) {
             g *= x;
         }
 
@@ -324,7 +357,7 @@ public final class Cci {
 
     // The number of basis functions to use.
     private int getNumFunctions() {
-        return 8;
+        return 15;
     }
 
     private double covariance(double[] x, double[] y) {
@@ -342,6 +375,7 @@ public final class Cci {
         return sumXY / N - (sumX / N) * (sumY / N);
     }
 
+
     // Optimal bandwidth qsuggested by Bowman and Azzalini (1997) q.31,
     // using MAD.
     private double h(String x) {
@@ -376,9 +410,7 @@ public final class Cci {
     }
 
     // Standardizes the given data array.
-    private double[] standardize(double[] data1) {
-        double[] data = Arrays.copyOf(data1, data1.length);
-
+    private void standardize(double[] data) {
         double sum = 0.0;
 
         for (double d : data) {
@@ -403,13 +435,65 @@ public final class Cci {
         for (int i = 0; i < data.length; i++) {
             data[i] /= sd;
         }
+    }
+
+    // False discovery rate, assuming non-negative correlations.
+    private double fdr(double alpha, List<Double> pValues, boolean pSorted) {
+        if (!pSorted) {
+            pValues = new ArrayList<>(pValues);
+            Collections.sort(pValues);
+        }
+
+        int m = pValues.size();
+
+        int index = -1;
+
+        for (int k = 0; k < m; k++) {
+            if (pValues.get(k) <= ((k + 1) / (double) (m + 1)) * alpha) {
+                index = k;
+            }
+        }
 
-        return data;
+        return index == -1 ? 0 : pValues.get(index);
     }
 
     private double normalCdf(double mean, double sd, double value) {
         return normal.cumulativeProbability((value - mean) / sd);
     }
+
+    public double calculateFdrQ() {
+        return calculateFdrQ(scores);
+    }
+
+    public synchronized double calculateFdrQ(List<Double> p) {
+
+        // If a legitimate scores value is desired for this test, should estimate the FDR q value.
+        Collections.sort(p);
+        double min = p.size() == 0 ? Double.NaN : p.get(0);
+        double high = 1.0;
+        double low = 0.0;
+        double q = alpha;
+
+        while (high - low > 1e-5) {
+            double midpoint = (high + low) / 2.0;
+            q = midpoint;
+            boolean sorted = true;
+
+            double _cutoff = fdr(q, p, sorted);
+
+            if (_cutoff < min) {
+                low = midpoint;
+            } else if (_cutoff > min) {
+                high = midpoint;
+            } else {
+                low = midpoint;
+                high = midpoint;
+            }
+        }
+
+        return q;
+    }
+
 }
 
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Cefs.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Cefs.java
index ca6aa86e..9e20dc5d 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Cefs.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Cefs.java
@@ -367,10 +367,6 @@ public final class Cefs {
         return this.depth;
     }
 
-    public void setDepth(int depth) {
-        this.depth = depth;
-    }
-
     /**
      * @return the result graph of the most recent search.
      */
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/DagSepsets.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/DagSepsets.java
index 9599e887..9a086c1c 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/DagSepsets.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/DagSepsets.java
@@ -21,7 +21,6 @@
 
 package edu.cmu.tetrad.search;
 
-import edu.cmu.tetrad.graph.EdgeListGraph;
 import edu.cmu.tetrad.graph.EdgeListGraphSingleConnections;
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.graph.Node;
@@ -35,11 +34,11 @@ import java.util.List;
  * @author Joseph Ramsey
  */
 public class DagSepsets implements SepsetProducer {
-    private EdgeListGraph dag;
+    private EdgeListGraphSingleConnections dag;
     private boolean verbose = false;
 
     public DagSepsets(Graph dag) {
-        this.dag = new EdgeListGraph(dag);
+        this.dag = new EdgeListGraphSingleConnections(dag);
     }
 
     @Override
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/FasLofs.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/FasLofs.java
index afa277d1..5d6dcce9 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/FasLofs.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/FasLofs.java
@@ -29,7 +29,6 @@ import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.graph.Node;
 
 import java.util.Collections;
-import java.util.List;
 
 /**
  * Fast adjacency search followed by robust skew orientation. Checks are done for adding
@@ -77,37 +76,32 @@ public final class FasLofs implements GraphSearch {
      * and some of the adjacencies may be two-cycles.
      */
     public Graph search() {
+        long start = System.currentTimeMillis();
+
         SemBicScore score = new SemBicScore(new CovarianceMatrixOnTheFly(dataSet));
         score.setPenaltyDiscount(penaltyDiscount);
         IndependenceTest test = new IndTestScore(score, dataSet);
 
         System.out.println("FAS");
 
-//        Score scoredIndTest = new ScoredIndTest(test);
-//        Fges fges = new Fges(scoredIndTest);
-//        fges.setMaxDegree(5);
-//        fges.setKnowledge(knowledge);
-//        Graph G0 = fges.search();
-
         FasStable fas = new FasStable(test);
         fas.setDepth(getDepth());
         fas.setVerbose(false);
         fas.setKnowledge(knowledge);
         Graph G0 = fas.search();
 
-        return orient(G0);
-    }
-
-    public Graph orient(Graph g0) {
         System.out.println("LOFS orientation, rule " + rule);
 
-        Lofs2 lofs2 = new Lofs2(g0, Collections.singletonList(dataSet));
+        Lofs2 lofs2 = new Lofs2(G0, Collections.singletonList(dataSet));
         lofs2.setRule(rule);
         lofs2.setKnowledge(knowledge);
         Graph graph = lofs2.orient();
 
         System.out.println("Done");
 
+        long stop = System.currentTimeMillis();
+        this.elapsed = stop - start;
+
         return graph;
     }
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Fask.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Fask.java
index 7f562c4f..862f11db 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Fask.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Fask.java
@@ -410,4 +410,3 @@ public final class Fask implements GraphSearch {
 
 
 
-
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Fask2.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Fask2.java
deleted file mode 100644
index ae4c5907..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Fask2.java
+++ /dev/null
@@ -1,605 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (c) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.search;
-
-import edu.cmu.tetrad.data.DataSet;
-import edu.cmu.tetrad.data.DataUtils;
-import edu.cmu.tetrad.data.IKnowledge;
-import edu.cmu.tetrad.data.Knowledge2;
-import edu.cmu.tetrad.graph.*;
-import edu.cmu.tetrad.util.DepthChoiceGenerator;
-import edu.cmu.tetrad.util.StatUtils;
-import edu.cmu.tetrad.util.TetradMatrix;
-import org.apache.commons.math3.distribution.NormalDistribution;
-import org.apache.commons.math3.linear.SingularMatrixException;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import static java.lang.Math.*;
-
-/**
- * Fast adjacency search followed by robust skew orientation. Checks are done for adding
- * two-cycles. The two-cycle checks do not require non-Gaussianity. The robust skew
- * orientation of edges left or right does.
- *
- * @author Joseph Ramsey
- */
-public final class Fask2 implements GraphSearch {
-
-    // The score to be used for the FAS adjacency search.
-    private final Score score;
-
-    // An initial graph to orient, skipping the adjacency step.
-    private Graph initialGraph = null;
-
-    // Elapsed time of the search, in milliseconds.
-    private long elapsed = 0;
-
-    // The data sets being analyzed. They must all have the same variables and the same
-    // number of records.
-    private DataSet dataSet = null;
-
-    // For the Fast Adjacency Search.
-    private int depth = -1;
-
-    // For the SEM BIC score, for the Fast Adjacency Search.
-    private double penaltyDiscount = 1;
-
-    // Alpha for orienting 2-cycles. Usually needs to be low.
-    private double alpha = 1e-6;
-
-    // Knowledge the the search will obey, of forbidden and required edges.
-    private IKnowledge knowledge = new Knowledge2();
-
-    // Data as a double[][].
-    private final double[][] data;
-
-    // Cutoff for T tests for 2-cycle tests.
-    private double cutoff;
-
-    private boolean reverseOrientationsBySignOfCorrelation = true;
-    private boolean reverseOrientationsBySkewnessOfVariables = true;
-
-    private double extraEdgeThreshold = 0.3;
-    private boolean useFasAdjacencies = true;
-    private boolean useCorrDiffAdjacencies = true;
-
-    /**
-     * @param dataSet These datasets must all have the same variables, in the same order.
-     */
-    public Fask2(DataSet dataSet, Score score) {
-        this.dataSet = dataSet;
-        this.score = score;
-
-        data = dataSet.getDoubleData().transpose().toArray();
-    }
-
-    //======================================== PUBLIC METHODS ====================================//
-
-    /**
-     * Runs the search on the concatenated data, returning a graph, possibly cyclic, possibly with
-     * two-cycles. Runs the fast adjacency search (FAS, Spirtes et al., 2000) follows by a modification
-     * of the robust skew rule (Pairwise Likelihood Ratios for Estimation of Non-Gaussian Structural
-     * Equation Models, Smith and Hyvarinen), together with some heuristics for orienting two-cycles.
-     *
-     * @return the graph. Some of the edges may be undirected (though it shouldn't be many in most cases)
-     * and some of the adjacencies may be two-cycles.
-     */
-    public Graph search() {
-        long start = System.currentTimeMillis();
-
-        setCutoff(alpha);
-
-        DataSet dataSet = DataUtils.standardizeData(this.dataSet);
-
-        List<Node> variables = dataSet.getVariables();
-        double[][] colData = dataSet.getDoubleData().transpose().toArray();
-        Graph G0;
-
-        if (getInitialGraph() != null) {
-            Graph g1 = new EdgeListGraph(getInitialGraph().getNodes());
-
-            for (Edge edge : getInitialGraph().getEdges()) {
-                Node x = edge.getNode1();
-                Node y = edge.getNode2();
-
-                if (!g1.isAdjacentTo(x, y)) g1.addUndirectedEdge(x, y);
-            }
-
-            g1 = GraphUtils.replaceNodes(g1, dataSet.getVariables());
-
-            G0 = g1;
-        } else {
-            IndependenceTest test = new IndTestScore(score, dataSet);
-
-            System.out.println("FAS");
-
-            FasStable fas = new FasStable(test);
-            fas.setDepth(getDepth());
-            fas.setVerbose(false);
-            fas.setKnowledge(knowledge);
-            G0 = fas.search();
-        }
-
-        SearchGraphUtils.pcOrientbk(knowledge, G0, G0.getNodes());
-
-        System.out.println("Orientation");
-
-        Graph graph = new EdgeListGraph(variables);
-
-        for (int i = 0; i < variables.size(); i++) {
-            for (int j = i + 1; j < variables.size(); j++) {
-                Node X = variables.get(i);
-                Node Y = variables.get(j);
-
-                // Centered
-                final double[] x = colData[i];
-                final double[] y = colData[j];
-
-                double c1 = StatUtils.cov(x, y, x, 0, +1)[1];
-                double c2 = StatUtils.cov(x, y, y, 0, +1)[1];
-
-                if ((isUseFasAdjacencies() && G0.isAdjacentTo(X, Y)) || /*|| (alsoAdjacent(x, y, G0, X, Y))) {//*/(isUseCorrDiffAdjacencies() && Math.abs(c1 - c2) > getExtraEdgeThreshold())) {
-                    if (knowledgeOrients(X, Y)) {
-                        graph.addDirectedEdge(X, Y);
-                    } else if (knowledgeOrients(Y, X)) {
-                        graph.addDirectedEdge(Y, X);
-                    } else if (bidirected(x, y, G0, X, Y)) {
-                        Edge edge1 = Edges.directedEdge(X, Y);
-                        Edge edge2 = Edges.directedEdge(Y, X);
-                        graph.addEdge(edge1);
-                        graph.addEdge(edge2);
-                    }
-//                    else if (leftright2(x, y, G0, X, Y)) {
-//                        graph.addDirectedEdge(X, Y);
-//                    } else if (leftright2(y, x, G0, Y, X)) {
-//                        graph.addDirectedEdge(X, Y);
-//                    }
-                    else if (leftright(x, y)) {
-                        graph.addDirectedEdge(X, Y);
-                    } else {
-                        graph.addDirectedEdge(Y, X);
-                    }
-                }
-            }
-        }
-
-        Graph graph2 = new EdgeListGraph(graph.getNodes());
-
-        for (int i = 0; i < variables.size(); i++) {
-            for (int j = i + 1; j < variables.size(); j++) {
-
-                Node X = variables.get(i);
-                Node Y = variables.get(j);
-
-                final double[] x = colData[i];
-                final double[] y = colData[j];
-
-                boolean still = stillAdjacent(x, y, graph, G0, X, Y);
-
-                if (still) {
-                    List<Edge> e = graph.getEdges(X, Y);
-
-                    if (e.size() == 0) {
-                        graph2.addUndirectedEdge(X, Y);
-                    } else {
-                        for (Edge edge : e) {
-                            graph2.addEdge(edge);
-                        }
-                    }
-                }
-            }
-        }
-
-        System.out.println();
-        System.out.println("Done");
-
-        long stop = System.currentTimeMillis();
-        this.elapsed = stop - start;
-
-        return graph;
-    }
-
-    private boolean bidirected(double[] x, double[] y, Graph G0, Node X, Node Y) {
-
-        Set<Node> adjSet = new HashSet<Node>(G0.getAdjacentNodes(X));
-        adjSet.addAll(G0.getAdjacentNodes(Y));
-        List<Node> adj = new ArrayList<>(adjSet);
-        adj.remove(X);
-        adj.remove(Y);
-
-        DepthChoiceGenerator gen = new DepthChoiceGenerator(adj.size(), Math.min(depth, adj.size()));
-        int[] choice;
-
-        while ((choice = gen.next()) != null) {
-            List<Node> _adj = GraphUtils.asList(choice, adj);
-            double[][] _Z = new double[_adj.size()][];
-
-            for (int f = 0; f < _adj.size(); f++) {
-                Node _z = _adj.get(f);
-                int column = dataSet.getColumn(_z);
-                _Z[f] = data[column];
-            }
-
-            double pc = partialCorrelation(x, y, _Z, x, Double.NEGATIVE_INFINITY, +1);
-            double pc1 = partialCorrelation(x, y, _Z, x, 0, +1);
-            double pc2 = partialCorrelation(x, y, _Z, y, 0, +1);
-
-            int nc = StatUtils.getRows(x, x, Double.NEGATIVE_INFINITY, +1).size();
-            int nc1 = StatUtils.getRows(x, x, 0, +1).size();
-            int nc2 = StatUtils.getRows(y, y, 0, +1).size();
-
-            double z = 0.5 * (log(1.0 + pc) - log(1.0 - pc));
-            double z1 = 0.5 * (log(1.0 + pc1) - log(1.0 - pc1));
-            double z2 = 0.5 * (log(1.0 + pc2) - log(1.0 - pc2));
-
-            double zv1 = (z - z1) / sqrt((1.0 / ((double) nc - 3) + 1.0 / ((double) nc1 - 3)));
-            double zv2 = (z - z2) / sqrt((1.0 / ((double) nc - 3) + 1.0 / ((double) nc2 - 3)));
-
-//            double p1 = 2 * (1.0 - new NormalDistribution(0, 1).cumulativeProbability(abs(zv1)));
-//            double p2 = 2 * (1.0 - new NormalDistribution(0, 1).cumulativeProbability(abs(zv2)));
-
-//            boolean rejected1 = p1 < twoCycleAlpha;
-//            boolean rejected2 = p2 < twoCycleAlpha;
-
-            boolean rejected1 = abs(zv1) > cutoff;
-            boolean rejected2 = abs(zv2) > cutoff;
-
-            boolean possibleTwoCycle = false;
-
-            if (zv1 < 0 && zv2 > 0 && rejected1) {
-                possibleTwoCycle = true;
-            } else if (zv1 > 0 && zv2 < 0 && rejected2) {
-                possibleTwoCycle = true;
-            } else if (rejected1 && rejected2) {
-                possibleTwoCycle = true;
-            }
-
-            if (!possibleTwoCycle) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    private boolean alsoAdjacent(double[] x, double[] y, Graph G0, Node X, Node Y) {
-
-        Set<Node> adjSet = new HashSet<Node>(G0.getParents(X));
-        adjSet.addAll(G0.getParents(Y));
-        List<Node> _adj = new ArrayList<>(adjSet);
-        _adj.remove(X);
-        _adj.remove(Y);
-//
-//        DepthChoiceGenerator gen = new DepthChoiceGenerator(adj.size(), Math.min(depth, adj.size()));
-//        int[] choice;
-//
-//        while ((choice = gen.next()) != null) {
-//        List<Node> _adj = GraphUtils.asList(choice, G0.getParents(X));
-        double[][] _Z = new double[_adj.size()][];
-
-        for (int f = 0; f < _adj.size(); f++) {
-            Node _z = _adj.get(f);
-            int column = dataSet.getColumn(_z);
-            _Z[f] = data[column];
-        }
-
-        double pc1 = partialCorrelation(x, y, _Z, x, 0, +1);
-        double pc2 = partialCorrelation(x, y, _Z, y, 0, +1);
-
-        int nc1 = StatUtils.getRows(x, x, 0, +1).size();
-        int nc2 = StatUtils.getRows(y, y, 0, +1).size();
-
-        double z1 = 0.5 * (log(1.0 + pc1) - log(1.0 - pc1));
-        double z2 = 0.5 * (log(1.0 + pc2) - log(1.0 - pc2));
-
-        double zv1 = (z1 - z2) / sqrt((1.0 / ((double) nc1 - 3) + 1.0 / ((double) nc2 - 3)));
-        double p1 = 2 * (1.0 - new NormalDistribution(0, 1).cumulativeProbability(abs(zv1)));
-
-        System.out.println(p1);
-
-        if (p1 > .5) {
-            return false;
-        }
-//        }
-
-        return true;
-    }
-
-    private boolean leftright2(double[] x, double[] y, Graph G0, Node X, Node Y) {
-
-        Set<Node> adjSet = new HashSet<Node>(G0.getAdjacentNodes(X));
-        adjSet.addAll(G0.getAdjacentNodes(Y));
-        List<Node> adj = new ArrayList<>(adjSet);
-        adj.remove(X);
-        adj.remove(Y);
-
-        DepthChoiceGenerator gen = new DepthChoiceGenerator(adj.size(), Math.min(depth, adj.size()));
-        int[] choice;
-
-        while ((choice = gen.next()) != null) {
-            List<Node> _adj = GraphUtils.asList(choice, adj);
-            double[][] _Z = new double[_adj.size()][];
-
-            for (int f = 0; f < _adj.size(); f++) {
-                Node _z = _adj.get(f);
-                int column = dataSet.getColumn(_z);
-                _Z[f] = data[column];
-            }
-
-            double pc = partialCorrelation(x, y, _Z, x, Double.NEGATIVE_INFINITY, +1);
-            double pc1 = partialCorrelation(x, y, _Z, x, 0, +1);
-            double pc2 = partialCorrelation(x, y, _Z, y, 0, +1);
-
-            int nc = StatUtils.getRows(x, x, Double.NEGATIVE_INFINITY, +1).size();
-            int nc1 = StatUtils.getRows(x, x, 0, +1).size();
-            int nc2 = StatUtils.getRows(y, y, 0, +1).size();
-
-            double z = 0.5 * (log(1.0 + pc) - log(1.0 - pc));
-            double z1 = 0.5 * (log(1.0 + pc1) - log(1.0 - pc1));
-            double z2 = 0.5 * (log(1.0 + pc2) - log(1.0 - pc2));
-
-            double zv1 = (z - z1) / sqrt((1.0 / ((double) nc - 3) + 1.0 / ((double) nc1 - 3)));
-            double zv2 = (z - z2) / sqrt((1.0 / ((double) nc - 3) + 1.0 / ((double) nc2 - 3)));
-
-//            double p1 = 2 * (1.0 - new NormalDistribution(0, 1).cumulativeProbability(abs(zv1)));
-//            double p2 = 2 * (1.0 - new NormalDistribution(0, 1).cumulativeProbability(abs(zv2)));
-
-//            boolean rejected1 = p1 < twoCycleAlpha;
-//            boolean rejected2 = p2 < twoCycleAlpha;
-
-            boolean rejected1 = abs(zv1) > cutoff;
-            boolean rejected2 = abs(zv2) > cutoff;
-
-            boolean possibleTwoCycle = false;
-
-            if (zv1 < 0 && zv2 > 0 && rejected1) {
-                possibleTwoCycle = true;
-            } else if (zv1 > 0 && zv2 < 0 && rejected2) {
-                possibleTwoCycle = true;
-            } else if (rejected1 && rejected2) {
-                possibleTwoCycle = true;
-            }
-
-            if (!possibleTwoCycle && !rejected2 && rejected1) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    private boolean stillAdjacent(double[] x, double[] y, Graph graph, Graph G0, Node X, Node Y) {
-        if (graph.isAdjacentTo(X, Y)) return true;
-
-        Set<Node> adjSet = new HashSet<>(graph.getParents(X));
-        adjSet.addAll(graph.getParents(Y));
-        List<Node> adj = new ArrayList<>(adjSet);
-        adj.remove(X);
-        adj.remove(Y);
-
-        double[][] _Z = new double[adj.size()][];
-
-        for (int f = 0; f < adj.size(); f++) {
-            Node _z = adj.get(f);
-            int column = dataSet.getColumn(_z);
-            _Z[f] = data[column];
-        }
-
-        double pc1 = partialCorrelation(x, y, _Z, x, 0, +1);
-        double pc2 = partialCorrelation(x, y, _Z, y, 0, +1);
-
-        int nc1 = StatUtils.getRows(x, x, 0, +1).size();
-        int nc2 = StatUtils.getRows(y, y, 0, +1).size();
-
-        double z1 = 0.5 * (log(1.0 + pc1) - log(1.0 - pc1));
-        double z2 = 0.5 * (log(1.0 + pc2) - log(1.0 - pc2));
-
-        double zv1 = (z1 - z2) / sqrt((1.0 / ((double) nc1 - 3) + 1.0 / ((double) nc2 - 3)));
-
-//        double p1 = 2 * (1.0 - new NormalDistribution(0, 1).cumulativeProbability(abs(zv1)));
-
-//        System.out.println("p1 = " + p1);
-
-        return zv1 > cutoff;
-    }
-
-    private boolean leftright(double[] x, double[] y) {
-        double left = cu(x, y, x) / (sqrt(cu(x, x, x) * cu(y, y, x)));
-        double right = cu(x, y, y) / (sqrt(cu(x, x, y) * cu(y, y, y)));
-        double lr = left - right;
-
-        if (isReverseOrientationsBySignOfCorrelation()) {
-            lr *= signum(StatUtils.correlation(x, y));
-        }
-
-        if (isReverseOrientationsBySkewnessOfVariables()) {
-            double sd = sqrt(6.0 / dataSet.getNumRows());
-
-            double sx = StatUtils.skewness(x);
-            double sy = StatUtils.skewness(y);
-
-            if (abs(sx) > 4 * sd && abs(sy) > 4 * sd) {
-                lr *= signum(sx) * signum(sy);
-            }
-        }
-
-        return lr > 0;
-    }
-
-    public static double cu(double[] x, double[] y, double[] condition) {
-        double exy = 0.0;
-
-        int n = 0;
-
-        for (int k = 0; k < x.length; k++) {
-            if (condition[k] > 0) {
-                exy += x[k] * y[k];
-                n++;
-            }
-        }
-
-        return exy / n;
-    }
-
-    private double partialCorrelation(double[] x, double[] y, double[][] z, double[] condition, double threshold, double direction) throws SingularMatrixException {
-        double[][] cv = StatUtils.covMatrix(x, y, z, condition, threshold, direction);
-        TetradMatrix m = new TetradMatrix(cv).transpose();
-        return StatUtils.partialCorrelation(m);
-    }
-
-    /**
-     * Sets the significance level at which independence judgments should be made.  Affects the cutoff for partial
-     * correlations to be considered statistically equal to zero.
-     */
-    private void setCutoff(double alpha) {
-        if (alpha < 0.0 || alpha > 1.0) {
-            throw new IllegalArgumentException("Significance out of range: " + alpha);
-        }
-
-        this.cutoff = StatUtils.getZForAlpha(alpha);
-    }
-
-    /**
-     * @return The depth of search for the Fast Adjacency Search (FAS).
-     */
-
-    public int getDepth() {
-        return depth;
-    }
-
-    /**
-     * @param depth The depth of search for the Fast Adjacency Search (S). The default is -1.
-     *              unlimited. Making this too high may results in statistical errors.
-     */
-    public void setDepth(int depth) {
-        this.depth = depth;
-    }
-
-    /**
-     * @return The elapsed time in milliseconds.
-     */
-    public long getElapsedTime() {
-        return elapsed;
-    }
-
-    /**
-     * @return Returns the penalty discount used for the adjacency search. The default is 1,
-     * though a higher value is recommended, say, 2, 3, or 4.
-     */
-    public double getPenaltyDiscount() {
-        return penaltyDiscount;
-    }
-
-    /**
-     * @param penaltyDiscount Sets the penalty discount used for the adjacency search.
-     *                        The default is 1, though a higher value is recommended, say,
-     *                        2, 3, or 4.
-     */
-    public void setPenaltyDiscount(double penaltyDiscount) {
-        this.penaltyDiscount = penaltyDiscount;
-    }
-
-    /**
-     * @param alpha Alpha for orienting 2-cycles. Needs to be on the low side usually. Default 1e-6.
-     */
-    public void setAlpha(double alpha) {
-        this.alpha = alpha;
-    }
-
-    /**
-     * @return the current knowledge.
-     */
-    public IKnowledge getKnowledge() {
-        return knowledge;
-    }
-
-    /**
-     * @param knowledge Knowledge of forbidden and required edges.
-     */
-    public void setKnowledge(IKnowledge knowledge) {
-        this.knowledge = knowledge;
-    }
-
-    //======================================== PRIVATE METHODS ====================================//
-
-    private boolean knowledgeOrients(Node left, Node right) {
-        return knowledge.isForbidden(right.getName(), left.getName()) || knowledge.isRequired(left.getName(), right.getName());
-    }
-
-    public Graph getInitialGraph() {
-        return initialGraph;
-    }
-
-    public void setInitialGraph(Graph initialGraph) {
-        this.initialGraph = initialGraph;
-    }
-
-    public void setReverseOrientationsBySignOfCorrelation(boolean reverseOrientationsBySignOfCorrelation) {
-        this.reverseOrientationsBySignOfCorrelation = reverseOrientationsBySignOfCorrelation;
-    }
-
-    public double getExtraEdgeThreshold() {
-        return extraEdgeThreshold;
-    }
-
-    public void setExtraEdgeThreshold(double extraEdgeThreshold) {
-        this.extraEdgeThreshold = extraEdgeThreshold;
-    }
-
-    public boolean isUseFasAdjacencies() {
-        return useFasAdjacencies;
-    }
-
-    public void setUseFasAdjacencies(boolean useFasAdjacencies) {
-        this.useFasAdjacencies = useFasAdjacencies;
-    }
-
-    public boolean isUseCorrDiffAdjacencies() {
-        return useCorrDiffAdjacencies;
-    }
-
-    public void setUseCorrDiffAdjacencies(boolean useCorrDiffAdjacencies) {
-        this.useCorrDiffAdjacencies = useCorrDiffAdjacencies;
-    }
-
-    public boolean isReverseOrientationsBySkewnessOfVariables() {
-        return reverseOrientationsBySkewnessOfVariables;
-    }
-
-    public void setReverseOrientationsBySkewnessOfVariables(boolean reverseOrientationsBySkewnessOfVariables) {
-        this.reverseOrientationsBySkewnessOfVariables = reverseOrientationsBySkewnessOfVariables;
-    }
-
-    public boolean isReverseOrientationsBySignOfCorrelation() {
-        return reverseOrientationsBySignOfCorrelation;
-    }
-}
-
-
-
-
-
-
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/FaskMixed.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/FaskMixed.java
deleted file mode 100644
index 45c33704..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/FaskMixed.java
+++ /dev/null
@@ -1,464 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (c) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.search;
-
-import edu.cmu.tetrad.data.DataSet;
-import edu.cmu.tetrad.data.DataUtils;
-import edu.cmu.tetrad.data.IKnowledge;
-import edu.cmu.tetrad.data.Knowledge2;
-import edu.cmu.tetrad.graph.*;
-import edu.cmu.tetrad.util.DepthChoiceGenerator;
-import edu.cmu.tetrad.util.StatUtils;
-import edu.cmu.tetrad.util.TetradMatrix;
-import org.apache.commons.math3.linear.SingularMatrixException;
-
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
-import static edu.cmu.tetrad.util.StatUtils.skewness;
-import static java.lang.Math.*;
-
-/**
- * Fast adjacency search followed by robust skew orientation. Checks are done for adding
- * two-cycles. The two-cycle checks do not require non-Gaussianity. The robust skew
- * orientation of edges left or right does.
- *
- * This one does the FAS search including mixed variable, then removes the mixed variable
- * and continues on with orientation.
- *
- * @author Joseph Ramsey
- */
-public final class FaskMixed implements GraphSearch {
-
-    // The score to be used for the FAS adjacency search.
-    private final Score score;
-
-    // An initial graph to orient, skipping the adjacency step.
-    private Graph initialGraph = null;
-
-    // Elapsed time of the search, in milliseconds.
-    private long elapsed = 0;
-
-    // The data sets being analyzed. They must all have the same variables and the same
-    // number of records.
-    private DataSet dataSet = null;
-
-    // For the Fast Adjacency Search.
-    private int depth = -1;
-
-    // For the SEM BIC score, for the Fast Adjacency Search.
-    private double penaltyDiscount = 1;
-
-    // Alpha for orienting 2-cycles. Usually needs to be low.
-    private double alpha = 1e-6;
-
-    // Knowledge the the search will obey, of forbidden and required edges.
-    private IKnowledge knowledge = new Knowledge2();
-
-    // Data as a double[][].
-    private final double[][] data;
-
-    // Cutoff for T tests for 2-cycle tests.
-    private double cutoff;
-
-    private boolean reverseOrientationsBySignOfCorrelation = true;
-    private boolean reverseOrientationsBySkewnessOfVariables = true;
-
-    private double extraEdgeThreshold = 0.3;
-    private boolean useFasAdjacencies = true;
-    private boolean useCorrDiffAdjacencies = true;
-
-    /**
-     * @param dataSet These datasets must all have the same variables, in the same order.
-     */
-    public FaskMixed(DataSet dataSet, Score score) {
-        this.dataSet = dataSet;
-        this.score = score;
-
-        data = dataSet.getDoubleData().transpose().toArray();
-    }
-
-    //======================================== PUBLIC METHODS ====================================//
-
-    /**
-     * Runs the search on the concatenated data, returning a graph, possibly cyclic, possibly with
-     * two-cycles. Runs the fast adjacency search (FAS, Spirtes et al., 2000) follows by a modification
-     * of the robust skew rule (Pairwise Likelihood Ratios for Estimation of Non-Gaussian Structural
-     * Equation Models, Smith and Hyvarinen), together with some heuristics for orienting two-cycles.
-     *
-     * @return the graph. Some of the edges may be undirected (though it shouldn't be many in most cases)
-     * and some of the adjacencies may be two-cycles.
-     */
-    public Graph search() {
-        long start = System.currentTimeMillis();
-
-        setCutoff(alpha);
-
-        DataSet dataSet = DataUtils.standardizeData(this.dataSet);
-
-        double[][] colData = dataSet.getDoubleData().transpose().toArray();
-        Graph G0;
-
-        if (getInitialGraph() != null) {
-            Graph g1 = new EdgeListGraph(getInitialGraph().getNodes());
-
-            for (Edge edge : getInitialGraph().getEdges()) {
-                Node x = edge.getNode1();
-                Node y = edge.getNode2();
-
-                if (!g1.isAdjacentTo(x, y)) g1.addUndirectedEdge(x, y);
-            }
-
-            g1 = GraphUtils.replaceNodes(g1, dataSet.getVariables());
-
-            G0 = g1;
-        } else {
-//            SemBicScore score = new SemBicScore(new CovarianceMatrixOnTheFly(dataSet, false));
-//            score.setPenaltyDiscount(penaltyDiscount);
-            IndependenceTest test = new IndTestScore(score, dataSet);
-
-//            for (int j = 0; j < colData.length; j++) {
-//                double[] x = colData[j];
-//
-//                double s = signum(StatUtils.skewness(x));
-//
-//                for (int i = 0; i < x.length; i++) {
-//                    x[i] = s * x[i];
-//                }
-//
-//                colData[j] = x;
-//            }
-
-            System.out.println("FAS");
-
-            FasStable fas = new FasStable(test);
-            fas.setDepth(getDepth());
-            fas.setVerbose(false);
-            fas.setKnowledge(knowledge);
-            G0 = fas.search();
-        }
-
-        if (G0 != null) {
-            DataSet discreteData = DataUtils.copyDiscreteVariables(dataSet);
-
-            for (Node x : discreteData.getVariables()) {
-                G0.removeNode(x);
-            }
-        }
-
-        this.dataSet = DataUtils.copycContinuousVariables(this.dataSet);
-        List<Node> variables = this.dataSet.getVariables();
-
-        SearchGraphUtils.pcOrientbk(knowledge, G0, G0.getNodes());
-
-        System.out.println("Orientation");
-
-        Graph graph = new EdgeListGraph(variables);
-
-        for (int i = 0; i < variables.size(); i++) {
-            for (int j = i + 1; j < variables.size(); j++) {
-                Node X = variables.get(i);
-                Node Y = variables.get(j);
-
-                // Centered
-                final double[] x = colData[i];
-                final double[] y = colData[j];
-
-                double c1 = StatUtils.cov(x, y, x, 0, +1)[1];
-                double c2 = StatUtils.cov(x, y, y, 0, +1)[1];
-
-                if ((isUseFasAdjacencies() && G0.isAdjacentTo(X, Y)) || (isUseCorrDiffAdjacencies() && Math.abs(c1 - c2) > getExtraEdgeThreshold())) {
-                    if (knowledgeOrients(X, Y)) {
-                        graph.addDirectedEdge(X, Y);
-                    } else if (knowledgeOrients(Y, X)) {
-                        graph.addDirectedEdge(Y, X);
-                    } else if (bidirected(x, y, G0, X, Y)) {
-                        Edge edge1 = Edges.directedEdge(X, Y);
-                        Edge edge2 = Edges.directedEdge(Y, X);
-
-//                        edge1.setLineColor(Color.GREEN);
-//                        edge2.setLineColor(Color.GREEN);
-
-                        graph.addEdge(edge1);
-                        graph.addEdge(edge2);
-                    } else if (leftright(x, y)) {
-                        graph.addDirectedEdge(X, Y);
-                    } else {
-                        graph.addDirectedEdge(Y, X);
-                    }
-                }
-            }
-        }
-
-        System.out.println();
-        System.out.println("Done");
-
-        long stop = System.currentTimeMillis();
-        this.elapsed = stop - start;
-
-        return graph;
-    }
-
-    private boolean bidirected(double[] x, double[] y, Graph G0, Node X, Node Y) {
-
-        Set<Node> adjSet = new HashSet<Node>(G0.getAdjacentNodes(X));
-        adjSet.addAll(G0.getAdjacentNodes(Y));
-        List<Node> adj = new ArrayList<>(adjSet);
-        adj.remove(X);
-        adj.remove(Y);
-
-        DepthChoiceGenerator gen = new DepthChoiceGenerator(adj.size(), Math.min(depth, adj.size()));
-        int[] choice;
-
-        while ((choice = gen.next()) != null) {
-            List<Node> _adj = GraphUtils.asList(choice, adj);
-            double[][] _Z = new double[_adj.size()][];
-
-            for (int f = 0; f < _adj.size(); f++) {
-                Node _z = _adj.get(f);
-                int column = dataSet.getColumn(_z);
-                _Z[f] = data[column];
-            }
-
-            double pc = partialCorrelation(x, y, _Z, x, Double.NEGATIVE_INFINITY, +1);
-            double pc1 = partialCorrelation(x, y, _Z, x, 0, +1);
-            double pc2 = partialCorrelation(x, y, _Z, y, 0, +1);
-
-            int nc = StatUtils.getRows(x, x, Double.NEGATIVE_INFINITY, +1).size();
-            int nc1 = StatUtils.getRows(x, x, 0, +1).size();
-            int nc2 = StatUtils.getRows(y, y, 0, +1).size();
-
-            double z = 0.5 * (log(1.0 + pc) - log(1.0 - pc));
-            double z1 = 0.5 * (log(1.0 + pc1) - log(1.0 - pc1));
-            double z2 = 0.5 * (log(1.0 + pc2) - log(1.0 - pc2));
-
-            double zv1 = (z - z1) / sqrt((1.0 / ((double) nc - 3) + 1.0 / ((double) nc1 - 3)));
-            double zv2 = (z - z2) / sqrt((1.0 / ((double) nc - 3) + 1.0 / ((double) nc2 - 3)));
-
-//            double p1 = 2 * (1.0 - new NormalDistribution(0, 1).cumulativeProbability(abs(zv1)));
-//            double p2 = 2 * (1.0 - new NormalDistribution(0, 1).cumulativeProbability(abs(zv2)));
-
-//            boolean rejected1 = p1 < twoCycleAlpha;
-//            boolean rejected2 = p2 < twoCycleAlpha;
-
-            boolean rejected1 = abs(zv1) > cutoff;
-            boolean rejected2 = abs(zv2) > cutoff;
-
-            boolean possibleTwoCycle = false;
-
-            if (zv1 < 0 && zv2 > 0 && rejected1) {
-                possibleTwoCycle = true;
-            } else if (zv1 > 0 && zv2 < 0 && rejected2) {
-                possibleTwoCycle = true;
-            } else if (rejected1 && rejected2) {
-                possibleTwoCycle = true;
-            }
-
-            if (!possibleTwoCycle) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    private boolean leftright(double[] x, double[] y) {
-        double left = cu(x, y, x) / (sqrt(cu(x, x, x) * cu(y, y, x)));
-        double right = cu(x, y, y) / (sqrt(cu(x, x, y) * cu(y, y, y)));
-        double lr = left - right;
-
-        if (isReverseOrientationsBySignOfCorrelation()) {
-            lr *= signum(StatUtils.correlation(x, y));
-        }
-
-        System.out.println(skewness(x) + " " + skewness(y));
-
-        if (isReverseOrientationsBySkewnessOfVariables()) {
-            double sd = sqrt(6.0 / dataSet.getNumRows());
-
-            double sx = StatUtils.skewness(x);
-            double sy = StatUtils.skewness(y);
-
-            if (abs(sx) > 5 * sd && abs(sy) > 5 * sd) {
-                lr *= signum(sx) * signum(sy);
-            }
-        }
-
-        return lr > 0;
-    }
-
-    public static double cu(double[] x, double[] y, double[] condition) {
-        double exy = 0.0;
-
-        int n = 0;
-
-        for (int k = 0; k < x.length; k++) {
-            if (condition[k] > 0) {
-                exy += x[k] * y[k];
-                n++;
-            }
-        }
-
-        return exy / n;
-    }
-
-    private double partialCorrelation(double[] x, double[] y, double[][] z, double[] condition, double threshold, double direction) throws SingularMatrixException {
-        double[][] cv = StatUtils.covMatrix(x, y, z, condition, threshold, direction);
-        TetradMatrix m = new TetradMatrix(cv).transpose();
-        return StatUtils.partialCorrelation(m);
-    }
-
-    /**
-     * Sets the significance level at which independence judgments should be made.  Affects the cutoff for partial
-     * correlations to be considered statistically equal to zero.
-     */
-    private void setCutoff(double alpha) {
-        if (alpha < 0.0 || alpha > 1.0) {
-            throw new IllegalArgumentException("Significance out of range: " + alpha);
-        }
-
-        this.cutoff = StatUtils.getZForAlpha(alpha);
-    }
-
-    /**
-     * @return The depth of search for the Fast Adjacency Search (FAS).
-     */
-
-    public int getDepth() {
-        return depth;
-    }
-
-    /**
-     * @param depth The depth of search for the Fast Adjacency Search (S). The default is -1.
-     *              unlimited. Making this too high may results in statistical errors.
-     */
-    public void setDepth(int depth) {
-        this.depth = depth;
-    }
-
-    /**
-     * @return The elapsed time in milliseconds.
-     */
-    public long getElapsedTime() {
-        return elapsed;
-    }
-
-    /**
-     * @return Returns the penalty discount used for the adjacency search. The default is 1,
-     * though a higher value is recommended, say, 2, 3, or 4.
-     */
-    public double getPenaltyDiscount() {
-        return penaltyDiscount;
-    }
-
-    /**
-     * @param penaltyDiscount Sets the penalty discount used for the adjacency search.
-     *                        The default is 1, though a higher value is recommended, say,
-     *                        2, 3, or 4.
-     */
-    public void setPenaltyDiscount(double penaltyDiscount) {
-        this.penaltyDiscount = penaltyDiscount;
-    }
-
-    /**
-     * @param alpha Alpha for orienting 2-cycles. Needs to be on the low side usually. Default 1e-6.
-     */
-    public void setAlpha(double alpha) {
-        this.alpha = alpha;
-    }
-
-    /**
-     * @return the current knowledge.
-     */
-    public IKnowledge getKnowledge() {
-        return knowledge;
-    }
-
-    /**
-     * @param knowledge Knowledge of forbidden and required edges.
-     */
-    public void setKnowledge(IKnowledge knowledge) {
-        this.knowledge = knowledge;
-    }
-
-    //======================================== PRIVATE METHODS ====================================//
-
-    private boolean knowledgeOrients(Node left, Node right) {
-        return knowledge.isForbidden(right.getName(), left.getName()) || knowledge.isRequired(left.getName(), right.getName());
-    }
-
-    public Graph getInitialGraph() {
-        return initialGraph;
-    }
-
-    public void setInitialGraph(Graph initialGraph) {
-        this.initialGraph = initialGraph;
-    }
-
-    public void setReverseOrientationsBySignOfCorrelation(boolean reverseOrientationsBySignOfCorrelation) {
-        this.reverseOrientationsBySignOfCorrelation = reverseOrientationsBySignOfCorrelation;
-    }
-
-    public double getExtraEdgeThreshold() {
-        return extraEdgeThreshold;
-    }
-
-    public void setExtraEdgeThreshold(double extraEdgeThreshold) {
-        this.extraEdgeThreshold = extraEdgeThreshold;
-    }
-
-    public boolean isUseFasAdjacencies() {
-        return useFasAdjacencies;
-    }
-
-    public void setUseFasAdjacencies(boolean useFasAdjacencies) {
-        this.useFasAdjacencies = useFasAdjacencies;
-    }
-
-    public boolean isUseCorrDiffAdjacencies() {
-        return useCorrDiffAdjacencies;
-    }
-
-    public void setUseCorrDiffAdjacencies(boolean useCorrDiffAdjacencies) {
-        this.useCorrDiffAdjacencies = useCorrDiffAdjacencies;
-    }
-
-    public boolean isReverseOrientationsBySkewnessOfVariables() {
-        return reverseOrientationsBySkewnessOfVariables;
-    }
-
-    public void setReverseOrientationsBySkewnessOfVariables(boolean reverseOrientationsBySkewnessOfVariables) {
-        this.reverseOrientationsBySkewnessOfVariables = reverseOrientationsBySkewnessOfVariables;
-    }
-
-    public boolean isReverseOrientationsBySignOfCorrelation() {
-        return reverseOrientationsBySignOfCorrelation;
-    }
-}
-
-
-
-
-
-
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/GFci.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/GFci.java
index 683e1c1b..139ed821 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/GFci.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/GFci.java
@@ -112,7 +112,6 @@ public final class GFci implements GraphSearch {
         Graph fgesGraph = new EdgeListGraphSingleConnections(graph);
 
         sepsets = new SepsetsGreedy(fgesGraph, independenceTest, null, maxDegree);
-        ((SepsetsGreedy) sepsets).setKnowledge(knowledge);
 
         for (Node b : nodes) {
             if (Thread.currentThread().isInterrupted()) {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestConditionalCorrelation.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestConditionalCorrelation.java
index 3418049a..40ee5bcf 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestConditionalCorrelation.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestConditionalCorrelation.java
@@ -83,7 +83,7 @@ public final class IndTestConditionalCorrelation implements IndependenceTest {
      * given data set (must be continuous). The given significance level is used.
      *
      * @param dataSet A data set containing only continuous columns.
-     * @param alpha   The q level of the test.
+     * @param alpha   The alpha level of the test.
      */
     public IndTestConditionalCorrelation(DataSet dataSet, double alpha) {
         if (!(dataSet.isContinuous())) {
@@ -91,7 +91,7 @@ public final class IndTestConditionalCorrelation implements IndependenceTest {
         }
 
         if (!(alpha >= 0 && alpha <= 1)) {
-                throw new IllegalArgumentException("Q mut be in [0, 1]");
+                throw new IllegalArgumentException("Alpha mut be in [0, 1]");
         }
 
         List<Node> nodes = dataSet.getVariables();
@@ -130,6 +130,8 @@ public final class IndTestConditionalCorrelation implements IndependenceTest {
         for (Node node : z) _z.add(node.getName());
         boolean independent = cci.isIndependent(_x, _y, _z);
 
+//        System.out.println(Runtime.getRuntime().freeMemory());
+
         if (verbose) {
             if (independent) {
                 TetradLogger.getInstance().log("independencies",
@@ -176,7 +178,7 @@ public final class IndTestConditionalCorrelation implements IndependenceTest {
      * @return the probability associated with the most recently computed independence test.
      */
     public double getPValue() {
-        return cci.getAlpha();
+        return cci.getQ();
     }
 
     /**
@@ -273,7 +275,7 @@ public final class IndTestConditionalCorrelation implements IndependenceTest {
      * @return a string representation of this test.
      */
     public String toString() {
-        return "Conditional Correlation, q = " + nf.format(getAlpha());
+        return "Conditional Correlation, alpha = " + nf.format(getAlpha());
     }
 
     public boolean isVerbose() {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestCorrelationT.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestCorrelationT.java
index dc4f4d04..c5126724 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestCorrelationT.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestCorrelationT.java
@@ -25,7 +25,6 @@ import edu.cmu.tetrad.data.*;
 import edu.cmu.tetrad.graph.Node;
 import edu.cmu.tetrad.util.*;
 import org.apache.commons.math3.distribution.TDistribution;
-import org.apache.commons.math3.linear.SingularMatrixException;
 
 import java.io.PrintStream;
 import java.text.NumberFormat;
@@ -301,8 +300,7 @@ public final class IndTestCorrelationT implements IndependenceTest {
 
             try {
                 inverse = Czz.inverse();
-            } catch (SingularMatrixException e) {
-                System.out.println(SearchLogUtils.determinismDetected(z, x));
+            } catch (Exception e) {
                 return true;
             }
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestFisherZ.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestFisherZ.java
index cabba68e..c1a0f04c 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestFisherZ.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestFisherZ.java
@@ -190,7 +190,7 @@ public final class IndTestFisherZ implements IndependenceTest {
         try {
             r = partialCorrelation(x, y, z);
         } catch (SingularMatrixException e) {
-            System.out.println(SearchLogUtils.determinismDetected(z, x));
+//            System.out.println(SearchLogUtils.determinismDetected(z, x));
             this.fisherZ = Double.POSITIVE_INFINITY;
             return false;
         }
@@ -299,20 +299,34 @@ public final class IndTestFisherZ implements IndependenceTest {
             parents[j] = covMatrix.getVariables().indexOf(z.get(j));
         }
 
+//        int i = covMatrix.getVariable().indexOf(x);
+
+//        double variance = covMatrix.getValue(i, i);
+
         if (parents.length > 0) {
 
             // Regress z onto i, yielding regression coefficients b.
             TetradMatrix Czz = covMatrix.getSelection(parents, parents);
+//            TetradMatrix inverse;
 
             try {
+//                inverse =
                 Czz.inverse();
             } catch (SingularMatrixException e) {
-                System.out.println(SearchLogUtils.determinismDetected(z, x));
+//                System.out.println(SearchLogUtils.determinismDetected(z, x));
+
                 return true;
             }
+
+//            TetradVector Cyz = covMatrix.getSelection(parents, new int[]{i}).getColumn(0);
+//            TetradVector b = inverse.times(Cyz);
+//
+//            variance -= Cyz.dotProduct(b);
         }
 
         return false;
+
+//        return variance < 1e-20;
     }
 
     /**
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestFisherZGeneralizedInverse.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestFisherZGeneralizedInverse.java
index b4b06f1d..5d95f3a8 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestFisherZGeneralizedInverse.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestFisherZGeneralizedInverse.java
@@ -362,7 +362,7 @@ public final class IndTestFisherZGeneralizedInverse implements IndependenceTest
 //        final double upperBound = 9.0;
 //        final double delta = 0.001;
 //                double alpha = this.alpha/2.0;    //Two sided test
-//        return CutoffFinder.getBootstrapAlpha(npdf, upperBound, alpha, delta);
+//        return CutoffFinder.getCutoff(npdf, upperBound, alpha, delta);
     }
 
     private int sampleSize() {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestLaggedRegression.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestLaggedRegression.java
index eaee0de2..c42103b5 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestLaggedRegression.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestLaggedRegression.java
@@ -340,7 +340,7 @@ public final class IndTestLaggedRegression implements IndependenceTest {
 //        final double upperBound = 9.0;
 //        final double delta = 0.001;
 //        //        double alpha = this.alpha/2.0;    //Two sided test
-//        return CutoffFinder.getBootstrapAlpha(npdf, upperBound, alpha, delta);
+//        return CutoffFinder.getCutoff(npdf, upperBound, alpha, delta);
 //    }
 
 //    private int sampleSize() {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestRegression.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestRegression.java
index 0767c1b2..7f53d417 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestRegression.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestRegression.java
@@ -309,7 +309,7 @@ public final class IndTestRegression implements IndependenceTest {
 //        final double upperBound = 9.0;
 //        final double delta = 0.001;
 //        //        double alpha = this.alpha/2.0;    //Two sided test
-//        return CutoffFinder.getBootstrapAlpha(npdf, upperBound, alpha, delta);
+//        return CutoffFinder.getCutoff(npdf, upperBound, alpha, delta);
 //    }
 
 //    private int sampleSize() {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestRegressionAD.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestRegressionAD.java
index f9ad4223..2d84f59d 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestRegressionAD.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/IndTestRegressionAD.java
@@ -304,7 +304,7 @@ public final class IndTestRegressionAD implements IndependenceTest {
 //        final double upperBound = 9.0;
 //        final double delta = 0.001;
 //        //        double alpha = this.alpha/2.0;    //Two sided test
-//        return CutoffFinder.getBootstrapAlpha(npdf, upperBound, alpha, delta);
+//        return CutoffFinder.getCutoff(npdf, upperBound, alpha, delta);
 //    }
 
 //    private int sampleSize() {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Lingam.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Lingam.java
index 515c66cc..a59934aa 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Lingam.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Lingam.java
@@ -21,27 +21,29 @@
 
 package edu.cmu.tetrad.search;
 
-import edu.cmu.tetrad.data.*;
+import edu.cmu.tetrad.data.DataSet;
+import edu.cmu.tetrad.graph.EdgeListGraph;
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.util.PermutationGenerator;
-import edu.cmu.tetrad.util.TetradLogger;
-import edu.cmu.tetrad.util.TetradMatrix;
+import edu.cmu.tetrad.util.*;
+import org.apache.commons.math3.linear.QRDecomposition;
+import org.apache.commons.math3.linear.RealMatrix;
 
 import java.util.*;
 
-import static java.lang.StrictMath.abs;
+import static java.lang.Math.abs;
+import static java.lang.Math.min;
 
 /**
  * Implements the LiNGAM algorithm in Shimizu, Hoyer, Hyvarinen, and Kerminen, A linear nongaussian acyclic model for
  * causal discovery, JMLR 7 (2006). Largely follows the Matlab code.
+ * <p>
+ * <p>Note: This code is currently broken; please do not use it until it's fixed. 11/24/2015</p>
  *
- * We use FGES with knowledge of causal order for the pruning step.
- *
- * @author Joseph Ramsey
+ * @author Gustavo Lacerda
  */
 public class Lingam {
-    private double penaltyDiscount = 2;
+    private double pruneFactor = 1.0;
 
     //================================CONSTRUCTORS==========================//
 
@@ -52,119 +54,537 @@ public class Lingam {
     }
 
     public Graph search(DataSet data) {
-        data = DataUtils.center(data);
-
-        CausalOrder result = estimateCausalOrder(data);
-        int[] perm = result.getPerm();
+        TetradMatrix X = data.getDoubleData();
+        List<Node> nodes = data.getVariables();
 
-        final SemBicScore score = new SemBicScore(new CovarianceMatrixOnTheFly(data));
-        score.setPenaltyDiscount(penaltyDiscount);
-        Fges fges = new Fges(score);
+        EstimateResult result = estimate(X);
+        int[] k = result.getK();
+        TetradMatrix bHat = pruneEdgesByResampling(X, k);
 
-        IKnowledge knowledge = new Knowledge2();
-        final List<Node> variables = data.getVariables();
+        Graph graph = new EdgeListGraph(nodes);
 
-        for (int i = 0; i < variables.size(); i++) {
-            knowledge.addToTier(i + 1, variables.get(perm[i]).getName());
+        for (int j = 0; j < bHat.columns(); j++) {
+            for (int i = 0; i < bHat.rows(); i++) {
+                if (bHat.get(i, j) != 0) {
+                    graph.addDirectedEdge(nodes.get(j), nodes.get(i));
+                }
+            }
         }
 
-        fges.setKnowledge(knowledge);
-
-        final Graph graph = fges.search();
         System.out.println("graph Returning this graph: " + graph);
+
         return graph;
     }
 
     //================================PUBLIC METHODS========================//
 
-    private CausalOrder estimateCausalOrder(DataSet dataSet) {
-        TetradMatrix X = dataSet.getDoubleData();
-        FastIca fastIca = new FastIca(X, 30);
+    private EstimateResult estimate(TetradMatrix X) {
+        FastIca fastIca = new FastIca(X, 20);
         fastIca.setVerbose(false);
+        fastIca.setAlgorithmType(FastIca.DEFLATION);
+        fastIca.setFunction(FastIca.LOGCOSH);
+        fastIca.setTolerance(1e-20);
         FastIca.IcaResult result = fastIca.findComponents();
-        TetradMatrix W = result.getW().transpose();
+        TetradMatrix w = result.getW();
+        TetradMatrix k = result.getK();
 
+        TetradMatrix W = k.times(w.transpose());
         System.out.println("W = " + W);
 
-        PermutationGenerator gen1 = new PermutationGenerator(W.rows());
-        int[] perm1 = new int[0];
-        double sum1 = Double.POSITIVE_INFINITY;
-        int[] choice1;
+        TetradLogger.getInstance().log("lingamDetails", "\nW " + W);
+
+
+//        PermutationGenerator gen = new PermutationGenerator(W.columns());
+//        int[] perm;
+//        int[] rowp = new int[5];
+//        double maxSum = -1.0;
+//
+//        while ((perm = gen.next()) != null) {
+//            double sum = 0.0;
+//
+//            for (int i = 0; i < W.rows(); i++) {
+//                for (int j = 0; j < i; j++) {
+//                    sum += abs(W.get(perm[i], perm[j]));
+//                }
+//            }
+//
+//            if (sum > maxSum) {
+//                maxSum = sum;
+//                rowp = Arrays.copyOf(perm, perm.length);
+//            }
+//        }
+
+
+        // The method that calls assign() twice could be a problem for the
+        // negative coefficients
+        TetradMatrix S = W.copy();
+
+        for (int i = 0; i < S.rows(); i++) {
+            for (int j = 0; j < S.columns(); j++) {
+                S.set(i, j, 1.0 / abs(S.get(i, j)));
+            }
+        }
+
+        //this is an n x 2 matrix, i.e. a list of index pairs
+        int[][] assignment = Hungarian.hgAlgorithm(S.toArray(), "min");
+
+        int[] rowp = new int[assignment.length];
+
+        for (int i = 0; i < rowp.length; i++) {
+            rowp[i] = assignment[i][1];
+        }
+
+        TetradLogger.getInstance().log("lingamDetails", "\nrowp = ");
+
+//        for (int row : rowp) {
+//            System.out.println("lingamDetails " + row + "\t");
+//        }
+
+        TetradMatrix Wp = W.getSelection(rowp, rowp);//range(0, W.columns() - 1));
+
+        System.out.println("lingamDetails Wp = " + Wp);
+
+//        TetradVector estdisturbancesstd = new TetradVector(Wp.rows());
+//
+//        for (int i = 0; i < Wp.rows(); i++) {
+//            estdisturbancesstd.set(i, 1.0 / abs(Wp.get(i, i)));
+//        }
+
+        System.out.println("lingamDetails Wp = " + Wp);
+
+        TetradVector diag = Wp.diag();
 
-        while ((choice1 = gen1.next()) != null) {
+        for (int i = 0; i < Wp.rows(); i++) {
+            for (int j = 0; j < Wp.columns(); j++) {
+                Wp.set(i, j, Wp.get(i, j) / diag.get(i));
+            }
+        }
+
+        System.out.println("lingamDetails Wp = " + Wp);
+
+        TetradMatrix Best = TetradMatrix.identity(Wp.rows()).minus(Wp);
+
+        System.out.println("lingamDetails Best " + Best);
+
+        TetradVector Xm = new TetradVector(X.columns());
+
+        for (int j = 0; j < X.columns(); j++) {
             double sum = 0.0;
 
-            for (int i = 0; i < W.rows(); i++) {
-                final double c = W.get(i, choice1[i]);
-                sum += 1.0 / abs(c);
+            for (int i = 0; i < X.rows(); i++) {
+                double v = X.get(i, j);
+                sum += v;
             }
 
-            if (sum < sum1) {
-                sum1 = sum;
-                perm1 = Arrays.copyOf(choice1, choice1.length);
+            double mean = sum / X.rows();
+
+            Xm.set(j, mean);
+        }
+
+//        TetradVector cest = Wp.times(Xm);
+//
+//        System.out.println("lingamDetails cest = " + cest);
+
+//        StlPruneResult result1 = stlPrune(Best);
+//
+//        TetradMatrix bestCausal = result1.getBestcausal();
+//        int[] causalperm = result1.getCausalperm();
+//
+//        System.out.println("lingamDetails Best causal " + bestCausal);
+//        System.out.println("lingamDetails causalperm = " + Arrays.toString(causalperm));
+//
+//        int[] icausal = iperm(causalperm);
+//
+//        for (int i = 0; i < bestCausal.rows(); i++) {
+//            for (int j = i + 1; j < bestCausal.columns(); j++) {
+//                bestCausal.set(i, j, 0);
+//            }
+//        }
+//
+//        System.out.println("lingamDetails bestCausal = " + bestCausal);
+//
+//        TetradMatrix B = bestCausal.getSelection(icausal, icausal).copy();
+//
+//
+//        System.out.println("lingamDetails B = " + B);
+//
+//        System.out.println("causal perm = " + Arrays.toString(causalperm));
+
+        return new EstimateResult(rowp);
+    }
+
+    public double getPruneFactor() {
+        return pruneFactor;
+    }
+
+    public void setPruneFactor(double pruneFactor) {
+        if (pruneFactor <= 0) {
+            throw new IllegalArgumentException("Prune factor must be greater than zero.");
+        }
+
+        this.pruneFactor = pruneFactor;
+    }
+
+    public static class EstimateResult {
+        private int[] k;
+
+        public EstimateResult(int[] k) {
+            this.k = k;
+        }
+
+        public int[] getK() {
+            return k;
+        }
+    }
+
+    private static class StlPruneResult {
+        private TetradMatrix Bestcausal;
+        private int[] causalperm;
+
+        public StlPruneResult(TetradMatrix Bestcausal, int[] causalPerm) {
+            this.Bestcausal = Bestcausal;
+            this.causalperm = causalPerm;
+        }
+
+        public TetradMatrix getBestcausal() {
+            return Bestcausal;
+        }
+
+        public int[] getCausalperm() {
+            return causalperm;
+        }
+    }
+
+    private StlPruneResult stlPrune(TetradMatrix bHat) {
+        int m = bHat.rows();
+
+        LinkedList<Entry> entries = getEntries(bHat);
+
+        // Sort entries by absolute value.
+        java.util.Collections.sort(entries);
+
+        TetradMatrix bHat2 = bHat.copy();
+//
+        int numUpperTriangle = m * (m + 1) / 2;
+        int numTotal = m * m;
+//
+        for (int i = 0; i < numUpperTriangle; i++) {
+            Entry entry = entries.get(i);
+            bHat.set(entry.row, entry.column, 0);
+        }
+
+        // If that doesn't result in a permutation, try setting one more entry
+        // to zero, iteratively, until you get a permutation.
+        for (int i = numUpperTriangle; i < numTotal; i++) {
+            int[] permutation = algorithmB(bHat);
+
+            if (permutation != null) {
+                TetradMatrix Bestcausal = permute(permutation, bHat2);
+
+                return new StlPruneResult(Bestcausal, permutation);
             }
+
+            Entry entry = entries.get(i);
+            bHat.set(entry.row, entry.column, 0);
         }
 
-        TetradMatrix WTilde = W.getSelection(perm1, perm1);
+        throw new IllegalArgumentException("No permutation was found.");
+    }
+
+    private TetradMatrix permute(int[] permutation, TetradMatrix data) {
+        return data.getSelection(permutation, permutation);
+    }
 
-        System.out.println("WTilde before normalization = " + WTilde);
+    private LinkedList<Entry> getEntries(TetradMatrix mat) {
+        LinkedList<Entry> entries = new LinkedList<>();
 
-        for (int j = 0; j < WTilde.columns(); j++) {
-            for (int i = j ; i < WTilde.rows(); i++) {
-                WTilde.set(i, j, WTilde.get(i, j) / WTilde.get(j, j));
+        for (int i = 0; i < mat.rows(); i++) {
+            for (int j = 0; j < mat.columns(); j++) {
+                Entry entry = new Entry(i, j, mat.get(i, j));
+                entries.add(entry);
             }
         }
 
-        System.out.println("WTilde after normalization = " + WTilde);
+        return entries;
+    }
 
-        final int m = dataSet.getNumColumns();
-        TetradMatrix B = TetradMatrix.identity(m).minus(WTilde.transpose());
+    private static class Entry implements Comparable<Entry> {
+        private int row;
+        private int column;
+        private double value;
 
-        System.out.println("B = " + B);
+        public Entry(int row, int col, double val) {
+            this.row = row;
+            this.column = col;
+            this.value = val;
+        }
 
-        PermutationGenerator gen2 = new PermutationGenerator(B.rows());
-        int[] perm2 = new int[0];
-        double sum2 = Double.POSITIVE_INFINITY;
-        int[] choice2;
+        /**
+         * Used for sorting. An entry is smaller than another if its absolute value is smaller.
+         *
+         * @see java.lang.Comparable#compareTo(java.lang.Object)
+         */
+        public int compareTo(Entry entry) {
+            double thisVal = abs(value);
+            double entryVal = abs(entry.value);
+            return (new Double(thisVal).compareTo(entryVal));
+        }
 
-        while ((choice2 = gen2.next()) != null) {
-            double sum = 0.0;
+        public String toString() {
+            return "[" + row + "," + column + "]:" + value + " ";
+        }
+    }
+
+    public int[] algorithmB(TetradMatrix mat) {
+        List<Integer> removedIndices = new ArrayList<>();
+        List<Integer> permutation = new ArrayList<>();
+
+        while (removedIndices.size() < mat.rows()) {
+            int allZerosRow = -1;
+
+            // Find a new row with zeroes in new columns.
+            for (int i = 0; i < mat.rows(); i++) {
+                if (removedIndices.contains(i)) {
+                    continue;
+                }
 
-            for (int i = 0; i < W.rows(); i++) {
-                for (int j = i; j < W.rows(); j++) {
-                    final double c = B.get(choice2[i], choice2[j]);
-                    sum += c * c;
+                if (zeroesInNewColumns(mat.getRow(i), removedIndices)) {
+                    allZerosRow = i;
+                    break;
                 }
             }
 
-            if (sum < sum2) {
-                sum2 = sum;
-                perm2 = Arrays.copyOf(choice2, choice2.length);
+            // No such row.
+            if (allZerosRow == -1) {
+                return null;
             }
+
+            removedIndices.add(allZerosRow);
+            permutation.add(allZerosRow);
         }
 
-        TetradMatrix BTilde = B.getSelection(perm2, perm2);
+        int[] _permutation = new int[permutation.size()];
 
-        System.out.println("BTilde = " + BTilde);
+        for (int i = 0; i < _permutation.length; i++) {
+            _permutation[i] = permutation.get(i);
+        }
 
-        return new CausalOrder(perm2);
+        return _permutation;
     }
 
-    public void setPenaltyDiscount(double penaltyDiscount) {
-        this.penaltyDiscount = penaltyDiscount;
+    private boolean zeroesInNewColumns(TetradVector vec, List<Integer> removedIndices) {
+        for (int i = 0; i < vec.size(); i++) {
+            if (vec.get(i) != 0 && !removedIndices.contains(i)) {
+                return false;
+            }
+        }
+
+        return true;
     }
 
-    public static class CausalOrder {
-        private int[] perm;
+    /**
+     * This is the method used in Patrik's code.
+     */
+    public TetradMatrix pruneEdgesByResampling(TetradMatrix data, int[] k) {
+        if (k.length != data.columns()) {
+            throw new IllegalArgumentException("Execting a permutation.");
+        }
+
+        Set<Integer> set = new LinkedHashSet<>();
+
+        for (int i = 0; i < k.length; i++) {
+            if (k[i] >= k.length) {
+                throw new IllegalArgumentException("Expecting a permutation.");
+            }
+
+            if (set.contains(i)) {
+                throw new IllegalArgumentException("Expecting a permutation.");
+            }
+
+            set.add(i);
+        }
+
+        TetradMatrix X = data.transpose();
+
+        int npieces = 10;
+        int cols = X.columns();
+        int rows = X.rows();
+        int piecesize = (int) Math.floor(cols / npieces);
+
+        List<TetradMatrix> bpieces = new ArrayList<>();
+//        List<Vector> diststdpieces = new ArrayList<Vector>();
+//        List<Vector> cpieces = new ArrayList<Vector>();
+
+        for (int p = 0; p < npieces; p++) {
+
+//          % Select subset of data, and permute the variables to the causal order
+//          Xp = X(k,((p-1)*piecesize+1):(p*piecesize));
+
+            int p0 = (p) * piecesize;
+            int p1 = (p + 1) * piecesize - 1;
+            int[] range = range(p0, p1);
+
+
+            TetradMatrix Xp = X.getSelection(k, range);
+
+//          % Remember to subract out the mean
+//          Xpm = mean(Xp,2);
+//          Xp = Xp - Xpm*ones(1,size(Xp,2));
+//
+//          % Calculate covariance matrix
+//          cov = (Xp*Xp')/size(Xp,2);
+
+            double[] Xpm = new double[rows];
+
+            for (int i = 0; i < rows; i++) {
+                double sum = 0.0;
+
+                for (int j = 0; j < Xp.columns(); j++) {
+                    sum += Xp.get(i, j);
+                }
+
+                Xpm[i] = sum / Xp.columns();
+            }
+
+            for (int i = 0; i < rows; i++) {
+                for (int j = 0; j < Xp.columns(); j++) {
+                    Xp.set(i, j, Xp.get(i, j) - Xpm[i]);
+                }
+            }
+
+
+            TetradMatrix cov = Xp.times(Xp.transpose());
+
+//            for (int i = 0; i < cov.rows(); i++) {
+//                for (int j = 0; j < cov.columns(); j++) {
+//                    cov.set(i, j, cov.get(i, j) / Xp.columns());
+//                }
+//            }
+
+//          % Do QL decomposition on the inverse square root of cov
+//          [Q,L] = tridecomp(cov^(-0.5),'ql');
+
+            boolean posDef = MatrixUtils.isPositiveDefinite(cov);
+//            TetradLogger.getInstance().log("lingamDetails","Positive definite = " + posDef);
+
+            if (!posDef) {
+                System.out.println("Covariance matrix is not positive definite.");
+            }
+
+            TetradMatrix invSqrt = cov.sqrt().inverse();
+
+            QRDecomposition qr = new QRDecomposition(invSqrt.getRealMatrix());
+            RealMatrix r = qr.getR();
 
-        CausalOrder(int[] perm) {
-            this.perm = perm;
+//          % The estimated disturbance-stds are one over the abs of the diag of L
+//          newestdisturbancestd = 1./diag(abs(L));
+
+            TetradVector newestdisturbancestd = new TetradVector(rows);
+
+            for (int t = 0; t < rows; t++) {
+                newestdisturbancestd.set(t, 1.0 / abs(r.getEntry(t, t)));
+            }
+
+//          % Normalize rows of L to unit diagonal
+//          L = L./(diag(L)*ones(1,dims));
+//
+            for (int s = 0; s < rows; s++) {
+                for (int t = 0; t < min(s, cols); t++) {
+                    r.setEntry(s, t, r.getEntry(s, t) / r.getEntry(s, s));
+                }
+            }
+
+//          % Calculate corresponding B
+//          bnewest = eye(dims)-L;
+
+            TetradMatrix bnewest = TetradMatrix.identity(rows);
+            bnewest = bnewest.minus(new TetradMatrix(r));
+
+//          % Also calculate constants
+//          cnewest = L*Xpm;
+
+//            Vector cnewest = new DenseVector(rows);
+//            cnewest = L.mult(new DenseVector(Xpm), cnewest);
+
+//          % Permute back to original variable order
+//          ik = iperm(k);
+//          bnewest = bnewest(ik, ik);
+//          newestdisturbancestd = newestdisturbancestd(ik);
+//          cnewest = cnewest(ik);
+
+            int[] ik = iperm(k);
+
+//            System.out.println("ik = " + Arrays.toString(ik));
+
+            bnewest = bnewest.getSelection(ik, ik);
+//            newestdisturbancestd = Matrices.getSubVector(newestdisturbancestd, ik);
+//            cnewest = Matrices.getSubVector(cnewest, ik);
+
+//          % Save results
+//          Bpieces(:,:,p) = bnewest;
+//          diststdpieces(:,p) = newestdisturbancestd;
+//          cpieces(:,p) = cnewest;
+
+            bpieces.add(bnewest);
+//            diststdpieces.add(newestdisturbancestd);
+//            cpieces.add(cnewest);
+
+//
+//        end
+
+        }
+
+        TetradMatrix means = new TetradMatrix(rows, rows);
+        TetradMatrix stds = new TetradMatrix(rows, rows);
+
+        TetradMatrix BFinal = new TetradMatrix(rows, rows);
+
+        for (int i = 0; i < rows; i++) {
+            for (int j = 0; j < rows; j++) {
+                double[] b = new double[npieces];
+
+                for (int y = 0; y < npieces; y++) {
+                    b[y] = bpieces.get(y).get(i, j);
+                }
+
+                double themean = StatUtils.mean(b);
+                double thestd = StatUtils.sd(b);
+
+                means.set(i, j, themean);
+                stds.set(i, j, thestd);
+
+                if (abs(themean) < getPruneFactor() * thestd) {
+                    BFinal.set(i, j, 0);
+                } else {
+                    BFinal.set(i, j, themean);
+                }
+            }
         }
 
-        int[] getPerm() {
-            return perm;
+        return BFinal;
+    }
+
+    public int[] iperm(int[] k) {
+        int[] ik = new int[k.length];
+
+        for (int i = 0; i < k.length; i++) {
+            for (int j = 0; j < k.length; j++) {
+                if (k[i] == j) {
+                    ik[j] = i;
+                }
+            }
         }
+
+        return ik;
+    }
+
+    private int[] range(int i1, int i2) {
+        if (i2 < i1) throw new IllegalArgumentException("i2 must be >=  i2 " + i1 + ", " + i2);
+        int series[] = new int[i2 - i1 + 1];
+        for (int j = i1; j <= i2; j++) series[j - i1] = j;
+        return series;
     }
 
 }
 
+
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Lofs2.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Lofs2.java
index a652ed31..703a347d 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Lofs2.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Lofs2.java
@@ -131,7 +131,7 @@ public class Lofs2 {
     // orientStrongerDirection list of past and present rules.
     public enum Rule {
         IGCI, R1TimeLag, R1, R2, R3, R4, Tanh, EB, Skew, SkewE, RSkew, RSkewE,
-        Patel, Patel25, Patel50, Patel75, Patel90, FastICA, RC, Nlo, FASKLR
+        Patel, Patel25, Patel50, Patel75, Patel90, FastICA, RC, Nlo
     }
 
     public Graph orient() {
@@ -154,7 +154,7 @@ public class Lofs2 {
         } else if (this.rule == Rule.R4) {
             graph = GraphUtils.undirectedGraph(skeleton);
             return ruleR4(graph);
-        }  else if (this.rule == Rule.EB) {
+        } else if (this.rule == Rule.EB) {
             graph = GraphUtils.undirectedGraph(skeleton);
             return entropyBased(graph);
         } else if (this.rule == Rule.Tanh) {
@@ -206,9 +206,6 @@ public class Lofs2 {
             return nlo.fullOrient4(_graph);
 //            return nlo.fullOrient5(_graph);
 //            return nlo.pairwiseOrient3(_graph);
-        } else if (this.rule == Rule.FASKLR) {
-            graph = GraphUtils.undirectedGraph(skeleton);
-            return ruleFaskLR(graph);
         }
 
         return graph;
@@ -759,61 +756,6 @@ public class Lofs2 {
 
     }
 
-    private Graph ruleFaskLR(Graph graph) {
-        this.dataSets = DataUtils.center(dataSets);
-        DataSet dataSet = DataUtils.concatenate(dataSets);
-
-        double[][] colData = dataSet.getDoubleData().transpose().toArray();
-
-//        for (int j = 0; j < colData.length; j++) {
-//            double[] x = colData[j];
-//
-//            double s = signum(StatUtils.skewness(x));
-//
-//            for (int i = 0; i < x.length; i++) {
-//                x[i] = s * x[i];
-//            }
-//
-//            colData[j] = x;
-//        }
-
-        Graph out = new EdgeListGraph(graph.getNodes());
-
-        for (Edge edge : graph.getEdges()) {
-            int c1 = dataSet.getColumn(dataSet.getVariable(edge.getNode1().getName()));
-            int c2 = dataSet.getColumn(dataSet.getVariable(edge.getNode2().getName()));
-            if (leftright(colData[c1], colData[c2])) {
-                out.addDirectedEdge(edge.getNode1(), edge.getNode2());
-            } else {
-                out.addDirectedEdge(edge.getNode2(), edge.getNode1());
-            }
-        }
-
-        return out;
-    }
-
-    private boolean leftright(double[] x, double[] y) {
-        double left = cu(x, y, x) / (sqrt(cu(x, x, x) * cu(y, y, x)));
-        double right = cu(x, y, y) / (sqrt(cu(x, x, y) * cu(y, y, y)));
-
-        return /*StatUtils.correlation(x, y)*/ (left - right) > 0;
-    }
-
-    public static double cu(double[] x, double[] y, double[] condition) {
-        double exy = 0.0;
-
-        int n = 0;
-
-        for (int k = 0; k < x.length; k++) {
-            if (condition[k] > 0) {
-                exy += x[k] * y[k];
-                n++;
-            }
-        }
-
-        return exy / n;
-    }
-
     private void resolveOneEdgeMaxR3(Graph graph, Node x, Node y) {
         String xname = x.getName();
         String yname = y.getName();
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Nlo.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Nlo.java
index f3f1b612..cc9dc94d 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Nlo.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/Nlo.java
@@ -94,7 +94,7 @@ public class Nlo {
             double[] cx = column(x);
 
             boolean indep1 = cci.independent(r1, cx);
-            double py = cci.getAlpha();
+            double py = cci.getQ();
 
             List<Node> _y = Collections.singletonList(y);
 
@@ -150,13 +150,13 @@ public class Nlo {
             double[] cx = column(x);
 
             cci.independent(r1, cx);
-            double px = cci.getAlpha();
+            double px = cci.getQ();
 
             double[] r2 = cci.residuals(x.toString(), names(Collections.singletonList(y)));
             double[] cy = column(y);
             cci.independent(r2, cy);
 
-            double py = cci.getAlpha();
+            double py = cci.getQ();
 
             if (py > px) {
                 graph.setEndpoint(y, x, Endpoint.ARROW);
@@ -206,7 +206,7 @@ public class Nlo {
                         break;
                     }
 
-                    double _p = cci.getAlpha();
+                    double _p = cci.getQ();
                     sumP += _p;
                 }
 
@@ -399,7 +399,7 @@ public class Nlo {
 
                 boolean indep = testIndependence(W, r);
 
-                double q = cci.getAlpha();
+                double q = cci.getQ();
 
                 System.out.println("\tW = " + W + " indep = " + (indep) + " q = " + q);
 
@@ -422,7 +422,7 @@ public class Nlo {
 
                 boolean indep = testIndependence(W, r);
 
-                double q = cci.getAlpha();
+                double q = cci.getQ();
 
                 System.out.println("\tW = " + W + " indep = " + (indep) + " q = " + q);
 
@@ -627,7 +627,7 @@ public class Nlo {
         for (Node x : X) {
             double[] _x = column(x);
             boolean indep = cci.independent(_x, y);
-            double q = cci.getAlpha();
+            double q = cci.getQ();
 
 //            boolean indep = q > alpha;
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/PcAll.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/PcAll.java
index 030833c7..1b8935d2 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/PcAll.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/PcAll.java
@@ -365,6 +365,7 @@ public final class PcAll implements GraphSearch {
             //            orientUnshieldedTriplesConcurrent(knowledge, getIndependenceTest(), getMaxIndegree());
         }
 
+        SearchGraphUtils.basicPattern(graph, false);
         graph = GraphUtils.replaceNodes(graph, nodes);
 
         MeekRules meekRules = new MeekRules();
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SearchGraphUtils.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SearchGraphUtils.java
index e839946f..1c079566 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SearchGraphUtils.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SearchGraphUtils.java
@@ -2854,7 +2854,7 @@ public final class SearchGraphUtils {
     /**
      * Just counts arrowpoint errors--for cyclic edges counts an arrowpoint at each node.
      */
-    public static GraphUtils.GraphComparison getGraphComparison3(Graph graph, Graph trueGraph) {
+    public static GraphUtils.GraphComparison getGraphComparison3(Graph graph, Graph trueGraph, PrintStream out) {
         graph = GraphUtils.replaceNodes(graph, trueGraph.getNodes());
         GraphUtils.TwoCycleErrors twoCycleErrors = GraphUtils.getTwoCycleErrors(trueGraph, graph);
 
@@ -3077,7 +3077,6 @@ public final class SearchGraphUtils {
     public static String graphComparisonString(String name1, Graph graph1, String name2, Graph graph2, boolean printStars) {
         StringBuilder builder = new StringBuilder();
         graph2 = GraphUtils.replaceNodes(graph2, graph1.getNodes());
-        graph1 = new EdgeListGraph(graph1);
 
         String trueGraphAndTarget = "Target graph from " + name1 + "\nTrue graph from " + name2;
         builder.append(trueGraphAndTarget + "\n");
@@ -3097,11 +3096,25 @@ public final class SearchGraphUtils {
                 Node node1 = graph1.getNode(edge.getNode1().getName());
                 Node node2 = graph1.getNode(edge.getNode2().getName());
 
-                List<Edge> graph1Edges = graph1.getEdges(node1, node2);
 
-                for (Edge _edge : graph1Edges) {
-                    builder.append("\n").append(i + 1).append(". ").append(_edge);
+                builder.append("\n").append(i + 1).append(". ").append(edge);
+
+                if (printStars) {
+                    boolean directedInGraph2 = false;
+
+                    if (Edges.isDirectedEdge(edge) && GraphUtils.existsSemidirectedPathFromTo(node1, node2, graph2)) {
+                        directedInGraph2 = true;
+                    } else if ((Edges.isUndirectedEdge(edge) || Edges.isBidirectedEdge(edge)) &&
+                            (GraphUtils.existsSemidirectedPathFromTo(node1, node2, graph2) ||
+                                    GraphUtils.existsSemidirectedPathFromTo(node2, node1, graph2))) {
+                        directedInGraph2 = true;
+                    }
+
+                    if (directedInGraph2) {
+                        builder.append(" *");
+                    }
                 }
+
             }
         }
 
@@ -3117,10 +3130,23 @@ public final class SearchGraphUtils {
                 Node node1 = graph2.getNode(edge.getNode1().getName());
                 Node node2 = graph2.getNode(edge.getNode2().getName());
 
-                List<Edge> graph2Edges = graph2.getEdges(node1, node2);
 
-                for (Edge _edge : graph2Edges) {
-                    builder.append("\n").append(i + 1).append(". ").append(_edge);
+                builder.append("\n").append(i + 1).append(". ").append(edge);
+
+                if (printStars) {
+                    boolean directedInGraph1 = false;
+
+                    if (Edges.isDirectedEdge(edge) && GraphUtils.existsSemidirectedPathFromTo(node1, node2, graph1)) {
+                        directedInGraph1 = true;
+                    } else if ((Edges.isUndirectedEdge(edge) || Edges.isBidirectedEdge(edge)) &&
+                            (GraphUtils.existsSemidirectedPathFromTo(node1, node2, graph1) ||
+                                    GraphUtils.existsSemidirectedPathFromTo(node2, node1, graph1))) {
+                        directedInGraph1 = true;
+                    }
+
+                    if (directedInGraph1) {
+                        builder.append(" *");
+                    }
                 }
             }
         }
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SemBicScore.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SemBicScore.java
index f0ae0282..5e72cf35 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SemBicScore.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SemBicScore.java
@@ -32,7 +32,9 @@ import org.apache.commons.math3.linear.SingularMatrixException;
 
 import java.io.PrintStream;
 import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
 
+import static java.lang.Math.PI;
 import static java.lang.Math.log;
 
 /**
@@ -67,7 +69,7 @@ public class SemBicScore implements Score {
     // Variables that caused computational problems and so are to be avoided.
     private Set<Integer> forbidden = new HashSet<>();
 
-    private Map<String, Integer> indexMap;
+    private Map<Node, Integer> indexMap;
 
 
     /**
@@ -81,7 +83,7 @@ public class SemBicScore implements Score {
         this.setCovariances(covariances);
         this.variables = covariances.getVariables();
         this.sampleSize = covariances.getSampleSize();
-        this.indexMap = indexMap(this.variables);
+        this.indexMap = indexMap(variables);
     }
 
     /**
@@ -92,7 +94,7 @@ public class SemBicScore implements Score {
 
         try {
             double s2 = getCovariances().getValue(i, i);
-//            int p = parents.length;
+            int p = parents.length;
 
             TetradMatrix covxx = getSelection(getCovariances(), parents, parents);
             TetradVector covxy = getSelection(getCovariances(), parents, new int[]{i}).getColumn(0);
@@ -170,19 +172,29 @@ public class SemBicScore implements Score {
     }
 
     private double partialCorrelation(Node x, Node y, List<Node> z) throws SingularMatrixException {
+//        if (z.isEmpty()) {
+//            double a = covariances.getValue(indexMap.get(x), indexMap.get(y));
+//            double b = covariances.getValue(indexMap.get(x), indexMap.get(x));
+//            double c = covariances.getValue(indexMap.get(y), indexMap.get(y));
+//
+//            if (b * c == 0) throw new SingularMatrixException();
+//
+//            return -a / Math.sqrt(b * c);
+//        } else {
         int[] indices = new int[z.size() + 2];
-        indices[0] = indexMap.get(x.getName());
-        indices[1] = indexMap.get(y.getName());
-        for (int i = 0; i < z.size(); i++) indices[i + 2] = indexMap.get(z.get(i).getName());
+        indices[0] = indexMap.get(x);
+        indices[1] = indexMap.get(y);
+        for (int i = 0; i < z.size(); i++) indices[i + 2] = indexMap.get(z.get(i));
         TetradMatrix submatrix = covariances.getSubmatrix(indices).getMatrix();
         return StatUtils.partialCorrelation(submatrix);
+//        }
     }
 
-    private Map<String, Integer> indexMap(List<Node> variables) {
-        Map<String, Integer> indexMap = new HashMap<>();
+    private Map<Node, Integer> indexMap(List<Node> variables) {
+        Map<Node, Integer> indexMap = new ConcurrentHashMap<>();
 
         for (int i = 0; i < variables.size(); i++) {
-            indexMap.put(variables.get(i).getName(), i);
+            indexMap.put(variables.get(i), i);
         }
 
         return indexMap;
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SemBicScoreLinear.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SemBicScoreLinear.java
deleted file mode 100644
index d8825906..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SemBicScoreLinear.java
+++ /dev/null
@@ -1,456 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.search;
-
-import edu.cmu.tetrad.data.CovarianceMatrixOnTheFly;
-import edu.cmu.tetrad.data.DataSet;
-import edu.cmu.tetrad.data.DataUtils;
-import edu.cmu.tetrad.data.ICovarianceMatrix;
-import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.util.DepthChoiceGenerator;
-import edu.cmu.tetrad.util.StatUtils;
-import edu.cmu.tetrad.util.TetradMatrix;
-import edu.cmu.tetrad.util.TetradVector;
-import org.apache.commons.math3.linear.SingularMatrixException;
-
-import java.io.PrintStream;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-
-import static java.lang.Math.log;
-
-/**
- * Implements the continuous BIC score for FGES.
- *
- * @author Joseph Ramsey
- */
-public class SemBicScoreLinear implements Score {
-
-    // The covariance matrix.
-    private ICovarianceMatrix covariances;
-
-    private DataSet dataSet;
-
-    private double[][] data;
-
-    // The variables of the covariance matrix.
-    private List<Node> variables;
-
-    // The sample size of the covariance matrix.
-    private int sampleSize;
-
-    // The penalty penaltyDiscount.
-    private double penaltyDiscount = 1.0;
-
-    // True if linear dependencies should return NaN for the score, and hence be
-    // ignored by FGES
-    private boolean ignoreLinearDependent = false;
-
-    // The printstream output should be sent to.
-    private PrintStream out = System.out;
-
-    // True if verbose output should be sent to out.
-    private boolean verbose = false;
-
-    // Variables that caused computational problems and so are to be avoided.
-    private Set<Integer> forbidden = new HashSet<>();
-
-    private Map<Node, Integer> indexMap;
-
-    private int numInBootstrap = 200;
-    private int numBootstraps = 100;
-    private double bootstrapAlpha = 0.999;
-
-    /**
-     * Constructs the score using a covariance matrix.
-     */
-    public SemBicScoreLinear(DataSet dataSet) {
-        if (dataSet == null) {
-            throw new NullPointerException();
-        }
-
-        this .dataSet = dataSet;
-        this.data = dataSet.getDoubleData().transpose().toArray();
-        this.setCovariances(new CovarianceMatrixOnTheFly(dataSet));
-        this.variables = covariances.getVariables();
-        this.sampleSize = covariances.getSampleSize();
-        this.indexMap = indexMap(variables);
-    }
-
-    /**
-     * Calculates the sample likelihood and BIC score for i given its parents in a simple SEM model
-     */
-    public double localScore(int i, int... parents) {
-        for (int p : parents) if (forbidden.contains(p)) return Double.NaN;
-
-        try {
-            double s2 = getCovariances().getValue(i, i);
-            int k = parents.length + 1;
-
-            TetradMatrix covxx = getSelection(getCovariances(), parents, parents);
-            TetradVector covxy = getSelection(getCovariances(), parents, new int[]{i}).getColumn(0);
-            s2 -= covxx.inverse().times(covxy).dotProduct(covxy);
-
-            if (s2 <= 0) {
-                if (isVerbose()) {
-                    out.println("Nonpositive residual varianceY: resVar / varianceY = " + (s2 / getCovariances().getValue(i, i)));
-                }
-
-                return Double.NaN;
-            }
-
-            double c = 0.0;
-
-            if (parents.length > 0) {
-                final double[] z = data[i];
-                final double[] x = data[parents[0]];
-
-                double[][] other = new double[parents.length - 1][];
-                for (int q = 1; q < other.length; q++) {
-                    other[i] = data[parents[q]];
-                }
-
-                boolean linear = DataUtils.linear(x, z, getNumInBootstrap(), getNumBootstraps(), 4);
-                System.out.println("linear  = " + linear);
-                if (!linear) return Double.NaN;
-
-//                c = 1.0 - DataUtils.linearPValue(x, z, other, getNumInBootstrap(), getNumBootstraps(), getBootstrapAlpha());
-
-            }
-
-            int n = getSampleSize();
-            return -(n) * log(s2) + getPenaltyDiscount() * k * log(n);
-//                    + getStructurePrior(parents.length);
-//                    - getStructurePrior(parents.length);
-        } catch (Exception e) {
-            boolean removedOne = true;
-
-            while (removedOne) {
-                List<Integer> _parents = new ArrayList<>();
-                for (int parent : parents) _parents.add(parent);
-                _parents.removeAll(forbidden);
-                parents = new int[_parents.size()];
-                for (int y = 0; y < _parents.size(); y++) parents[y] = _parents.get(y);
-                removedOne = printMinimalLinearlyDependentSet(parents, getCovariances());
-            }
-
-            return Double.NaN;
-        }
-    }
-
-    double sp = 6.0;
-
-    private double getStructurePrior(int parents) {
-        if (sp <= 0) {
-            return 0;
-        } else {
-            int i = parents + 1;
-            int c = variables.size();
-            double p = sp / (double) c;
-            return i * Math.log(p) + (c - i) * Math.log(1.0 - p);
-        }
-    }
-
-    @Override
-    public double localScoreDiff(int x, int y, int[] z) {
-
-        Node _x = variables.get(x);
-        Node _y = variables.get(y);
-        List<Node> _z = getVariableList(z);
-
-        double r;
-
-        try {
-            r = partialCorrelation(_x, _y, _z);
-        } catch (SingularMatrixException e) {
-//            System.out.println(SearchLogUtils.determinismDetected(_z, _x));
-            return Double.NaN;
-        }
-
-        int p = 2 + z.length;
-
-        int N = covariances.getSampleSize();
-        return -N * Math.log(1.0 - r * r) - p * getPenaltyDiscount() * Math.log(N);
-//        return localScore(y, append(z, x)) - localScore(y, z);
-    }
-
-    private List<Node> getVariableList(int[] indices) {
-        List<Node> variables = new ArrayList<>();
-        for (int i : indices) {
-            variables.add(this.variables.get(i));
-        }
-        return variables;
-    }
-
-    private double partialCorrelation(Node x, Node y, List<Node> z) throws SingularMatrixException {
-//        if (z.isEmpty()) {
-//            double a = covariances.getValue(indexMap.get(x), indexMap.get(y));
-//            double b = covariances.getValue(indexMap.get(x), indexMap.get(x));
-//            double c = covariances.getValue(indexMap.get(y), indexMap.get(y));
-//
-//            if (b * c == 0) throw new SingularMatrixException();
-//
-//            return -a / Math.sqrt(b * c);
-//        } else {
-        int[] indices = new int[z.size() + 2];
-        try {
-            indices[0] = indexMap.get(x);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-        indices[1] = indexMap.get(y);
-        for (int i = 0; i < z.size(); i++) indices[i + 2] = indexMap.get(z.get(i));
-        TetradMatrix submatrix = covariances.getSubmatrix(indices).getMatrix();
-        return StatUtils.partialCorrelation(submatrix);
-//        }
-    }
-
-    private Map<Node, Integer> indexMap(List<Node> variables) {
-        Map<Node, Integer> indexMap = new ConcurrentHashMap<>();
-
-        for (int i = 0; i < variables.size(); i++) {
-            indexMap.put(variables.get(i), i);
-        }
-
-        return indexMap;
-    }
-
-    @Override
-    public double localScoreDiff(int x, int y) {
-        return localScore(y, x) - localScore(y);
-    }
-
-    private int[] append(int[] parents, int extra) {
-        int[] all = new int[parents.length + 1];
-        System.arraycopy(parents, 0, all, 1, parents.length);
-        all[0] = extra;
-        return all;
-    }
-
-    /**
-     * Specialized scoring method for a single parent. Used to speed up the effect edges search.
-     */
-    public double localScore(int i, int parent) {
-        return localScore(i, new int[]{parent});
-
-//        double residualVariance = getCovariances().getValue(i, i);
-//        int n = getSampleSize();
-//        int p = 1;
-//        final double covXX = getCovariances().getValue(parent, parent);
-//
-//        if (covXX == 0) {
-//            if (isVerbose()) {
-//                out.println("Dividing by zero");
-//            }
-//            return Double.NaN;
-//        }
-//
-//        double covxxInv = 1.0 / covXX;
-//        double covxy = getCovariances().getValue(i, parent);
-//        double b = covxxInv * covxy;
-//        residualVariance -= covxy * b;
-//
-//        if (residualVariance <= 0) {
-//            if (isVerbose()) {
-//                out.println("Nonpositive residual varianceY: resVar / varianceY = " + (residualVariance / getCovariances().getValue(i, i)));
-//            }
-//            return Double.NaN;
-//        }
-//
-//        return score(residualVariance, n, p);
-    }
-
-    /**
-     * Specialized scoring method for no parents. Used to speed up the effect edges search.
-     */
-    public double localScore(int i) {
-        return localScore(i, new int[0]);
-//        double residualVariance = getCovariances().getValue(i, i);
-//        int n = getSampleSize();
-//        int p = 0;
-//
-//        if (residualVariance <= 0) {
-//            if (isVerbose()) {
-//                out.println("Nonpositive residual varianceY: resVar / varianceY = " + (residualVariance / getCovariances().getValue(i, i)));
-//            }
-//            return Double.NaN;
-//        }
-//
-//        double c = getPenaltyDiscount();
-//        return score(residualVariance, n, p);
-    }
-
-    /**
-     * True iff edges that cause linear dependence are ignored.
-     */
-    public boolean isIgnoreLinearDependent() {
-        return ignoreLinearDependent;
-    }
-
-    public void setIgnoreLinearDependent(boolean ignoreLinearDependent) {
-        this.ignoreLinearDependent = ignoreLinearDependent;
-    }
-
-    public void setOut(PrintStream out) {
-        this.out = out;
-    }
-
-    public double getPenaltyDiscount() {
-        return penaltyDiscount;
-    }
-
-    public ICovarianceMatrix getCovariances() {
-        return covariances;
-    }
-
-    public int getSampleSize() {
-        return sampleSize;
-    }
-
-    @Override
-    public boolean isEffectEdge(double bump) {
-        return bump > 0;//-0.25 * getPenaltyDiscount() * Math.log(sampleSize);
-    }
-
-    public DataSet getDataSet() {
-        throw new UnsupportedOperationException();
-    }
-
-    public void setPenaltyDiscount(double penaltyDiscount) {
-        this.penaltyDiscount = penaltyDiscount;
-    }
-
-    public boolean isVerbose() {
-        return verbose;
-    }
-
-    public void setVerbose(boolean verbose) {
-        this.verbose = verbose;
-    }
-
-    @Override
-    public List<Node> getVariables() {
-        return variables;
-    }
-
-    private TetradMatrix getSelection(ICovarianceMatrix cov, int[] rows, int[] cols) {
-        return cov.getSelection(rows, cols);
-    }
-
-    // Prints a smallest subset of parents that causes a singular matrix exception.
-    private boolean printMinimalLinearlyDependentSet(int[] parents, ICovarianceMatrix cov) {
-        List<Node> _parents = new ArrayList<>();
-        for (int p : parents) _parents.add(variables.get(p));
-
-        DepthChoiceGenerator gen = new DepthChoiceGenerator(_parents.size(), _parents.size());
-        int[] choice;
-
-        while ((choice = gen.next()) != null) {
-            int[] sel = new int[choice.length];
-            List<Node> _sel = new ArrayList<>();
-            for (int m = 0; m < choice.length; m++) {
-                sel[m] = parents[m];
-                _sel.add(variables.get(sel[m]));
-            }
-
-            TetradMatrix m = cov.getSelection(sel, sel);
-
-            try {
-                m.inverse();
-            } catch (Exception e2) {
-                forbidden.add(sel[0]);
-                out.println("### Linear dependence among variables: " + _sel);
-                out.println("### Removing " + _sel.get(0));
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    private void setCovariances(ICovarianceMatrix covariances) {
-        this.covariances = covariances;
-    }
-
-    public void setVariables(List<Node> variables) {
-        covariances.setVariables(variables);
-        this.variables = variables;
-    }
-
-    @Override
-    public Node getVariable(String targetName) {
-        for (Node node : variables) {
-            if (node.getName().equals(targetName)) {
-                return node;
-            }
-        }
-
-        return null;
-    }
-
-    @Override
-    public int getMaxDegree() {
-        return (int) Math.ceil(log(sampleSize));
-    }
-
-    @Override
-    public boolean determines(List<Node> z, Node y) {
-        int i = variables.indexOf(y);
-
-        int[] k = new int[z.size()];
-
-        for (int t = 0; t < z.size(); t++) {
-            k[t] = variables.indexOf(z.get(t));
-        }
-
-        double v = localScore(i, k);
-
-        return Double.isNaN(v);
-    }
-
-    public int getNumInBootstrap() {
-        return numInBootstrap;
-    }
-
-    public int getNumBootstraps() {
-        return numBootstraps;
-    }
-
-    public double getBootstrapAlpha() {
-        return bootstrapAlpha;
-    }
-
-    public void setNumInBootstrap(int numInBootstrap) {
-        this.numInBootstrap = numInBootstrap;
-    }
-
-    public void setNumBootstraps(int numBootstraps) {
-        this.numBootstraps = numBootstraps;
-    }
-
-    public void setBootstrapAlpha(double bootstrapAlpha) {
-        this.bootstrapAlpha = bootstrapAlpha;
-    }
-}
-
-
-
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SepsetsGreedy.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SepsetsGreedy.java
index fc73603a..1484454c 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SepsetsGreedy.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/SepsetsGreedy.java
@@ -21,14 +21,11 @@
 
 package edu.cmu.tetrad.search;
 
-import edu.cmu.tetrad.data.IKnowledge;
-import edu.cmu.tetrad.data.Knowledge2;
 import edu.cmu.tetrad.graph.Graph;
 import edu.cmu.tetrad.graph.GraphUtils;
 import edu.cmu.tetrad.graph.Node;
 import edu.cmu.tetrad.util.ChoiceGenerator;
 
-import java.util.LinkedList;
 import java.util.List;
 
 /**
@@ -41,7 +38,7 @@ public class SepsetsGreedy implements SepsetProducer {
     private final SepsetMap extraSepsets;
     private int depth = 3;
     private boolean verbose = false;
-    private IKnowledge knowledge = new Knowledge2();
+    private Graph dag;
 
     public SepsetsGreedy(Graph graph, IndependenceTest independenceTest, SepsetMap extraSepsets, int depth) {
         this.graph = graph;
@@ -80,8 +77,6 @@ public class SepsetsGreedy implements SepsetProducer {
         List<Node> adjk = graph.getAdjacentNodes(k);
         adji.remove(k);
         adjk.remove(i);
-        adji = possibleParents(i, adji, knowledge);
-        adjk = possibleParents(k, adjk, knowledge);
 
         for (int d = 0; d <= Math.min((depth == -1 ? 1000 : depth), Math.max(adji.size(), adjk.size())); d++) {
             if (d <= adji.size()) {
@@ -158,33 +153,5 @@ public class SepsetsGreedy implements SepsetProducer {
     public void setDepth(int depth) {
         this.depth = depth;
     }
-
-    private List<Node> possibleParents(Node x, List<Node> adjx,
-                                       IKnowledge knowledge) {
-        List<Node> possibleParents = new LinkedList<>();
-        String _x = x.getName();
-
-        for (Node z : adjx) {
-            String _z = z.getName();
-
-            if (possibleParentOf(_z, _x, knowledge)) {
-                possibleParents.add(z);
-            }
-        }
-
-        return possibleParents;
-    }
-
-    private boolean possibleParentOf(String z, String x, IKnowledge knowledge) {
-        return !knowledge.isForbidden(z, x) && !knowledge.isRequired(x, z);
-    }
-
-    public IKnowledge getKnowledge() {
-        return knowledge;
-    }
-
-    public void setKnowledge(IKnowledge knowledge) {
-        this.knowledge = knowledge;
-    }
 }
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/TimeSeriesUtils.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/TimeSeriesUtils.java
index 02fd8d94..187e5409 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/search/TimeSeriesUtils.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/search/TimeSeriesUtils.java
@@ -399,37 +399,37 @@ public class TimeSeriesUtils {
             }
         }
 
-////        System.out.println("Variable list before the sort = " + newVariables);
-//        Collections.sort(newVariables, new Comparator<Node>() {
-//            @Override
-//            public int compare(Node o1, Node o2) {
-//                String name1 = getNameNoLag(o1);
-//                String name2 = getNameNoLag(o2);
-//
-////                System.out.println("name 1 = " + name1);
-////                System.out.println("name 2 = " + name2);
-//                String prefix1 = getPrefix(name1);
-//                String prefix2 = getPrefix(name2);
-//
-////                System.out.println("prefix 1 = " + prefix1);
-////                System.out.println("prefix 2 = " + prefix2);
-//                int index1 = getIndex(name1);
-//                int index2 = getIndex(name2);
-//
-////                System.out.println("index 1 = " + index1);
-////                System.out.println("index 2 = " + index2);
-//                if (getLag(o1.getName()) == getLag(o2.getName())) {
-//                    if (prefix1.compareTo(prefix2) == 0) {
-//                        return Integer.compare(index1, index2);
-//                    } else {
-//                        return prefix1.compareTo(prefix2);
-//                    }
-//
-//                } else {
-//                    return getLag(o1.getName()) - getLag(o2.getName());
-//                }
-//            }
-//        });
+//        System.out.println("Variable list before the sort = " + newVariables);
+        Collections.sort(newVariables, new Comparator<Node>() {
+            @Override
+            public int compare(Node o1, Node o2) {
+                String name1 = getNameNoLag(o1);
+                String name2 = getNameNoLag(o2);
+
+//                System.out.println("name 1 = " + name1);
+//                System.out.println("name 2 = " + name2);
+                String prefix1 = getPrefix(name1);
+                String prefix2 = getPrefix(name2);
+
+//                System.out.println("prefix 1 = " + prefix1);
+//                System.out.println("prefix 2 = " + prefix2);
+                int index1 = getIndex(name1);
+                int index2 = getIndex(name2);
+
+//                System.out.println("index 1 = " + index1);
+//                System.out.println("index 2 = " + index2);
+                if (getLag(o1.getName()) == getLag(o2.getName())) {
+                    if (prefix1.compareTo(prefix2) == 0) {
+                        return Integer.compare(index1, index2);
+                    } else {
+                        return prefix1.compareTo(prefix2);
+                    }
+
+                } else {
+                    return getLag(o1.getName()) - getLag(o2.getName());
+                }
+            }
+        });
 
 //        System.out.println("Variable list after the sort = " + newVariables);
         for (Node node : newVariables) {
@@ -474,36 +474,35 @@ public class TimeSeriesUtils {
      * Creates new time series dataset from the given one with index variable
      * (e.g., time)
      */
-    public static DataSet addIndex(DataSet data) {
-        data = data.copy();
-        ContinuousVariable timeVar = new ContinuousVariable("Time");
-        data.addVariable(timeVar);
-        int c = data.getColumn(timeVar);
+    public static DataSet createLagDataWithIndex(DataSet data, int numLags) {
+        ContinuousVariable time = new ContinuousVariable("Time");
 
-        for (int r = 0; r < data.getNumRows(); r++) {
-            data.setDouble(r, c, (r + 1));
-        }
+        data.addVariable(time);
+        int timeCol = data.getColumn(time);
 
-        return data;
+        for (int i = 0; i < data.getNumRows(); i++) {
+            data.setDouble(i, timeCol, i + 1);
+        }
 
+        return TimeSeriesUtils.createLagData(data, numLags);
 
 //        List<Node> variables = data.getVariables();
 //        int dataSize = variables.size();
 //        int laggedRows = data.getNumRows() - numLags;
 //        IKnowledge knowledge = new Knowledge2();
-//        Node[][] laggedNodes = new Node[numLags + 1][dataSize];
+//        Node[] laggedNodes = new Node[dataSize];
 //        List<Node> newVariables = new ArrayList<>((numLags + 1) * dataSize + 2); // added 1 to this
 //
-//        for (int lag = 0; lag <= numLags; lag++) {
+////        for (int lag = 0; lag <= numLags; lag++) {
 //            for (int col = 0; col < dataSize; col++) {
 //                Node node = variables.get(col);
 //                String varName = node.getName();
 //                Node laggedNode;
 //                String name = varName;
 //
-//                if (lag != 0) {
-//                    name = name + ":" + lag;
-//                }
+////                if (lag != 0) {
+////                    name = name + ":" + lag;
+////                }
 //
 //                if (node instanceof ContinuousVariable) {
 //                    laggedNode = new ContinuousVariable(name);
@@ -515,11 +514,11 @@ public class TimeSeriesUtils {
 //                    throw new IllegalStateException("Node must be either continuous or discrete");
 //                }
 //                newVariables.add(laggedNode);
-//                laggedNode.setCenter(80 * col + 50, 80 * (numLags - lag) + 50);
-//                laggedNodes[lag][col] = laggedNode;
+//                laggedNode.setCenter(80 * col + 50, 80 * (numLags) + 50);
+//                laggedNodes[col] = laggedNode;
 ////                knowledge.addToTier(numLags - lag + 1, laggedNode.getName());
 //            }
-//        }
+////        }
 //
 //        String name = "time";
 //        Node indexNode = new ContinuousVariable(name);
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/GeneralizedSemIm.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/GeneralizedSemIm.java
index 0b6b7e51..0fce7018 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/GeneralizedSemIm.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/GeneralizedSemIm.java
@@ -853,9 +853,6 @@ public class GeneralizedSemIm implements IM, Simulator, TetradSerializable {
      */
     public DataSet simulateDataFisher(int sampleSize, int intervalBetweenShocks,
                                       double epsilon) {
-        boolean printedUndefined = false;
-        boolean printedInfinite = false;
-
         if (intervalBetweenShocks < 1) throw new IllegalArgumentException(
                 "Interval between shocks must be >= 1: " + intervalBetweenShocks);
         if (epsilon <= 0.0) throw new IllegalArgumentException(
@@ -889,7 +886,6 @@ public class GeneralizedSemIm implements IM, Simulator, TetradSerializable {
         double[][] all = new double[variableNodes.size()][sampleSize];
 
         // Do the simulation.
-
         for (int row = 0; row < sampleSize; row++) {
             for (int j = 0; j < t1.length; j++) {
                 Node error = pm.getErrorNode(variableNodes.get(j));
@@ -911,24 +907,10 @@ public class GeneralizedSemIm implements IM, Simulator, TetradSerializable {
 
             for (int i = 0; i < intervalBetweenShocks; i++) {
                 for (int j = 0; j < t1.length; j++) {
+                    t2[j] = shocks[j];
                     Node node = variableNodes.get(j);
                     Expression expression = pm.getNodeExpression(node);
                     t2[j] = expression.evaluate(context);
-
-                    if (Double.isNaN(t2[j])) {
-                        if (!printedUndefined) {
-                            System.out.println("Undefined value.");
-                            printedUndefined = true;
-                        }
-                    }
-
-                    if (Double.isInfinite(t2[j])) {
-                        if (!printedInfinite) {
-                            System.out.println("Infinite value.");
-                            printedInfinite = true;
-                        }
-                    }
-
                     variableValues.put(node.getName(), t2[j]);
                 }
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/LargeScaleSimulationSmithSim.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/LargeScaleSimulationSmithSim.java
deleted file mode 100644
index d9a848f4..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/LargeScaleSimulationSmithSim.java
+++ /dev/null
@@ -1,1011 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.sem;
-
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.*;
-import edu.cmu.tetrad.util.*;
-import edu.cmu.tetrad.util.dist.Distribution;
-import edu.cmu.tetrad.util.dist.Split;
-import edu.cmu.tetrad.util.dist.Uniform;
-import org.apache.commons.collections4.map.HashedMap;
-import org.apache.commons.math3.distribution.AbstractRealDistribution;
-import org.apache.commons.math3.distribution.BetaDistribution;
-import org.apache.commons.math3.distribution.NormalDistribution;
-import org.apache.commons.math3.random.Well1024a;
-
-import java.io.PrintStream;
-import java.util.*;
-import java.util.concurrent.RecursiveTask;
-
-import static java.lang.Math.abs;
-import static java.lang.Math.signum;
-import static java.lang.Math.sqrt;
-
-/**
- * Stores a SEM model, pared down, for purposes of simulating data sets with
- * large numbers of variables and sample sizes. Assumes acyclicity.
- *
- * @author Joseph Ramsey
- */
-public final class LargeScaleSimulationSmithSim {
-    static final long serialVersionUID = 23L;
-
-    private int[][] parents;
-    private double[][] coefs;
-    private double[][] coefs2;
-    private double[] errorVars;
-    private double[] errorVars2;
-    private double[] means;
-    private double[] means2;
-    private transient TetradAlgebra algebra;
-    private List<Node> variableNodes;
-    private Graph graph;
-    private double coefLow = .2;
-    private double coefHigh = 1.5;
-    private double varLow = 1.0;
-    private double varHigh = 3.0;
-    private double meanLow = 0;
-    private double meanHigh = 0;
-    private PrintStream out = System.out;
-    private int[] tierIndices;
-    private boolean verbose = false;
-    long seed = new Date().getTime();
-    private boolean alreadySetUp = false;
-    //    private boolean coefSymmetric = false;
-    private boolean includePositiveCoefs = true;
-    private boolean includeNegativeCoefs = true;
-
-    private boolean errorsNormal = true;
-    //    private boolean errorsPositivelySkewedIfNonNormal = true;
-    private double betaLeftValue;
-    private double betaRightValue;
-
-    //=============================CONSTRUCTORS============================//
-
-    public LargeScaleSimulationSmithSim(Graph graph) {
-        this.graph = graph;
-        this.variableNodes = graph.getNodes();
-
-        if (graph instanceof SemGraph) {
-            ((SemGraph) graph).setShowErrorTerms(false);
-        }
-
-        List<Node> causalOrdering = graph.getCausalOrdering();
-        this.tierIndices = new int[causalOrdering.size()];
-        for (int i = 0; i < tierIndices.length; i++) tierIndices[i] = variableNodes.indexOf(causalOrdering.get(i));
-    }
-
-    public LargeScaleSimulationSmithSim(Graph graph, List<Node> nodes, int[] tierIndices) {
-        if (graph == null) {
-            throw new NullPointerException("Graph must not be null.");
-        }
-
-        this.graph = GraphUtils.replaceNodes(graph, nodes);
-        this.variableNodes = nodes;
-        this.tierIndices = tierIndices;
-
-        if (graph instanceof SemGraph) {
-            ((SemGraph) graph).setShowErrorTerms(false);
-        }
-    }
-
-    /**
-     * This simulates data by picking random values for the exogenous terms and
-     * percolating this information down through the SEM, assuming it is
-     * acyclic. Works, but will hang for cyclic models, and is very slow for
-     * large numbers of variables (probably due to the heavyweight lookups of
-     * various values--could be improved). The model must be acyclic, or else
-     * this will spin.
-     */
-    public DataSet simulateDataRecursive(int sampleSize) {
-        if (tierIndices == null) {
-            List<Node> nodes = graph.getNodes();
-            tierIndices = new int[nodes.size()];
-            for (int j = 0; j < nodes.size(); j++) {
-                tierIndices[j] = j;
-            }
-        }
-
-        int size = variableNodes.size();
-        setupModel(size);
-
-        class SimulateTask extends RecursiveTask<Boolean> {
-            private final int from;
-            private final int to;
-            private double[][] all;
-            private int chunk;
-
-            public SimulateTask(int from, int to, double[][] all, int chunk) {
-                this.from = from;
-                this.to = to;
-                this.all = all;
-                this.chunk = chunk;
-            }
-
-            @Override
-            protected Boolean compute() {
-                if (from - to > chunk) {
-                    int mid = from + to / 2;
-                    SimulateTask left = new SimulateTask(from, mid, all, chunk);
-                    SimulateTask right = new SimulateTask(mid, to, all, chunk);
-                    left.fork();
-                    right.compute();
-                    left.join();
-                    return true;
-                } else {
-                    for (int i = from; i < to; i++) {
-                        NormalDistribution normal = new NormalDistribution(new Well1024a(++seed), 0, 1);//sqrt(errorVars[col]));
-                        normal.sample();
-
-                        if (verbose && (i + 1) % 50 == 0)
-                            System.out.println("Simulating " + (i + 1));
-
-                        for (int col : tierIndices) {
-                            double value = normal.sample() * sqrt(errorVars[col]);
-
-                            for (int j = 0; j < parents[col].length; j++) {
-                                value += all[parents[col][j]][i] * coefs[col][j];
-                            }
-
-                            value += means[col];
-
-                            all[col][i] = value;
-                        }
-                    }
-
-                    return true;
-                }
-            }
-        }
-
-        if (graph instanceof TimeLagGraph) {
-            sampleSize += 200;
-        }
-
-        double[][] all = new double[variableNodes.size()][sampleSize];
-
-        int chunk = sampleSize / ForkJoinPoolInstance.getInstance().getPool().getParallelism() + 1;
-
-        ForkJoinPoolInstance.getInstance().getPool().invoke(new SimulateTask(0, sampleSize, all, chunk));
-
-        if (graph instanceof TimeLagGraph) {
-            int[] rem = new int[200];
-            for (int i = 0; i < 200; ++i) {
-                rem[i] = i;
-            }
-            BoxDataSet dat = new BoxDataSet(new VerticalDoubleDataBox(all), variableNodes);
-            dat.removeRows(rem);
-            return dat;
-        }
-
-        return new BoxDataSet(new VerticalDoubleDataBox(all), variableNodes);
-    }
-
-    /**
-     * Simulates data using the model X = (I - B)Y^-1 * e. Errors are uncorrelated.
-     *
-     * @param sampleSize The nubmer of samples to draw.
-     */
-    public DataSet simulateDataReducedForm(int sampleSize) {
-        if (sampleSize < 1) throw new IllegalArgumentException(
-                "Sample size must be >= 1: " + sampleSize);
-
-        int size = variableNodes.size();
-        setupModel(size);
-
-        NormalDistribution normal = new NormalDistribution(new Well1024a(++seed), 0, 1);
-
-        TetradMatrix B = new TetradMatrix(getCoefficientMatrix());
-        TetradMatrix iMinusBInv = TetradAlgebra.identity(B.rows()).minus(B).inverse();
-
-        double[][] all = new double[variableNodes.size()][sampleSize];
-
-        for (int row = 0; row < sampleSize; row++) {
-            TetradVector e = new TetradVector(B.rows());
-
-            for (int j = 0; j < e.size(); j++) {
-                e.set(j, normal.sample() * sqrt(errorVars[j]));
-            }
-
-            TetradVector x = iMinusBInv.times(e);
-
-            for (int j = 0; j < x.size(); j++) {
-                all[j][row] = x.get(j);
-            }
-        }
-
-        List<Node> continuousVars = new ArrayList<>();
-
-        for (Node node : getVariableNodes()) {
-            final ContinuousVariable var = new ContinuousVariable(node.getName());
-            var.setNodeType(node.getNodeType());
-            continuousVars.add(var);
-        }
-
-        BoxDataSet boxDataSet = new BoxDataSet(new VerticalDoubleDataBox(all), continuousVars);
-        return DataUtils.restrictToMeasured(boxDataSet);
-    }
-
-    /**
-     * Simulates data using the model of R. A. Fisher, for a linear model. Shocks are
-     * applied every so many steps. A data point is recorded before each shock is
-     * administered. If convergence happens before that number of steps has been reached,
-     * a data point is recorded and a new shock immediately applied. The model may be
-     * cyclic. If cyclic, all eigenvalues for the coefficient matrix must be less than 1,
-     * though this is not checked. Uses an interval between shocks of 50 and a convergence
-     * threshold of 1e-5. Uncorrelated Gaussian shocks are used.
-     *
-     * @param sampleSize The number of samples to be drawn. Must be a positive
-     *                   integer.
-     */
-    public DataSet simulateDataFisher(int sampleSize) {
-        return simulateDataFisher(getSoCalledPoissonShocks(sampleSize), 50, 1e-5);
-    }
-
-    /**
-     * Simulates data using the model of R. A. Fisher, for a linear model. Shocks are
-     * applied every so many steps. A data point is recorded before each shock is
-     * administered. If convergence happens before that number of steps has been reached,
-     * a data point is recorded and a new shock immediately applied. The model may be
-     * cyclic. If cyclic, all eigenvalues for the coefficient matrix must be less than 1,
-     * though this is not checked.
-     *
-     * @param shocks                A matrix of shocks. The value at shocks[i][j] is the shock
-     *                              for the i'th time step, for the j'th variables.
-     * @param intervalBetweenShocks External shock is applied every this many steps.
-     *                              Must be positive integer.
-     * @param epsilon               The convergence criterion; |xi.t - xi.t-1| < epsilon.
-     */
-    public DataSet simulateDataFisher(double[][] shocks, int intervalBetweenShocks, double epsilon) {
-        if (intervalBetweenShocks < 1) throw new IllegalArgumentException(
-                "Interval between shocks must be >= 1: " + intervalBetweenShocks);
-        if (epsilon <= 0.0) throw new IllegalArgumentException(
-                "Epsilon must be > 0: " + epsilon);
-
-        int size = variableNodes.size();
-        if (shocks[0].length != size) {
-            throw new IllegalArgumentException("The number of columns in the shocks matrix does not equal " +
-                    "the number of variables.");
-        }
-
-        setupModel(size);
-        setupModel2(size);
-
-        double[] t1 = new double[variableNodes.size()];
-        double[] t2 = new double[variableNodes.size()];
-        double[][] all = new double[variableNodes.size()][shocks.length];
-
-        // Do the simulation.
-        for (int row = 0; row < shocks.length; row++) {
-            for (int j = 0; j < t1.length; j++) {
-                t2[j] = shocks[row][j];
-            }
-
-            for (int i = 0; i < intervalBetweenShocks; i++) {
-                for (int j = 0; j < t1.length; j++) {
-                    for (int k = 0; k < parents[j].length; k++) {
-                        t2[j] += t1[parents[j][k]] * coefs[j][k];
-                    }
-                }
-
-                boolean converged = true;
-
-                for (int j = 0; j < t1.length; j++) {
-                    if (abs(t2[j] - t1[j]) > epsilon) {
-                        converged = false;
-                        break;
-                    }
-                }
-
-                double[] t3 = t1;
-                t1 = t2;
-                t2 = t3;
-
-                if (converged) {
-                    break;
-                }
-            }
-
-            for (int j = 0; j < t1.length; j++) {
-                all[j][row] = t1[j];
-            }
-        }
-
-        List<Node> continuousVars = new ArrayList<>();
-
-        for (Node node : getVariableNodes()) {
-            final ContinuousVariable var = new ContinuousVariable(node.getName());
-            var.setNodeType(node.getNodeType());
-            continuousVars.add(var);
-        }
-
-        BoxDataSet boxDataSet = new BoxDataSet(new VerticalDoubleDataBox(all), continuousVars);
-        return DataUtils.restrictToMeasured(boxDataSet);
-    }
-
-    public DataSet simulateDataFisher(int intervalBetweenShocks, int intervalBetweenRecordings, int sampleSize, double epsilon) {
-        if (intervalBetweenShocks < 1) throw new IllegalArgumentException(
-                "Interval between shocks must be >= 1: " + intervalBetweenShocks);
-        if (epsilon <= 0.0) throw new IllegalArgumentException(
-                "Epsilon must be > 0: " + epsilon);
-
-        int size = variableNodes.size();
-
-        setupModel(size);
-        setupModel2(size);
-
-        // Temporary to mimic Simulation 22 from Smith et al.
-        double[][] states = new double[variableNodes.size()][sampleSize];
-
-        for (int v = 0; v < variableNodes.size(); v++) {
-            for (int t = 1; t < sampleSize; t++) {
-                if (states[v][t - 1] == 0) { //if the previous data point is zero.
-                    if (RandomUtil.getInstance().nextDouble() < .1)
-                        states[v][t] = 1;
-                    else {
-                        states[v][t] = 0;
-                    }
-                } else if (states[v][t - 1] == 1) { //if the previous data point is one.
-                    if (RandomUtil.getInstance().nextDouble() < .1)
-                        states[v][t] = 0;
-                    else {
-                        states[v][t] = 1;
-                    }
-                }
-            }
-        }
-
-        double[] t1 = new double[variableNodes.size()];
-        double[] t2 = new double[variableNodes.size()];
-        double[][] all = new double[variableNodes.size()][sampleSize];
-
-        int s = 0;
-        int shockIndex = 0;
-        int recordingIndex = 0;
-        double[] shock = getUncorrelatedShocks(1)[0];
-
-        while (s < sampleSize) {
-            if ((++shockIndex) % intervalBetweenShocks == 0) {
-                shock = getUncorrelatedShocks(1)[0];
-            }
-
-            if ((++recordingIndex) % intervalBetweenRecordings == 0) {
-                for (int j = 0; j < t1.length; j++) {
-                    all[j][s] = t1[j];
-                }
-
-                s++;
-            }
-
-            for (int j = 0; j < t1.length; j++) {
-                t2[j] = shock[j];
-            }
-
-            double inStrengthStd = .5;
-            double inStrengthMean = .5;
-
-            for (int j = 0; j < t1.length; j++) {
-                t2[j] = shock[j];
-                for (int k = 0; k < parents[j].length; k++) {
-                    double coef = 0.0;
-                    double stim = 0.0;
-
-                    if (s < sampleSize) {
-                        if (states[k][s] == 0) {
-                            coef = coefs[j][k];
-//                            stim = RandomUtil.getInstance().nextNormal(0, inStrengthStd);
-                        } else {
-                            coef = coefs2[j][k];
-
-
-                            coef = signum(coefs[j][k]) * abs(coef);
-//                            coef = 0;
-//                            stim = RandomUtil.getInstance().nextNormal(inStrengthMean, inStrengthStd);
-                        }
-
-//                        coef = coefs[j][k] + stim * coefs2[j][k];
-
-//                        if (coef < 0.2) coef = 0.2;
-//                        if (coef > 0.6) coef = 0.6;
-                    }
-
-
-//                    System.out.println(coef);
-
-//                    double coef = coefs[j][k];
-//                    double _stim = s < sampleSize ? stim[s][k] : 0;
-                    t2[j] = t2[j] + (t1[parents[j][k]]) * coef;
-                }
-            }
-
-            double[] t3 = t1;
-            t1 = t2;
-            t2 = t3;
-        }
-
-        List<Node> continuousVars = new ArrayList<>();
-
-        for (Node node : getVariableNodes()) {
-            final ContinuousVariable var = new ContinuousVariable(node.getName());
-            var.setNodeType(node.getNodeType());
-            continuousVars.add(var);
-        }
-
-        BoxDataSet boxDataSet = new BoxDataSet(new VerticalDoubleDataBox(all), continuousVars);
-        return DataUtils.restrictToMeasured(boxDataSet);
-    }
-
-    private void setupModel(int size) {
-        if (alreadySetUp) return;
-
-        Map<Node, Integer> nodesHash = new HashedMap<>();
-
-        for (int i = 0; i < variableNodes.size(); i++) {
-            nodesHash.put(variableNodes.get(i), i);
-        }
-
-        this.parents = new int[size][];
-        this.coefs = new double[size][];
-        this.errorVars = new double[size];
-        this.means = new double[size];
-
-        for (int i = 0; i < size; i++) {
-            this.parents[i] = new int[0];
-            this.coefs[i] = new double[0];
-        }
-
-        Distribution edgeCoefDist = new Split(coefLow, coefHigh);
-        Distribution errorCovarDist = new Uniform(varLow, varHigh);
-        Distribution meanDist = new Uniform(meanLow, meanHigh);
-
-        for (Edge edge : graph.getEdges()) {
-            Node tail = Edges.getDirectedEdgeTail(edge);
-            Node head = Edges.getDirectedEdgeHead(edge);
-
-            int _tail = nodesHash.get(tail);
-            int _head = nodesHash.get(head);
-
-            int[] parents = this.parents[_head];
-            int[] newParents = new int[parents.length + 1];
-            System.arraycopy(parents, 0, newParents, 0, parents.length);
-            newParents[newParents.length - 1] = _tail;
-            double[] coefs = this.coefs[_head];
-            double[] newCoefs = new double[coefs.length + 1];
-
-            System.arraycopy(coefs, 0, newCoefs, 0, coefs.length);
-
-            double coef = edgeCoefDist.nextRandom();
-//            if (coefSymmetric) coef = Math.abs(coef);
-
-            if (includePositiveCoefs && !includeNegativeCoefs) {
-                coef = abs(coef);
-            } else if (!includePositiveCoefs && includeNegativeCoefs) {
-                coef = -abs(coef);
-            } else if (!includePositiveCoefs && !includeNegativeCoefs) {
-                coef = 0;
-            }
-
-            newCoefs[newCoefs.length - 1] = coef;
-
-            this.parents[_head] = newParents;
-            this.coefs[_head] = newCoefs;
-        }
-
-        if (graph instanceof TimeLagGraph) {
-            TimeLagGraph lagGraph = (TimeLagGraph) graph;
-            IKnowledge knowledge = getKnowledge(lagGraph); //TimeSeriesUtils.getKnowledge(lagGraph);
-            List<Node> lag0 = lagGraph.getLag0Nodes();
-
-            for (Node y : lag0) {
-                List<Node> _parents = lagGraph.getParents(y);
-
-                for (Node x : _parents) {
-                    List<List<Node>> similar = returnSimilarPairs(x, y, knowledge);
-
-                    int _x = variableNodes.indexOf(x);
-                    int _y = variableNodes.indexOf(y);
-                    double first = Double.NaN;
-
-                    for (int i = 0; i < parents[_y].length; i++) {
-                        if (_x == parents[_y][i]) {
-                            first = coefs[_y][i];
-                        }
-                    }
-
-                    for (int j = 0; j < similar.get(0).size(); j++) {
-                        int _xx = variableNodes.indexOf(similar.get(0).get(j));
-                        int _yy = variableNodes.indexOf(similar.get(1).get(j));
-
-                        for (int i = 0; i < parents[_yy].length; i++) {
-                            if (_xx == parents[_yy][i]) {
-                                coefs[_yy][i] = first;
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        for (int i = 0; i < size; i++) {
-            this.errorVars[i] = errorCovarDist.nextRandom();
-            this.means[i] = meanDist.nextRandom();
-        }
-
-        alreadySetUp = true;
-    }
-
-    private void setupModel2(int size) {
-//        if (alreadySetUp) return;
-
-        Map<Node, Integer> nodesHash = new HashedMap<>();
-
-        for (int i = 0; i < variableNodes.size(); i++) {
-            nodesHash.put(variableNodes.get(i), i);
-        }
-
-//        this.parents = new int[size][];
-        this.coefs2 = new double[size][];
-        this.errorVars2 = new double[size];
-        this.means2 = new double[size];
-
-        for (int i = 0; i < size; i++) {
-//            this.parents[i] = new int[0];
-            this.coefs2[i] = new double[0];
-        }
-
-        Distribution edgeCoefDist = new Split(coefLow, coefHigh);
-        Distribution errorCovarDist = new Uniform(varLow, varHigh);
-        Distribution meanDist = new Uniform(meanLow, meanHigh);
-
-        for (Edge edge : graph.getEdges()) {
-            Node tail = Edges.getDirectedEdgeTail(edge);
-            Node head = Edges.getDirectedEdgeHead(edge);
-
-//            int _tail = nodesHash.get(tail);
-            int _head = nodesHash.get(head);
-
-//            int[] parents = this.parents[_head];
-//            int[] newParents = new int[parents.length + 1];
-//            System.arraycopy(parents, 0, newParents, 0, parents.length);
-//            newParents[newParents.length - 1] = _tail;
-            double[] coefs = this.coefs2[_head];
-            double[] newCoefs = new double[coefs.length + 1];
-
-            System.arraycopy(coefs, 0, newCoefs, 0, coefs.length);
-
-            double coef = edgeCoefDist.nextRandom();
-//            if (coefSymmetric) coef = Math.abs(coef);
-
-            if (includePositiveCoefs && !includeNegativeCoefs) {
-                coef = abs(coef);
-            } else if (!includePositiveCoefs && includeNegativeCoefs) {
-                coef = -abs(coef);
-            } else if (!includePositiveCoefs && !includeNegativeCoefs) {
-                coef = 0;
-            }
-
-            newCoefs[newCoefs.length - 1] = coef;
-
-//            this.parents[_head] = newParents;
-            this.coefs2[_head] = newCoefs;
-        }
-
-        for (int i = 0; i < size; i++) {
-            this.errorVars2[i] = errorCovarDist.nextRandom();
-            this.means2[i] = meanDist.nextRandom();
-        }
-
-//        alreadySetUp = true;
-    }
-
-    public TetradAlgebra getAlgebra() {
-        if (algebra == null) {
-            algebra = new TetradAlgebra();
-        }
-
-        return algebra;
-    }
-
-    public Graph getGraph() {
-        return graph;
-    }
-
-    public void setCoefRange(double coefLow, double coefHigh) {
-        this.coefLow = coefLow;
-        this.coefHigh = coefHigh;
-    }
-
-    public void setVarRange(double varLow, double varHigh) {
-        this.varLow = varLow;
-        this.varHigh = varHigh;
-    }
-
-    public void setMeanRange(double meanLow, double meanHigh) {
-        this.meanLow = meanLow;
-        this.meanHigh = meanHigh;
-    }
-
-    public void setOut(PrintStream out) {
-        this.out = out;
-    }
-
-    public PrintStream getOut() {
-        return out;
-    }
-
-    public boolean isVerbose() {
-        return verbose;
-    }
-
-    public void setVerbose(boolean verbose) {
-        this.verbose = verbose;
-    }
-
-    public double[][] getCoefficientMatrix() {
-        double[][] c = new double[coefs.length][coefs.length];
-
-        for (int i = 0; i < coefs.length; i++) {
-            for (int j = 0; j < coefs[i].length; j++) {
-                c[i][parents[i][j]] = coefs[i][j];
-            }
-        }
-
-        return c;
-    }
-
-    public List<Node> getVariableNodes() {
-        return variableNodes;
-    }
-
-    // returnSimilarPairs based on orientSimilarPairs in TsFciOrient.java by Entner and Hoyer
-    private List<List<Node>> returnSimilarPairs(Node x, Node y, IKnowledge knowledge) {
-        System.out.println("$$$$$ Entering returnSimilarPairs method with x,y = " + x + ", " + y);
-        if (x.getName().equals("time") || y.getName().equals("time")) {
-            return new ArrayList<>();
-        }
-//        System.out.println("Knowledge within returnSimilar : " + knowledge);
-        int ntiers = knowledge.getNumTiers();
-        int indx_tier = knowledge.isInWhichTier(x);
-        int indy_tier = knowledge.isInWhichTier(y);
-        int tier_diff = Math.max(indx_tier, indy_tier) - Math.min(indx_tier, indy_tier);
-        int indx_comp = -1;
-        int indy_comp = -1;
-        List tier_x = knowledge.getTier(indx_tier);
-//        Collections.sort(tier_x);
-        List tier_y = knowledge.getTier(indy_tier);
-//        Collections.sort(tier_y);
-
-        int i;
-        for (i = 0; i < tier_x.size(); ++i) {
-            if (getNameNoLag(x.getName()).equals(getNameNoLag(tier_x.get(i)))) {
-                indx_comp = i;
-                break;
-            }
-        }
-
-        for (i = 0; i < tier_y.size(); ++i) {
-            if (getNameNoLag(y.getName()).equals(getNameNoLag(tier_y.get(i)))) {
-                indy_comp = i;
-                break;
-            }
-        }
-
-        System.out.println("original independence: " + x + " and " + y);
-
-        if (indx_comp == -1) System.out.println("WARNING: indx_comp = -1!!!! ");
-        if (indy_comp == -1) System.out.println("WARNING: indy_comp = -1!!!! ");
-
-
-        List<Node> simListX = new ArrayList<>();
-        List<Node> simListY = new ArrayList<>();
-
-        for (i = 0; i < ntiers - tier_diff; ++i) {
-            if (knowledge.getTier(i).size() == 1) continue;
-            String A;
-            Node x1;
-            String B;
-            Node y1;
-            if (indx_tier >= indy_tier) {
-                List tmp_tier1 = knowledge.getTier(i + tier_diff);
-//                Collections.sort(tmp_tier1);
-                List tmp_tier2 = knowledge.getTier(i);
-//                Collections.sort(tmp_tier2);
-                A = (String) tmp_tier1.get(indx_comp);
-                B = (String) tmp_tier2.get(indy_comp);
-                if (A.equals(B)) continue;
-                if (A.equals(tier_x.get(indx_comp)) && B.equals(tier_y.get(indy_comp))) continue;
-                if (B.equals(tier_x.get(indx_comp)) && A.equals(tier_y.get(indy_comp))) continue;
-                x1 = graph.getNode(A);
-                y1 = graph.getNode(B);
-                System.out.println("Adding pair to simList = " + x1 + " and " + y1);
-                simListX.add(x1);
-                simListY.add(y1);
-            } else {
-                //System.out.println("############## WARNING (returnSimilarPairs): did not catch x,y pair " + x + ", " + y);
-                //System.out.println();
-                List tmp_tier1 = knowledge.getTier(i);
-//                Collections.sort(tmp_tier1);
-                List tmp_tier2 = knowledge.getTier(i + tier_diff);
-//                Collections.sort(tmp_tier2);
-                A = (String) tmp_tier1.get(indx_comp);
-                B = (String) tmp_tier2.get(indy_comp);
-                if (A.equals(B)) continue;
-                if (A.equals(tier_x.get(indx_comp)) && B.equals(tier_y.get(indy_comp))) continue;
-                if (B.equals(tier_x.get(indx_comp)) && A.equals(tier_y.get(indy_comp))) continue;
-                x1 = graph.getNode(A);
-                y1 = graph.getNode(B);
-                System.out.println("Adding pair to simList = " + x1 + " and " + y1);
-                simListX.add(x1);
-                simListY.add(y1);
-            }
-        }
-
-        List<List<Node>> pairList = new ArrayList<>();
-        pairList.add(simListX);
-        pairList.add(simListY);
-        return (pairList);
-    }
-
-    public String getNameNoLag(Object obj) {
-        String tempS = obj.toString();
-        if (tempS.indexOf(':') == -1) {
-            return tempS;
-        } else return tempS.substring(0, tempS.indexOf(':'));
-    }
-
-    public IKnowledge getKnowledge(Graph graph) {
-//        System.out.println("Entering getKnowledge ... ");
-        int numLags; // need to fix this!
-        List<Node> variables = graph.getNodes();
-        List<Integer> laglist = new ArrayList<>();
-        IKnowledge knowledge = new Knowledge2();
-        int lag;
-        for (Node node : variables) {
-            String varName = node.getName();
-            String tmp;
-            if (varName.indexOf(':') == -1) {
-                lag = 0;
-                laglist.add(lag);
-            } else {
-                tmp = varName.substring(varName.indexOf(':') + 1, varName.length());
-                lag = Integer.parseInt(tmp);
-                laglist.add(lag);
-            }
-        }
-        numLags = Collections.max(laglist);
-
-//        System.out.println("Variable list before the sort = " + variables);
-        Collections.sort(variables, new Comparator<Node>() {
-            @Override
-            public int compare(Node o1, Node o2) {
-                String name1 = getNameNoLag(o1);
-                String name2 = getNameNoLag(o2);
-
-//                System.out.println("name 1 = " + name1);
-//                System.out.println("name 2 = " + name2);
-
-                String prefix1 = getPrefix(name1);
-                String prefix2 = getPrefix(name2);
-
-//                System.out.println("prefix 1 = " + prefix1);
-//                System.out.println("prefix 2 = " + prefix2);
-
-                int index1 = getIndex(name1);
-                int index2 = getIndex(name2);
-
-//                System.out.println("index 1 = " + index1);
-//                System.out.println("index 2 = " + index2);
-
-                if (getLag(o1.getName()) == getLag(o2.getName())) {
-                    if (prefix1.compareTo(prefix2) == 0) {
-                        return Integer.compare(index1, index2);
-                    } else {
-                        return prefix1.compareTo(prefix2);
-                    }
-                } else {
-                    return getLag(o1.getName()) - getLag(o2.getName());
-                }
-            }
-        });
-
-//        System.out.println("Variable list after the sort = " + variables);
-
-        for (Node node : variables) {
-            String varName = node.getName();
-            String tmp;
-            if (varName.indexOf(':') == -1) {
-                lag = 0;
-//                laglist.add(lag);
-            } else {
-                tmp = varName.substring(varName.indexOf(':') + 1, varName.length());
-                lag = Integer.parseInt(tmp);
-//                laglist.add(lag);
-            }
-            knowledge.addToTier(numLags - lag, node.getName());
-        }
-
-        //System.out.println("Knowledge in graph = " + knowledge);
-        return knowledge;
-    }
-
-    public static String getPrefix(String s) {
-//        int y = 0;
-//        for (int i = s.length() - 1; i >= 0; i--) {
-//            try {
-//                y = Integer.parseInt(s.substring(i));
-//            } catch (NumberFormatException e) {
-//                return s.substring(0, y);
-//            }
-//        }
-//
-//        throw new IllegalArgumentException("Not character prefix.");
-
-//        if(s.indexOf(':')== -1) return s;
-//        String tmp = s.substring(0,s.indexOf(':')-1);
-//        return tmp;
-        return s.substring(0, 1);
-    }
-
-    public static int getIndex(String s) {
-        int y = 0;
-        for (int i = s.length() - 1; i >= 0; i--) {
-            try {
-                y = Integer.parseInt(s.substring(i));
-            } catch (NumberFormatException e) {
-                return y;
-            }
-        }
-        throw new IllegalArgumentException("Not integer suffix.");
-    }
-
-    public static int getLag(String s) {
-        if (s.indexOf(':') == -1) return 0;
-        String tmp = s.substring(s.indexOf(':') + 1, s.length());
-        return (Integer.parseInt(tmp));
-    }
-
-    public double[][] getUncorrelatedGaussianShocks(int sampleSize) {
-        NormalDistribution normal = new NormalDistribution(new Well1024a(++seed), 0, 1);
-
-        int numVars = variableNodes.size();
-        setupModel(numVars);
-
-        double[][] shocks = new double[sampleSize][numVars];
-
-        for (int i = 0; i < sampleSize; i++) {
-            for (int j = 0; j < numVars; j++) {
-                shocks[i][j] = normal.sample() * sqrt(errorVars[j]);
-            }
-        }
-
-        return shocks;
-    }
-
-    public double[][] getUncorrelatedShocks(int sampleSize) {
-        AbstractRealDistribution distribution;
-
-        if (errorsNormal) {
-            distribution = new NormalDistribution(new Well1024a(++seed), 0, 1);
-        } else {
-            distribution = new BetaDistribution(new Well1024a(++seed), getBetaLeftValue(), getBetaRightValue());
-//            distribution = new UniformRealDistribution(0, 1);
-        }
-
-//        TDistribution dist = new TDistribution(new Well1024a(++seed), 6);
-//        BetaDistribution dist = new BetaDistribution(new Well1024a(++seed), 2, 5);
-//        NormalDistribution dist = new NormalDistribution(new Well1024a(++seed), 0, 1);
-//        UniformRealDistribution dist = new UniformRealDistribution(0, 1);
-
-        int numVars = variableNodes.size();
-        setupModel(numVars);
-
-        double[][] shocks = new double[sampleSize][numVars];
-
-        for (int j = 0; j < numVars; j++) {
-            for (int i = 0; i < sampleSize; i++) {
-                double sample = distribution.sample();
-
-//                if (!errorsNormal) {
-//                    sample = Math.pow(sample, 3);
-//                }
-
-//                if (!errorsNormal && !errorsPositivelySkewedIfNonNormal) {
-//                    sample *= -1.0;
-//                }
-
-//                if (RandomUtil.getInstance().nextDouble() > 0.9) {
-//                    sample *= -1.0;
-//                }
-
-                shocks[i][j] = sample;
-            }
-        }
-
-        return shocks;
-    }
-
-    public double[][] getSoCalledPoissonShocks(int sampleSize) {
-        int numVars = variableNodes.size();
-        setupModel(numVars);
-
-        double[][] shocks = new double[sampleSize][numVars];
-
-        for (int j = 0; j < numVars; j++) {
-            int v = 0;
-
-            for (int i = 0; i < sampleSize; i++) {
-                if (RandomUtil.getInstance().nextDouble() < 0.3) {
-                    v = 1 - v;
-                }
-
-                shocks[i][j] = v + RandomUtil.getInstance().nextNormal(0, 0.1);
-            }
-        }
-
-        return shocks;
-    }
-
-    public void setIncludePositiveCoefs(boolean includePositiveCoefs) {
-        this.includePositiveCoefs = includePositiveCoefs;
-    }
-
-    public void setIncludeNegativeCoefs(boolean includeNegativeCoefs) {
-        this.includeNegativeCoefs = includeNegativeCoefs;
-    }
-
-    public boolean isErrorsNormal() {
-        return errorsNormal;
-    }
-
-    public void setErrorsNormal(boolean errorsNormal) {
-        this.errorsNormal = errorsNormal;
-    }
-
-//    public boolean isErrorsPositivelySkewedIfNonNormal() {
-//        return errorsPositivelySkewedIfNonNormal;
-//    }
-//
-//    public void setErrorsPositivelySkewedIfNonNormal(boolean errorsPositivelySkewedIfNonNormal) {
-//        this.errorsPositivelySkewedIfNonNormal = errorsPositivelySkewedIfNonNormal;
-//    }
-
-    public double getBetaRightValue() {
-        return betaRightValue;
-    }
-
-    public void setBetaRightValue(double betaRightValue) {
-        this.betaRightValue = betaRightValue;
-    }
-
-    public double getBetaLeftValue() {
-        return betaLeftValue;
-    }
-
-    public void setBetaLeftValue(double betaLeftValue) {
-        this.betaLeftValue = betaLeftValue;
-    }
-}
-
-
-
-
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/SemUpdater.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/SemUpdater.java
index faeea1f9..996a221c 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/SemUpdater.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/sem/SemUpdater.java
@@ -18,6 +18,7 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetrad.sem;
 
 import cern.colt.matrix.DoubleMatrix1D;
@@ -33,6 +34,7 @@ import edu.cmu.tetrad.graph.SemGraph;
 import edu.cmu.tetrad.util.TetradMatrix;
 import edu.cmu.tetrad.util.TetradSerializable;
 import edu.cmu.tetrad.util.TetradVector;
+
 import java.util.List;
 
 /**
@@ -48,7 +50,6 @@ import java.util.List;
  * @see edu.cmu.tetrad.bayes.Manipulation
  */
 public class SemUpdater implements TetradSerializable {
-
     static final long serialVersionUID = 23L;
     private SemEvidence evidence;
     private SemIm semIm;
@@ -59,6 +60,7 @@ public class SemUpdater implements TetradSerializable {
         }
 
         setEvidence(new SemEvidence(semIm));
+        this.semIm = semIm;
     }
 
     /**
@@ -82,7 +84,6 @@ public class SemUpdater implements TetradSerializable {
         }
 
         this.evidence = evidence;
-        this.semIm = evidence.getSemIm();
     }
 
     /**
@@ -142,6 +143,7 @@ public class SemUpdater implements TetradSerializable {
 //                x1[++index] = i;
 //            }
 //        }
+
         // Calculate sigmaBar. (Don't know how to use it yet.)
 //        DoubleMatrix2D sigma11 = sigma.viewSelection(x1, x1);
         DoubleMatrix2D sigma12 = sigma.viewSelection(x1, x2);
@@ -166,6 +168,7 @@ public class SemUpdater implements TetradSerializable {
 //        for (int i = 0; i < variableNodes.size(); i++) {
 //            varNames[i] = ((Node) variableNodes.get(i)).getNode();
 //        }
+
 //        System.out.println(sigmaBar);
 //
 //        CovarianceMatrix covMatrix = new CovarianceMatrix(varNames,
@@ -176,6 +179,7 @@ public class SemUpdater implements TetradSerializable {
 //        SemIm semIm = estimator.getEstimatedSem();
 //        semIm.setMeanValues(muBar.toArray());
 //        return semIm;
+
         DoubleMatrix2D sigma2 = new DenseDoubleMatrix2D(manipulatedSemIm.getErrCovar().toArray());
 
 //        for (int aX2 : x2) {
@@ -190,6 +194,7 @@ public class SemUpdater implements TetradSerializable {
 //                sigma2.set(aX2, i, 0.d);
 //            }
 //        }
+
         return manipulatedSemIm.updatedIm(new TetradMatrix(sigma2.toArray()), new TetradVector(muBar.toArray()));
     }
 
@@ -204,7 +209,8 @@ public class SemUpdater implements TetradSerializable {
     }
 
     /**
-     * Alters the graph by removing edges from parents to manipulated variables.
+     * Alters the graph by removing edges from parents to manipulated
+     * variables.
      */
     private SemGraph createManipulatedGraph(Graph graph) {
         SemGraph updatedGraph = new SemGraph(graph);
@@ -227,3 +233,8 @@ public class SemUpdater implements TetradSerializable {
         return updatedGraph;
     }
 }
+
+
+
+
+
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/study/Conditions/Condition2.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/study/Conditions/Condition2.java
index eedaaf33..dd1c6b54 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/study/Conditions/Condition2.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/study/Conditions/Condition2.java
@@ -24,6 +24,10 @@ package edu.cmu.tetrad.study.Conditions;
 import edu.cmu.tetrad.algcomparison.Comparison;
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
 import edu.cmu.tetrad.algcomparison.algorithm.external.*;
+import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.*;
+import edu.cmu.tetrad.algcomparison.independence.FisherZ;
+import edu.cmu.tetrad.algcomparison.score.FisherZScore;
+import edu.cmu.tetrad.algcomparison.score.SemBicScore;
 import edu.cmu.tetrad.algcomparison.statistic.*;
 import edu.cmu.tetrad.util.Parameters;
 
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/study/ExampleCompareFromFiles.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/study/ExampleCompareFromFiles.java
index b10adf5e..8f336a85 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/study/ExampleCompareFromFiles.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/study/ExampleCompareFromFiles.java
@@ -23,7 +23,10 @@ package edu.cmu.tetrad.study;
 
 import edu.cmu.tetrad.algcomparison.Comparison;
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
+import edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Fci;
 import edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Gfci;
+import edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Rfci;
+import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.*;
 import edu.cmu.tetrad.algcomparison.independence.FisherZ;
 import edu.cmu.tetrad.algcomparison.score.SemBicScore;
 import edu.cmu.tetrad.algcomparison.statistic.*;
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/util/AlgorithmDescriptions.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/util/AlgorithmDescriptions.java
deleted file mode 100644
index 5f6862bf..00000000
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/util/AlgorithmDescriptions.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * To change this license header, choose License Headers in Project Properties.
- * To change this template file, choose Tools | Templates
- * and open the template in the editor.
- */
-package edu.cmu.tetrad.util;
-
-
-import edu.cmu.tetrad.annotation.Algorithm;
-import edu.cmu.tetrad.annotation.AlgorithmAnnotations;
-import edu.cmu.tetrad.annotation.AnnotatedClass;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import org.jsoup.Connection;
-import org.jsoup.Jsoup;
-import org.jsoup.nodes.Document;
-import org.jsoup.nodes.Element;
-import org.jsoup.select.Elements;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- *
- * @author Zhou Yuan <zhy19@pitt.edu>
- */
-public class AlgorithmDescriptions {
-    
-    private static final Logger LOGGER = LoggerFactory.getLogger(AlgorithmDescriptions.class);
-    
-    private static final AlgorithmDescriptions INSTANCE = new AlgorithmDescriptions();
-
-    private final Map<String, String> algoDescMap = new HashMap<>();
-    
-    private AlgorithmDescriptions() {
-        List<AnnotatedClass<Algorithm>> annotatedClasses = AlgorithmAnnotations.getInstance().getAnnotatedClasses();
-        
-        // Get the html manual URL and file path from properties file
-        final Properties applicationProperties = new Properties();
-
-        try (InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("tetrad-lib.properties")) {
-            if (inputStream != null) {
-                applicationProperties.load(inputStream);
-            }
-        } catch (IOException exception) {
-            LOGGER.error("Could not read tetrad-lib.properties file", exception);
-        }
-
-        String manualUrl = applicationProperties.getProperty("manual.html.url");
-
-        Connection conn = Jsoup.connect(manualUrl);
-  
-        Document doc = null;
-        
-        // Always try to get the latest manual via URL, if failed, try read the local HTML file        
-        if (conn != null) {
-            try {
-                doc = conn.get();
-            } catch (IOException ex) {
-                LOGGER.error("Failed to fetch tetrad HTML manual via Github Pages URL.", ex);
-            }
-        } else {
-            // Read the copied maunal/index.html from within the jar
-            try (InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("manual/index.html")) {
-                if (inputStream != null) {
-                    doc = Jsoup.parse(inputStream, "UTF-8", "");
-                }
-            } catch (IOException ex) {
-                LOGGER.error("Failed to read tetrad HTML manual 'maunal/index.html' file from within the jar.", ex);
-            }
-        }
-
-        // Get the description of each algorithm, use empty string if not found
-        for (AnnotatedClass<Algorithm> clazz: annotatedClasses) {
-            String algoShortName = clazz.getAnnotation().command();
-            String desc = "";
-
-            if (doc != null) {
-                Element algoDescription = doc.getElementById(algoShortName);
-                if (algoDescription != null) {
-                    Elements paragraphs = algoDescription.children();
-                    desc = paragraphs.stream().map((p) -> p.text() + "\n\n").reduce(desc, String::concat);
-                }
-            }
-            
-            algoDescMap.put(algoShortName, desc);
-        }
-    }
-    
-    public static AlgorithmDescriptions getInstance() {
-        return INSTANCE;
-    }
-
-    public String get(String algoShortName) {
-        String algoDesc = algoDescMap.get(algoShortName);
-
-        return (algoDesc == null)
-                ? String.format("Please add algorithm description for %s.", algoShortName)
-                : algoDesc;
-    }
-}
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/util/MatrixUtils.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/util/MatrixUtils.java
index cec8756c..e36f49ed 100755
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/util/MatrixUtils.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/util/MatrixUtils.java
@@ -18,25 +18,23 @@
 // along with this program; if not, write to the Free Software               //
 // Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
 ///////////////////////////////////////////////////////////////////////////////
+
 package edu.cmu.tetrad.util;
 
+import cern.colt.matrix.DoubleMatrix2D;
 import cern.colt.matrix.impl.DenseDoubleMatrix1D;
 import cern.colt.matrix.impl.DenseDoubleMatrix2D;
 import cern.colt.matrix.linalg.CholeskyDecomposition;
 import cern.colt.matrix.linalg.Property;
+import org.apache.commons.math3.exception.NotStrictlyPositiveException;
+import org.apache.commons.math3.exception.OutOfRangeException;
+import org.apache.commons.math3.linear.*;
+
 import java.text.DecimalFormat;
 import java.text.NumberFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import org.apache.commons.math3.exception.NotStrictlyPositiveException;
-import org.apache.commons.math3.exception.OutOfRangeException;
-import org.apache.commons.math3.linear.AbstractRealMatrix;
-import org.apache.commons.math3.linear.BlockRealMatrix;
-import org.apache.commons.math3.linear.NonPositiveDefiniteMatrixException;
-import org.apache.commons.math3.linear.RealMatrix;
-import org.apache.commons.math3.linear.RectangularCholeskyDecomposition;
-import org.apache.commons.math3.linear.SingularValueDecomposition;
 
 /**
  * Class Matrix includes several public static functions performing matrix
@@ -46,85 +44,11 @@ import org.apache.commons.math3.linear.SingularValueDecomposition;
  *
  * @author Tianjiao Chu
  * @author Joseph Ramsey
- * @author Kevin V. Bui
  */
 public final class MatrixUtils {
 
-    /**
-     * Make a repeat copy of matrix mat.
-     *
-     * @param mat matrix to copy
-     * @param nRow number of repeat copy of row
-     * @param mColumn number of repeat copy of column
-     * @return
-     */
-    public static double[][] repmat(double[][] mat, int nRow, int mColumn) {
-        int numOfRow = mat.length;
-        double[][] repMat = new double[numOfRow * nRow][];
-        for (int row = 0; row < numOfRow; row++) {
-            repMat[row] = repeatCopyVector(mat[row], mColumn);
-        }
-
-        repeatCopyRow(repMat, --nRow, numOfRow, numOfRow);
-
-        return repMat;
-    }
-
-    /**
-     * Make a n repeat copy of the rows and columns of the matrix mat.
-     *
-     * @param mat
-     * @param n number of repeat copy
-     * @return
-     */
-    public static double[][] repmat(double[][] mat, int n) {
-        int numOfRow = mat.length;
-        double[][] repMat = new double[numOfRow * n][];
-        for (int row = 0; row < numOfRow; row++) {
-            repMat[row] = repeatCopyVector(mat[row], n);
-        }
-
-        repeatCopyRow(repMat, --n, numOfRow, numOfRow);
-        return repMat;
-    }
-
-    /**
-     * Repeat copy of rows.
-     *
-     * @param mat matrix
-     * @param n number of repeat copy
-     * @param startRowPos starting row
-     * @param numOfRow number of rows to copy nth times
-     */
-    private static void repeatCopyRow(double[][] mat, int n, int startRowPos, int numOfRow) {
-        for (int i = 0; i < n; i++) {
-            for (int row = 0; row < numOfRow; row++) {
-                double[] src = mat[row];
-                double[] dest = new double[src.length];
-                System.arraycopy(src, 0, dest, 0, src.length);
-
-                mat[startRowPos++] = dest;
-            }
-        }
-    }
-
-    /**
-     * Repeat copy of a vector.
-     *
-     * @param src vector
-     * @param n number of repeat copy
-     * @return a new vector of n copy of the vector
-     */
-    private static double[] repeatCopyVector(double[] src, int n) {
-        double[] dest = new double[src.length * n];
-        for (int i = 0; i < n; i++) {
-            System.arraycopy(src, 0, dest, i * src.length, src.length);
-        }
-
-        return dest;
-    }
-
     //=========================PUBLIC METHODS===========================//
+
     /**
      * Tests two matrices for equality.
      *
@@ -133,15 +57,11 @@ public final class MatrixUtils {
      * @return True iff the first and second matrices are equal.
      */
     public static boolean equals(double[][] ma, double[][] mb) {
-        if (ma.length != mb.length) {
-            return false;
-        }
+        if (ma.length != mb.length) return false;
         for (int i = 0; i < ma.length; i++) {
             double[] _ma = ma[i];
             double[] _mb = mb[i];
-            if (!Arrays.equals(_ma, _mb)) {
-                return false;
-            }
+            if (!Arrays.equals(_ma, _mb)) return false;
         }
 
         return true;
@@ -163,13 +83,13 @@ public final class MatrixUtils {
      * If any two corresponding elements differ by more than the given
      * tolerance, false is returned.
      *
-     * @param ma The first 2D matrix to check.
-     * @param mb The second 2D matrix to check.
+     * @param ma        The first 2D matrix to check.
+     * @param mb        The second 2D matrix to check.
      * @param tolerance A double >= 0.
      * @return Ibid.
      */
     public static boolean equals(double[][] ma, double[][] mb,
-            double tolerance) {
+                                 double tolerance) {
         return new TetradMatrix(ma).equals(new TetradMatrix(mb), tolerance);
         //new Property(tolerance).equals(TetradMatrix.instance(ma),
         //     TetradMatrix.instance(mb));
@@ -180,8 +100,8 @@ public final class MatrixUtils {
      * any two corresponding elements differ by more than the given tolerance,
      * false is returned.
      *
-     * @param va The first matrix to check.
-     * @param vb The second matrix to check.
+     * @param va        The first matrix to check.
+     * @param vb        The second matrix to check.
      * @param tolerance A double >= 0.
      * @return Ibid.
      */
@@ -200,7 +120,7 @@ public final class MatrixUtils {
     }
 
     /**
-     * @param m The matrix to check.
+     * @param m         The matrix to check.
      * @param tolerance A double >= 0.
      * @return Ibid.
      */
@@ -437,27 +357,27 @@ public final class MatrixUtils {
 
     /**
      * @param edgeCoef The edge covariance matrix. edgeCoef(i, j) is a parameter
-     * in this matrix just in case i-->j is an edge in the model. All other
-     * entries in the matrix are zero.
+     *                 in this matrix just in case i-->j is an edge in the model. All other
+     *                 entries in the matrix are zero.
      * @param errCovar The error covariance matrix. errCovar(i, i) is the
-     * variance of i; off-diagonal errCovar(i, j) are covariance parameters that
-     * are specified in the model. All other matrix entries are zero.
+     *                 variance of i; off-diagonal errCovar(i, j) are covariance parameters
+     *                 that are specified in the model. All other matrix entries are zero.
      * @return The implied covariance matrix, which is the covariance matrix
      * over the measured variables that is implied by all the given information.
      * @throws IllegalArgumentException if edgeCoef or errCovar contains an
-     * undefined value (Double.NaN).
+     *                                  undefined value (Double.NaN).
      */
     public static TetradMatrix impliedCovar2(TetradMatrix edgeCoef, TetradMatrix errCovar) {
         if (containsNaN(edgeCoef)) {
-            throw new IllegalArgumentException("Edge coefficient matrix must not "
-                    + "contain undefined values. Probably the search put them "
-                    + "there.");
+            throw new IllegalArgumentException("Edge coefficient matrix must not " +
+                    "contain undefined values. Probably the search put them " +
+                    "there.");
         }
 
         if (containsNaN(errCovar)) {
-            throw new IllegalArgumentException("Error covariance matrix must not "
-                    + "contain undefined values. Probably the search put them "
-                    + "there.");
+            throw new IllegalArgumentException("Error covariance matrix must not " +
+                    "contain undefined values. Probably the search put them " +
+                    "there.");
         }
 
         int sampleSize = 10000;
@@ -481,20 +401,24 @@ public final class MatrixUtils {
     public static TetradMatrix impliedCovar(TetradMatrix edgeCoef, TetradMatrix errCovar) {
         if (containsNaN(edgeCoef)) {
             System.out.println(edgeCoef);
-            throw new IllegalArgumentException("Edge coefficient matrix must not "
-                    + "contain undefined values. Probably the search put them "
-                    + "there.");
+            throw new IllegalArgumentException("Edge coefficient matrix must not " +
+                    "contain undefined values. Probably the search put them " +
+                    "there.");
         }
 
         if (containsNaN(errCovar)) {
-            throw new IllegalArgumentException("Error covariance matrix must not "
-                    + "contain undefined values. Probably the search put them "
-                    + "there.");
+            throw new IllegalArgumentException("Error covariance matrix must not " +
+                    "contain undefined values. Probably the search put them " +
+                    "there.");
         }
 
 //        TetradMatrix g = TetradMatrix.identity(edgeCoef.rows()).minus(edgeCoef);
+
 //        return g.times(errCovar).times(g.transpose());
 //        return g.transpose().times(errCovar).times(g);
+
+
+
         // I - B
         TetradMatrix m1 = TetradMatrix.identity(edgeCoef.rows()).minus(edgeCoef);
 //
@@ -676,8 +600,8 @@ public final class MatrixUtils {
     }
 
     /**
-     * Converts a covariance matrix to a correlation matrix in place; the same
-     * matrix is returned for convenience, but m is modified in the process.
+     * Converts a covariance matrix to a correlation matrix in place; the same matrix
+     * is returned for convenience, but m is modified in the process.
      */
     public static TetradMatrix convertCovToCorr(TetradMatrix m) {
         for (int i = 0; i < m.rows(); i++) {
@@ -761,7 +685,7 @@ public final class MatrixUtils {
         return toString(m, nf, variables);
     }
 
-    public static String toString(double[][] m, NumberFormat nf) {
+    private static String toString(double[][] m, NumberFormat nf) {
         return toString(m, nf, null);
     }
 
@@ -921,6 +845,7 @@ public final class MatrixUtils {
         return result;
     }
 
+
     public static String toString(double[] m) {
         StringBuilder buf = new StringBuilder();
 
@@ -943,7 +868,6 @@ public final class MatrixUtils {
 
     public static String toString(int[][] m) {
         TextTable textTable = new TextTable(m.length, m[0].length);
-        textTable.setTabDelimited(true);
 
         for (int i = 0; i < m.length; i++) {
             for (int j = 0; j < m[0].length; j++) {
@@ -977,16 +901,18 @@ public final class MatrixUtils {
     }
 
     //=========================PRIVATE METHODS===========================//
+
     private static String nullMessage() {
-        return "\n"
-                + "\t"
-                + "<Matrix is null>";
+        return "\n" +
+                "\t" +
+                "<Matrix is null>";
     }
 
     /**
      * @return the order of the matrix for which this is the vech.
      * @throws IllegalArgumentException in case this matrix does not have
-     * dimension n x 1 for some n = 0 + 1 + 2 + ... + k for some k.
+     *                                  dimension n x 1 for some n = 0 + 1 + 2 +
+     *                                  ... + k for some k.
      */
     private static int vechOrder(double[] vech) {
         int difference = vech.length;
@@ -1001,6 +927,7 @@ public final class MatrixUtils {
         return order;
     }
 
+
     public static int[] copyOf(int[] arr, int length) {
         int[] copy = new int[arr.length];
         System.arraycopy(arr, 0, copy, 0, length);
@@ -1052,3 +979,8 @@ public final class MatrixUtils {
         };
     }
 }
+
+
+
+
+
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/util/ParamDescriptions.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/util/ParamDescriptions.java
index 250eb264..f065faac 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/util/ParamDescriptions.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/util/ParamDescriptions.java
@@ -34,11 +34,11 @@ public class ParamDescriptions {
         map.put("standardize", new ParamDescription("Yes if the data should be standardized", false));
 
         map.put("measurementVariance", new ParamDescription("Additive measurement noise variance (min = 0.0)", 0.0, 0, Double.MAX_VALUE));
-        map.put("depth", new ParamDescription("Maximum size of conditioning set (unlimited = -1)", -1, -1, Integer.MAX_VALUE));
+        map.put("depth", new ParamDescription("Maximum size of conditioning set (min = -1)", -1, -1, Integer.MAX_VALUE));
         map.put("meanLow", new ParamDescription("Low end of mean range (min = 0.0)", 0.5, 0.0, Double.MAX_VALUE));
         map.put("meanHigh", new ParamDescription("High end of mean range (min = 0.0)", 1.5, 0.0, Double.MAX_VALUE));
-        map.put("coefLow", new ParamDescription("Low end of coefficient range (min = 0.0)", 0.2, 0.0, Double.MAX_VALUE));
-        map.put("coefHigh", new ParamDescription("High end of coefficient range (min = 0.0)", 0.7, 0.0, Double.MAX_VALUE));
+        map.put("coefLow", new ParamDescription("Low end of coefficient range (min = 0.0)", 0.5, 0.0, Double.MAX_VALUE));
+        map.put("coefHigh", new ParamDescription("High end of coefficient range (min = 0.0)", 1.5, 0.0, Double.MAX_VALUE));
         map.put("covLow", new ParamDescription("Low end of covariance range (min = 0.0)", 0.5, 0.0, Double.MAX_VALUE));
         map.put("covHigh", new ParamDescription("High end of covariance range (min = 0.0)", 1.5, 0.0, Double.MAX_VALUE));
         map.put("varLow", new ParamDescription("Low end of variance range (min = 0.0)", 1.0, 0.0, Double.MAX_VALUE));
@@ -259,13 +259,10 @@ public class ParamDescriptions {
                 1, 1, Double.POSITIVE_INFINITY));
 
         map.put("saveLatentVars", new ParamDescription("Save latent variables.", false));
-
+        
         map.put("probTwoCycle", new ParamDescription(
-                "The probability of creating a 2-cycles in the graph (0 - 1)",
-                0.0, 0.0, 1.0));
-
-        map.put("fdrQ", new ParamDescription("Q values for an FDR test", 0.2, 0.0, 1.0));
-
+            "The probability of creating a 2-cycles in the graph (0 - 1)",
+            0.0, 0.0, 1.0));
     }
 
     public static ParamDescriptions getInstance() {
diff --git a/tetrad-lib/src/main/java/edu/cmu/tetrad/util/StatUtils.java b/tetrad-lib/src/main/java/edu/cmu/tetrad/util/StatUtils.java
index ae9b5d01..cdf0bf17 100644
--- a/tetrad-lib/src/main/java/edu/cmu/tetrad/util/StatUtils.java
+++ b/tetrad-lib/src/main/java/edu/cmu/tetrad/util/StatUtils.java
@@ -2052,51 +2052,6 @@ public final class StatUtils {
         return new double[]{sxy, sxy / sqrt(sx * sy), sx, sy, (double) n, ex, ey, sxy / sx};
     }
 
-    public static double[]  ucov(double[] x, double[] y, double[] condition, double threshold, double direction) {
-        double exy = 0.0;
-        double exx = 0.0;
-        double eyy = 0.0;
-
-        double ex = 0.0;
-        double ey = 0.0;
-
-        int n = 0;
-
-        for (int k = 0; k < x.length; k++) {
-            if (direction > threshold) {
-                if (condition[k] > threshold) {
-                    exy += x[k] * y[k];
-                    exx += x[k] * x[k];
-                    eyy += y[k] * y[k];
-                    ex += x[k];
-                    ey += y[k];
-                    n++;
-                }
-            } else if (direction < threshold) {
-                if (condition[k] > threshold) {
-                    exy += x[k] * y[k];
-                    exx += x[k] * x[k];
-                    eyy += y[k] * y[k];
-                    ex += x[k];
-                    ey += y[k];
-                    n++;
-                }
-            }
-        }
-
-        exy /= n;
-        exx /= n;
-        eyy /= n;
-        ex /= n;
-        ey /= n;
-
-        double sxy = exy;
-        double sx = exx;
-        double sy = eyy;
-
-        return new double[]{sxy, sxy / sqrt(sx * sy), sx, sy, (double) n, ex, ey, sxy / sx};
-    }
-
     public static double[][] covMatrix(double[] x, double[] y, double[][] z, double[] condition, double threshold, double direction) {
         List<Integer> rows = getRows(x, condition, threshold, direction);
 
diff --git a/tetrad-lib/src/main/resources/tetrad-lib.properties b/tetrad-lib/src/main/resources/tetrad-lib.properties
index 23d4ee1e..2c7dbd95 100644
--- a/tetrad-lib/src/main/resources/tetrad-lib.properties
+++ b/tetrad-lib/src/main/resources/tetrad-lib.properties
@@ -1,6 +1,4 @@
-latest.version.url=https://cloud.ccd.pitt.edu
-
-manual.html.url=http://cmu-phil.github.io/tetrad/manual/index.html
+latest.version.url=https://ccd3.vm.bridges.psc.edu
 
 datatype.continuous.test.default=edu.cmu.tetrad.algcomparison.independence.FisherZ
 datatype.discrete.test.default=edu.cmu.tetrad.algcomparison.independence.ChiSquare
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/FaskGraphs.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/FaskGraphs.java
index 93baf54b..e72c471d 100644
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/FaskGraphs.java
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/FaskGraphs.java
@@ -1,8 +1,6 @@
 package edu.cmu.tetrad.test;
 
 import edu.cmu.tetrad.algcomparison.algorithm.multi.Fask;
-import edu.cmu.tetrad.algcomparison.score.SemBicScore;
-import edu.cmu.tetrad.data.CovarianceMatrixOnTheFly;
 import edu.cmu.tetrad.data.DataReader;
 import edu.cmu.tetrad.data.DataSet;
 import edu.cmu.tetrad.data.DelimiterType;
@@ -115,8 +113,7 @@ public class FaskGraphs {
                         DataSet dataSet = reader.parseTabular(new File(path, name));
                         filenames.add(name);
                         datasets.add(dataSet);
-
-                        Fask fask = new Fask(new SemBicScore());
+                        Fask fask = new Fask();
                         Graph search = fask.search(dataSet, parameters);
                         graphs.add(search);
                     } else if (name.contains("typical")) {
@@ -124,7 +121,7 @@ public class FaskGraphs {
                         DataSet dataSet = reader.parseTabular(new File(path, name));
                         filenames.add(name);
                         datasets.add(dataSet);
-                        Fask fask = new Fask(new SemBicScore());
+                        Fask fask = new Fask();
                         Graph search = fask.search(dataSet, parameters);
                         graphs.add(search);
                     }
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/LoadContinuousDataPwdd7.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/LoadContinuousDataPwdd7.java
deleted file mode 100644
index 557ca288..00000000
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/LoadContinuousDataPwdd7.java
+++ /dev/null
@@ -1,185 +0,0 @@
-package edu.cmu.tetrad.test;
-
-import edu.cmu.tetrad.algcomparison.simulation.Simulation;
-import edu.cmu.tetrad.algcomparison.utils.HasParameterValues;
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.EdgeListGraph;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.graph.GraphUtils;
-import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.util.Parameters;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * @author jdramsey
- */
-public class LoadContinuousDataPwdd7 implements Simulation, HasParameterValues {
-    static final long serialVersionUID = 23L;
-    private final int index;
-    private final String prefix;
-    private String path;
-    private Graph graph = null;
-    private List<DataSet> dataSets = new ArrayList<>();
-    private List<String> usedParameters = new ArrayList<>();
-    private Parameters parametersValues = new Parameters();
-
-    public LoadContinuousDataPwdd7(String path, int index, String prefix) {
-        this.path = path;
-        this.index = index;
-        this.prefix = prefix;
-        String structure = new File(path).getName();
-        parametersValues.set("Structure", structure + " " + index);
-    }
-
-    @Override
-    public void createData(Parameters parameters) {
-        this.dataSets = new ArrayList<>();
-
-        File dir2 = new File(path + "/models");
-
-        if (dir2.exists()) {
-            File[] files = dir2.listFiles();
-
-            for (File file : files) {
-                if (!file.getName().endsWith(".txt")) continue;
-                if (!file.getName().contains("sim" + index + ".")) continue;
-
-                System.out.println("Loading graph from " + file.getAbsolutePath());
-                this.graph = readGraph(file);
-//            this.graph = GraphUtils.loadGraphTxt(file);
-
-//            if (!graph.isAdjacentTo(graph.getNode("X3"), graph.getNode("X4"))) {
-//                graph.addUndirectedEdge(graph.getNode("X3"), graph.getNode("X4"));
-//            }
-
-                GraphUtils.circleLayout(this.graph, 225, 200, 150);
-
-                break;
-            }
-        }
-
-        File dir = new File(path + "/data");
-
-        if (dir.exists()) {
-            File[] dirs = dir.listFiles();
-
-            for (File _dir : dirs) {
-                if (_dir.getName().startsWith(".DS")) continue;
-                if (!_dir.getName().equals("50_simulation_" + index)) continue;
-
-                File[] files = _dir.listFiles();
-
-                for (File file : files) {
-                    if (!file.getName().endsWith(".txt")) continue;
-                    if (!file.getName().startsWith(prefix + "_")) continue;
-                    System.out.println("Loading data from " + file.getAbsolutePath());
-
-                    try {
-                        DataReader reader = new DataReader();
-                        reader.setVariablesSupplied(false);
-                        reader.setDelimiter(DelimiterType.WHITESPACE);
-                        DataSet dataSet = reader.parseTabular(file);
-
-                        if (dataSet.getVariables().size() > graph.getNumNodes()) {
-                            List<Node> nodes = new ArrayList<>();
-                            for (int i = 0; i < graph.getNumNodes(); i++) nodes.add(dataSet.getVariable(i));
-                            dataSet = dataSet.subsetColumns(nodes);
-                        }
-
-                        dataSets.add(dataSet);
-                    } catch (Exception e) {
-                        System.out.println("Couldn't parse " + file.getAbsolutePath());
-                        e.printStackTrace();
-                    }
-                }
-            }
-        }
-
-
-
-        if (parameters.get("numRuns") != null) {
-            parameters.set("numRuns", parameters.get("numRuns"));
-        } else {
-            parameters.set("numRuns", dataSets.size());
-        }
-
-        System.out.println();
-    }
-
-    @Override
-    public Graph getTrueGraph(int index) {
-        return this.graph;
-    }
-
-    @Override
-    public DataModel getDataModel(int index) {
-        return dataSets.get(index);
-    }
-
-    public String getDescription() {
-        try {
-            StringBuilder b = new StringBuilder();
-            b.append("Smith sim " + index).append("\n\n");
-            return b.toString();
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    @Override
-    public List<String> getParameters() {
-        return usedParameters;
-    }
-
-    @Override
-    public int getNumDataModels() {
-        return dataSets.size();
-    }
-
-    @Override
-    public DataType getDataType() {
-        return DataType.Continuous;
-    }
-
-    @Override
-    public Parameters getParameterValues() {
-        return parametersValues;
-    }
-
-
-    public Graph readGraph(File file) {
-        try {
-            DataReader reader = new DataReader();
-            reader.setVariablesSupplied(false);
-            reader.setDelimiter(DelimiterType.COMMA);
-
-            DataSet data = reader.parseTabular(file);
-            List<Node> variables = data.getVariables();
-
-            List<Node> _variables = new ArrayList<>();
-            for (int i = 0; i < variables.size(); i++) {
-                _variables.add(new ContinuousVariable(variables.get(i).getName()));
-            }
-
-            Graph graph = new EdgeListGraph(_variables);
-
-            for (int i = 0; i < _variables.size(); i++) {
-                for (int j = 0; j < _variables.size(); j++) {
-                    if (i == j) continue;
-
-                    if (data.getDouble(i, j) != 0) {
-                        graph.addDirectedEdge(_variables.get(i), _variables.get(j));
-                    }
-                }
-            }
-
-            return graph;
-        } catch (IOException e) {
-            throw new RuntimeException(e);
-        }
-    }
-}
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/SpecialExampleSimulationClark.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/SpecialExampleSimulationClark.java
index d510a17d..4aa7fde0 100644
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/SpecialExampleSimulationClark.java
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/SpecialExampleSimulationClark.java
@@ -4,7 +4,6 @@ import edu.cmu.tetrad.algcomparison.Comparison;
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
 import edu.cmu.tetrad.algcomparison.algorithm.multi.Fask;
 import edu.cmu.tetrad.algcomparison.graph.RandomForward;
-import edu.cmu.tetrad.algcomparison.score.SemBicScore;
 import edu.cmu.tetrad.util.Parameters;
 import edu.cmu.tetrad.algcomparison.simulation.Simulations;
 import edu.cmu.tetrad.algcomparison.statistic.*;
@@ -48,7 +47,7 @@ public class SpecialExampleSimulationClark {
 
         Algorithms algorithms = new Algorithms();
 
-        algorithms.add(new Fask(new SemBicScore()));
+        algorithms.add(new Fask());
 
         Simulations simulations = new Simulations();
 
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestCci.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestCci.java
deleted file mode 100644
index 067491b1..00000000
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestCci.java
+++ /dev/null
@@ -1,1360 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.test;
-
-import edu.cmu.tetrad.algcomparison.algorithm.multi.Fask;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.FAS;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.PcAll;
-import edu.cmu.tetrad.algcomparison.independence.*;
-import edu.cmu.tetrad.algcomparison.score.SemBicScore;
-import edu.cmu.tetrad.algcomparison.statistic.*;
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.*;
-import edu.cmu.tetrad.search.IndTestChiSquare;
-import edu.cmu.tetrad.search.Score;
-import edu.cmu.tetrad.sem.*;
-import edu.cmu.tetrad.util.Parameters;
-import edu.cmu.tetrad.util.RandomUtil;
-import edu.cmu.tetrad.util.StatUtils;
-import edu.cmu.tetrad.util.TetradVector;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import java.io.*;
-import java.text.ParseException;
-import java.util.*;
-
-import static java.util.Collections.sort;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
-
-/**
- * @author Joseph Ramsey
- */
-@Ignore
-public class TestCci {
-
-    private boolean printStuff = false;
-
-    @Test
-    public void test1() {
-
-        String[] linearFunctions = new String[]{
-                "TSUM(NEW(B)*$)"
-        };
-
-        String[] nonlinearFunctions = new String[]{
-//                "abs(TSUM(NEW(B) * $))",
-//                "TSUM(NEW(B) * (abs($) ^ .8))",
-//                "TSUM(NEW(B) * (abs($) ^ 1.05))",
-//                "TSUM(NEW(B) * (abs($) ^ 1.5))",
-                "TSUM(NEW(B)*$) + TSUM(NEW(B) * (abs($) ^ 1.5))",
-                "(TSUM(NEW(B)*$) + TSUM(NEW(B) * ($^2)))",
-//                "TSUM(NEW(B) * ($ ^ 2))",
-                "TSUM(NEW(B) * ($ ^ 3))",
-//                "TSUM(NEW(B) * ln(cosh($)))",
-                "tanh(NEW(B) * (TSUM($)))",
-                "(TSUM(sin(NEW(B) * $)) + TSUM(cos(NEW(B) * $)))"
-        };
-
-        String[] gaussianErrors = new String[]{
-                "Normal(0, 0.3)"
-        };
-
-        String[] nonGaussianErrors = new String[]{
-//                "0.5 * Uniform(-1, 1)",
-                "(U(0, 1)^3 - .5)",
-//                "0.1 * Laplace(0, 1)"
-        };
-
-//        String parameters = "Split(-.6, -.2, .2, .6)";
-        String parameters = "U(.2, .5)";
-
-        int index = 1;
-
-        try {
-            for (String linearFunction : linearFunctions) {
-                for (String nonlinearFunction : nonlinearFunctions) {
-                    for (String gaussianError : gaussianErrors) {
-                        for (String nonGaussianError : nonGaussianErrors) {
-                            final double quantile = 0.33;
-                            final double alpha = 0.01;
-                            final int N = 1000;
-
-                            File dir = new File("/Users/user/Box Sync/data/nonlinearity/simulations8/example" + index++);
-                            dir.mkdirs();
-
-                            PrintStream out = new PrintStream(new File(dir, "description.txt"));
-
-                            out.println("Linear function " + linearFunction);
-                            out.println("Nonlinear function " + nonlinearFunction);
-                            out.println("Gaussian error " + gaussianError);
-                            out.println("Non-Gaussian error " + nonGaussianError);
-                            out.println("Parameters " + parameters);
-                            out.println("Sample size " + N);
-                            out.println("Quantile = " + quantile);
-                            out.println("Alpha = " + alpha);
-
-                            out.println();
-                            out.close();
-
-                            Graph graph = GraphUtils.randomGraph(20, 0, 20, 100, 100, 100, true);
-
-                            GeneralizedSemPm pm1 = getPm(graph, linearFunction, gaussianError, parameters);
-                            GeneralizedSemPm pm2 = getPm(graph, linearFunction, nonGaussianError, parameters);
-                            GeneralizedSemPm pm3 = getPm(graph, nonlinearFunction, gaussianError, parameters);
-                            GeneralizedSemPm pm4 = getPm(graph, nonlinearFunction, nonGaussianError, parameters);
-
-                            GeneralizedSemIm im1 = new GeneralizedSemIm(pm1);
-                            GeneralizedSemIm im2 = new GeneralizedSemIm(pm2);
-                            GeneralizedSemIm im3 = new GeneralizedSemIm(pm3);
-                            GeneralizedSemIm im4 = new GeneralizedSemIm(pm4);
-
-                            DataSet D1 = im1.simulateData(N, false);
-                            DataSet D2 = im2.simulateData(N, false);
-                            DataSet D3 = im3.simulateData(N, false);
-                            DataSet D4 = im4.simulateData(N, false);
-
-//                                D1 = DataUtils.center(D1);
-//                                D2 = DataUtils.center(D2);
-//                                D3 = DataUtils.center(D3);
-//                                D4 = DataUtils.center(D4);
-
-//                                // Save these dataset out so we can compare with the White test. The judgements should be that edges for
-//                                // D1 and D2 are nonlinear and edges for D3 and D4 are nonlinear.
-//                                // Make sure you save out the graph as well.
-//
-//                                DataWriter.writeRectangularData(D1, new FileWriter(new File(dir, "D1.txt")), '\t');
-//                                DataWriter.writeRectangularData(D2, new FileWriter(new File(dir, "D2.txt")), '\t');
-//                                DataWriter.writeRectangularData(D3, new FileWriter(new File(dir, "D3.txt")), '\t');
-//                                DataWriter.writeRectangularData(D4, new FileWriter(new File(dir, "D4.txt")), '\t');
-
-//                                GraphUtils.saveGraph(graph, new File(dir, "graph.txt"), false);
-
-//                                List<Edge> edges = new ArrayList<Edge>(graph.getEdges());
-//                                sort(edges);
-//                                List<Node> variables = graph.getNodes();
-//
-//                                PrintStream graphOut = new PrintStream(new FileOutputStream(new File(dir, "graph.indices.txt")));
-//
-//                                for (int i = 0; i < edges.size(); i++) {
-//                                    Edge edge = edges.get(i);
-//
-//                                    Node x = edge.getNode1();
-//                                    Node y = edge.getNode2();
-//
-//                                    int j1 = variables.indexOf(x);
-//                                    int j2 = variables.indexOf(y);
-//
-//                                    graphOut.println((j1 + 1) + "\t" + (j2 + 1));
-//                                }
-//
-//                                out.close();
-
-                            Parameters parameters1 = new Parameters();
-                            parameters1.set("alpha", 0.001);
-                            parameters1.set("penaltyDiscount", 1);
-
-                            parameters1.set("depth", -1);
-                            parameters1.set("twoCycleAlpha", 1e-20);
-                            parameters1.set("extraEdgeThreshold", .5);
-                            parameters1.set("faskDelta", -0.2);
-
-//                                parameters1.set("useFasAdjacencies");
-//                                parameters1.set("useCorrDiffAdjacencies");
-//                                 Bootstrapping
-//                                parameters1.set("bootstrapSampleSize");
-//                                parameters1.set("bootstrapEnsemble");
-//                                parameters1.set("verbose");
-
-                            DataSet d = D4;
-
-                            d = DataUtils.getNonparanormalTransformed(d);
-//
-//
-//                            IndependenceWrapper test = new SemBicTest();
-//                            FAS pcall = new FAS(test);
-//                            Graph g2 = pcall.search(D4, parameters1);
-
-                            Score score = new edu.cmu.tetrad.search.SemBicScore(new CovarianceMatrixOnTheFly(d));
-
-                            edu.cmu.tetrad.search.Fask fask = new edu.cmu.tetrad.search.Fask(d, score);
-//                            fask.setInitialGraph(g2);
-                            Graph _g = fask.search();
-
-//                            _g = g2;
-
-                            _g = GraphUtils.replaceNodes(_g, graph.getNodes());
-
-//                            System.out.println("graph = " + graph + " _g = " + _g);
-
-                            double ap = new AdjacencyPrecision().getValue(_g, graph);
-                            double ar = new AdjacencyRecall().getValue(graph, _g);
-                            double ahp = new ArrowheadPrecisionIgnore2c().getValue(graph, _g);
-                            double ahr = new ArrowheadRecall().getValue(graph, _g);
-
-                            System.out.println("\nNonlinear function: " + nonlinearFunction);
-                            System.out.println("AP = " + ap + " AR = " + ar + " AHP = " + ahp + " AHR = " + ahr);
-                        }
-                    }
-                }
-            }
-
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-    }
-
-    private GeneralizedSemPm getPm(Graph graph, String function, String error, String parameters) {
-        GeneralizedSemPm pm = new GeneralizedSemPm(graph);
-
-        List<Node> variablesNodes = pm.getVariableNodes();
-        List<Node> errorNodes = pm.getErrorNodes();
-
-        try {
-            for (Node node : variablesNodes) {
-                String _template = TemplateExpander.getInstance().expandTemplate(
-                        function, pm, node);
-                pm.setNodeExpression(node, _template);
-            }
-
-            for (Node node : errorNodes) {
-                String _template = TemplateExpander.getInstance().expandTemplate(error, pm, node);
-                pm.setNodeExpression(node, _template);
-            }
-
-            for (String p : pm.getParameters()) {
-                pm.setParameterExpression(p, parameters);
-            }
-        } catch (ParseException e) {
-            System.out.println(e);
-        }
-
-        return pm;
-    }
-
-    private void print(GeneralizedSemPm pm) {
-        if (printStuff) {
-            System.out.println(pm);
-        }
-    }
-
-    private void print(List<Node> errorNodes) {
-        if (printStuff) {
-            System.out.println(errorNodes);
-        }
-    }
-
-    private void print(GeneralizedSemIm im) {
-        if (printStuff) {
-            System.out.println(im);
-        }
-    }
-
-    private void print(DataSet dataSet) {
-        if (printStuff) {
-            System.out.println(dataSet);
-        }
-    }
-
-    private void print(String x) {
-        if (printStuff) {
-            System.out.println(x);
-        }
-    }
-
-
-    private void print(SemPm semPm) {
-        if (printStuff) {
-            System.out.println(semPm);
-        }
-    }
-
-    @Test
-    public void test2() {
-        RandomUtil.getInstance().setSeed(2999983L);
-
-        int sampleSize = 1000;
-
-        List<Node> variableNodes = new ArrayList<>();
-        ContinuousVariable x1 = new ContinuousVariable("X1");
-        ContinuousVariable x2 = new ContinuousVariable("X2");
-        ContinuousVariable x3 = new ContinuousVariable("X3");
-        ContinuousVariable x4 = new ContinuousVariable("X4");
-        ContinuousVariable x5 = new ContinuousVariable("X5");
-
-        variableNodes.add(x1);
-        variableNodes.add(x2);
-        variableNodes.add(x3);
-        variableNodes.add(x4);
-        variableNodes.add(x5);
-
-        Graph _graph = new EdgeListGraph(variableNodes);
-        SemGraph graph = new SemGraph(_graph);
-        graph.addDirectedEdge(x1, x3);
-        graph.addDirectedEdge(x2, x3);
-        graph.addDirectedEdge(x3, x4);
-        graph.addDirectedEdge(x2, x4);
-        graph.addDirectedEdge(x4, x5);
-        graph.addDirectedEdge(x2, x5);
-
-        SemPm semPm = new SemPm(graph);
-        SemIm semIm = new SemIm(semPm);
-        DataSet dataSet = semIm.simulateData(sampleSize, false);
-
-        print(semPm);
-
-        GeneralizedSemPm _semPm = new GeneralizedSemPm(semPm);
-        GeneralizedSemIm _semIm = new GeneralizedSemIm(_semPm, semIm);
-        DataSet _dataSet = _semIm.simulateDataMinimizeSurface(sampleSize, false);
-
-        print(_semPm);
-
-//        System.out.println(_dataSet);
-
-        for (int j = 0; j < dataSet.getNumColumns(); j++) {
-            double[] col = dataSet.getDoubleData().getColumn(j).toArray();
-            double[] _col = _dataSet.getDoubleData().getColumn(j).toArray();
-
-            double mean = StatUtils.mean(col);
-            double _mean = StatUtils.mean(_col);
-
-            double variance = StatUtils.variance(col);
-            double _variance = StatUtils.variance(_col);
-
-            assertEquals(mean, _mean, 0.3);
-            assertEquals(1.0, variance / _variance, .2);
-        }
-    }
-
-    @Test
-    public void test3() {
-        RandomUtil.getInstance().setSeed(49293843L);
-
-        List<Node> variableNodes = new ArrayList<>();
-        ContinuousVariable x1 = new ContinuousVariable("X1");
-        ContinuousVariable x2 = new ContinuousVariable("X2");
-        ContinuousVariable x3 = new ContinuousVariable("X3");
-        ContinuousVariable x4 = new ContinuousVariable("X4");
-        ContinuousVariable x5 = new ContinuousVariable("X5");
-
-        variableNodes.add(x1);
-        variableNodes.add(x2);
-        variableNodes.add(x3);
-        variableNodes.add(x4);
-        variableNodes.add(x5);
-
-        Graph _graph = new EdgeListGraph(variableNodes);
-        SemGraph graph = new SemGraph(_graph);
-        graph.setShowErrorTerms(true);
-
-        Node e1 = graph.getExogenous(x1);
-        Node e2 = graph.getExogenous(x2);
-        Node e3 = graph.getExogenous(x3);
-        Node e4 = graph.getExogenous(x4);
-        Node e5 = graph.getExogenous(x5);
-
-        graph.addDirectedEdge(x1, x3);
-        graph.addDirectedEdge(x1, x2);
-        graph.addDirectedEdge(x2, x3);
-        graph.addDirectedEdge(x3, x4);
-        graph.addDirectedEdge(x2, x4);
-        graph.addDirectedEdge(x4, x5);
-        graph.addDirectedEdge(x2, x5);
-        graph.addDirectedEdge(x5, x1);
-
-        GeneralizedSemPm pm = new GeneralizedSemPm(graph);
-
-        List<Node> variablesNodes = pm.getVariableNodes();
-        print(variablesNodes);
-
-        List<Node> errorNodes = pm.getErrorNodes();
-        print(errorNodes);
-
-
-        try {
-            pm.setNodeExpression(x1, "cos(b1) + a1 * X5 + E_X1");
-            pm.setNodeExpression(x2, "a2 * X1 + E_X2");
-            pm.setNodeExpression(x3, "tan(a3*X2 + a4*X1) + E_X3");
-            pm.setNodeExpression(x4, "0.1 * E^X2 + X3 + E_X4");
-            pm.setNodeExpression(x5, "0.1 * E^X4 + a6* X2 + E_X5");
-            pm.setNodeExpression(e1, "U(0, 1)");
-            pm.setNodeExpression(e2, "U(0, 1)");
-            pm.setNodeExpression(e3, "U(0, 1)");
-            pm.setNodeExpression(e4, "U(0, 1)");
-            pm.setNodeExpression(e5, "U(0, 1)");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            print(im);
-
-            DataSet dataSet = im.simulateDataNSteps(1000, false);
-
-//            System.out.println(dataSet);
-
-            double[] d1 = dataSet.getDoubleData().getColumn(0).toArray();
-            double[] d2 = dataSet.getDoubleData().getColumn(1).toArray();
-
-            double cov = StatUtils.covariance(d1, d2);
-
-            assertEquals(-0.002, cov, 0.001);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test4() {
-        // For X3
-
-        Map<String, String[]> templates = new HashMap<>();
-
-        templates.put("NEW(b) + NEW(b) + NEW(c) + NEW(c) + NEW(c)", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("NEW(X1) + NEW(b) + NEW(c) + NEW(c) + NEW(c)", new String[]{});
-        templates.put("$", new String[]{});
-        templates.put("TSUM($)", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("TPROD($)", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("TPROD($) + X2", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("TPROD($) + TSUM($)", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("tan(TSUM(NEW(a)*$))", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("Normal(0, 1)", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("Normal(m, s)", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("Normal(NEW(m), s)", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("Normal(NEW(m), NEW(s)) + m1 + s6", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("TSUM($) + a", new String[]{"X1", "X2", "X3", "X4", "X5"});
-        templates.put("TSUM($) + TSUM($) + TSUM($) + 1", new String[]{"X1", "X2", "X3", "X4", "X5"});
-
-        for (String template : templates.keySet()) {
-            GeneralizedSemPm semPm = makeTypicalPm();
-            print(semPm.getGraph().toString());
-
-            Set<Node> shouldWork = new HashSet<>();
-
-            for (String name : templates.get(template)) {
-                shouldWork.add(semPm.getNode(name));
-            }
-
-            Set<Node> works = new HashSet<>();
-
-            for (int i = 0; i < semPm.getNodes().size(); i++) {
-                print("-----------");
-                print(semPm.getNodes().get(i).toString());
-                print("Trying template: " + template);
-                String _template = template;
-
-                Node node = semPm.getNodes().get(i);
-
-                try {
-                    _template = TemplateExpander.getInstance().expandTemplate(_template, semPm, node);
-                } catch (Exception e) {
-                    print("Couldn't expand template: " + template);
-                    continue;
-                }
-
-                try {
-                    semPm.setNodeExpression(node, _template);
-                    print("Set formula " + _template + " for " + node);
-
-                    if (semPm.getVariableNodes().contains(node)) {
-                        works.add(node);
-                    }
-
-                } catch (Exception e) {
-                    print("Couldn't set formula " + _template + " for " + node);
-                }
-            }
-
-            for (String parameter : semPm.getParameters()) {
-                print("-----------");
-                print(parameter);
-                print("Trying template: " + template);
-                String _template = template;
-
-                try {
-                    _template = TemplateExpander.getInstance().expandTemplate(_template, semPm, null);
-                } catch (Exception e) {
-                    print("Couldn't expand template: " + template);
-                    continue;
-                }
-
-                try {
-                    semPm.setParameterExpression(parameter, _template);
-                    print("Set formula " + _template + " for " + parameter);
-                } catch (Exception e) {
-                    print("Couldn't set formula " + _template + " for " + parameter);
-                }
-            }
-
-            assertEquals(shouldWork, works);
-        }
-    }
-
-    @Test
-    public void test5() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        List<Node> nodes = new ArrayList<>();
-
-        for (int i1 = 0; i1 < 5; i1++) {
-            nodes.add(new ContinuousVariable("X" + (i1 + 1)));
-        }
-
-        Graph graph = new Dag(GraphUtils.randomGraph(nodes, 0, 5,
-                30, 15, 15, false));
-        SemPm semPm = new SemPm(graph);
-        SemIm semIm = new SemIm(semPm);
-
-        semIm.simulateDataReducedForm(1000, false);
-
-        GeneralizedSemPm pm = new GeneralizedSemPm(semPm);
-        GeneralizedSemIm im = new GeneralizedSemIm(pm, semIm);
-
-        TetradVector e = new TetradVector(5);
-
-        for (int i = 0; i < e.size(); i++) {
-            e.set(i, RandomUtil.getInstance().nextNormal(0, 1));
-        }
-
-        TetradVector record1 = semIm.simulateOneRecord(e);
-        TetradVector record2 = im.simulateOneRecord(e);
-
-        print("XXX1" + e);
-        print("XXX2" + record1);
-        print("XXX3" + record2);
-
-        for (int i = 0; i < record1.size(); i++) {
-            assertEquals(record1.get(i), record2.get(i), 1e-10);
-        }
-    }
-
-    @Test
-    public void test6() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        int numVars = 5;
-
-        List<Node> nodes = new ArrayList<>();
-        for (int i = 0; i < numVars; i++) nodes.add(new ContinuousVariable("X" + (i + 1)));
-
-        Graph graph = GraphUtils.randomGraphRandomForwardEdges(nodes, 0, numVars, 30, 15, 15, false, true);
-
-        SemPm spm = new SemPm(graph);
-
-        Parameters params = new Parameters();
-        params.set("coefLow", 0.5);
-        params.set("coefHigh", 1.5);
-        params.set("varLow", 1);
-        params.set("varHigh", 3);
-
-        SemIm sim = new SemIm(spm, params);
-
-        GeneralizedSemPm pm = new GeneralizedSemPm(spm);
-        GeneralizedSemIm im = new GeneralizedSemIm(pm, sim);
-
-        DataSet data = im.simulateData(1000, false);
-
-        print(im);
-
-        GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-        GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-        print(estIm);
-        print(estimator.getReport());
-
-        double aSquaredStar = estimator.getaSquaredStar();
-
-        assertEquals(1.04, aSquaredStar, 0.01);
-    }
-
-    @Test
-    public void test7() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        List<Node> nodes = new ArrayList<>();
-        int numVars = 10;
-
-        for (int i = 0; i < numVars; i++) nodes.add(new ContinuousVariable("X" + (i + 1)));
-
-        Graph graph = GraphUtils.randomGraphRandomForwardEdges(nodes, 0, numVars, 30, 15, 15, false, true);
-
-        GeneralizedSemPm pm = new GeneralizedSemPm(graph);
-        GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-        print(im);
-
-        DataSet data = im.simulateDataRecursive(1000, false);
-
-        GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-        GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-        print(estIm);
-        print(estimator.getReport());
-
-        double aSquaredStar = estimator.getaSquaredStar();
-
-        assertEquals(0.67, aSquaredStar, 0.01);
-    }
-
-    @Test
-    public void test8() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        Node x = new GraphNode("X");
-        Node y = new GraphNode("Y");
-
-        List<Node> nodes = new ArrayList<>();
-        nodes.add(x);
-        nodes.add(y);
-
-        Graph graph = new EdgeListGraphSingleConnections(nodes);
-
-        graph.addDirectedEdge(x, y);
-
-        SemPm spm = new SemPm(graph);
-        SemIm sim = new SemIm(spm);
-
-        sim.setEdgeCoef(x, y, 20);
-        sim.setErrVar(x, 1);
-        sim.setErrVar(y, 1);
-
-        GeneralizedSemPm pm = new GeneralizedSemPm(spm);
-        GeneralizedSemIm im = new GeneralizedSemIm(pm, sim);
-
-        print(im);
-
-        try {
-            pm.setParameterEstimationInitializationExpression("b1", "U(10, 30)");
-            pm.setParameterEstimationInitializationExpression("T1", "U(.1, 3)");
-            pm.setParameterEstimationInitializationExpression("T2", "U(.1, 3)");
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-
-        DataSet data = im.simulateDataRecursive(1000, false);
-
-        GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-        GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-        print(estIm);
-//        System.out.println(estimator.getReport());
-
-        double aSquaredStar = estimator.getaSquaredStar();
-
-        assertEquals(0.69, aSquaredStar, 0.01);
-    }
-
-    @Test
-    public void test9() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * tan(X1) + E_X2");
-            pm.setNodeExpression(x3, "a2 * tan(X2) + E_X3");
-            pm.setNodeExpression(x4, "a3 * tan(X1) + a4 * tan(X3) ^ 2 + E_X4");
-
-//            pm.setNodeExpression(x1, "E_X1");
-//            pm.setNodeExpression(x2, "a1 * X1^2 + E_X2");
-//            pm.setNodeExpression(x3, "a2 * X2^2 + E_X3");
-//            pm.setNodeExpression(x4, "a3 * X1^2 + a4 * X3 ^ 2 + E_X4");
-//
-            pm.setNodeExpression(pm.getErrorNode(x1), "Beta(5, 2)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "Beta(2, 5)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "Beta(1, 3)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "Beta(1, 7)");
-
-            pm.setParameterEstimationInitializationExpression("c1", "U(1, 3)");
-            pm.setParameterEstimationInitializationExpression("c2", "U(1, 3)");
-            pm.setParameterEstimationInitializationExpression("c3", "U(1, 3)");
-            pm.setParameterEstimationInitializationExpression("c4", "U(1, 3)");
-            pm.setParameterEstimationInitializationExpression("c5", "U(1, 3)");
-            pm.setParameterEstimationInitializationExpression("c6", "U(1, 3)");
-            pm.setParameterEstimationInitializationExpression("c7", "U(1, 3)");
-            pm.setParameterEstimationInitializationExpression("c8", "U(1, 3)");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(1000, false);
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "Beta(c1, c2)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "Beta(c3, c4)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "Beta(c5, c6)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "Beta(c7, c8)");
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(0.62, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test10() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * tan(X1) + E_X2");
-            pm.setNodeExpression(x3, "a2 * tan(X2) + E_X3");
-            pm.setNodeExpression(x4, "a3 * tan(X1) * a4 * tan(X3) ^ 2 + E_X4");
-//
-//            pm.setNodeExpression(x2, "a1 * X1 + E_X2");
-//            pm.setNodeExpression(x3, "a2 * X2 + E_X3");
-//            pm.setNodeExpression(x4, "a3 * X1 + a4 * X3 + E_X4");
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "Gamma(5, 2)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "Gamma(5, 2)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "Gamma(5, 2)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "Gamma(5, 2)");
-
-            pm.setParameterEstimationInitializationExpression("c1", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c2", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c3", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c4", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c5", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c6", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c7", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c8", "U(1, 5)");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(1000, false);
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "Gamma(c1, c2)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "Gamma(c3, c4)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "Gamma(c5, c6)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "Gamma(c7, c8)");
-
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(1.42, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test11() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * tan(X1) + E_X2");
-            pm.setNodeExpression(x3, "a2 * tan(X2) + E_X3");
-            pm.setNodeExpression(x4, "a3 * tan(X1) + a4 * tan(X3) ^ 2 + E_X4");
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "N(0, c1)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "N(0, c2)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "N(0, c3)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "N(0, c4)");
-
-            pm.setParameterExpression("c1", "4");
-            pm.setParameterExpression("c2", "4");
-            pm.setParameterExpression("c3", "4");
-            pm.setParameterExpression("c4", "4");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(1000, false);
-
-            GeneralizedSemIm imInit = new GeneralizedSemIm(pm);
-            imInit.setParameterValue("c1", 8);
-            imInit.setParameterValue("c2", 8);
-            imInit.setParameterValue("c3", 8);
-            imInit.setParameterValue("c4", 8);
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(7.07, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test12() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * tan(X1) + E_X2");
-            pm.setNodeExpression(x3, "a2 * tan(X2) + E_X3");
-            pm.setNodeExpression(x4, "a3 * tan(X1) + a4 * tan(X3) ^ 2 + E_X4");
-//
-//            pm.setNodeExpression(x2, "a1 * X1 + E_X1");
-//            pm.setNodeExpression(x3, "a2 * X2 + E_X1");
-//            pm.setNodeExpression(x4, "a3 * X1 + a4 * X3 + E_X1");
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "Normal(c1, c2)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "Normal(c3, c4)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "Normal(c5, c6)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "Normal(c7, c8)");
-
-            pm.setParameterExpression("c1", "1");
-            pm.setParameterExpression("c2", "5");
-            pm.setParameterExpression("c3", "1");
-            pm.setParameterExpression("c4", "5");
-            pm.setParameterExpression("c5", "1");
-            pm.setParameterExpression("c6", "5");
-            pm.setParameterExpression("c7", "1");
-            pm.setParameterExpression("c8", "5");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(1000, false);
-
-            GeneralizedSemIm imInit = new GeneralizedSemIm(pm);
-            imInit.setParameterValue("c1", 3);
-            imInit.setParameterValue("c2", 4);
-            imInit.setParameterValue("c3", 3);
-            imInit.setParameterValue("c4", 4);
-            imInit.setParameterValue("c5", 3);
-            imInit.setParameterValue("c6", 4);
-            imInit.setParameterValue("c7", 3);
-            imInit.setParameterValue("c8", 4);
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(2.56, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test13() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * tan(X1) + E_X1");
-            pm.setNodeExpression(x3, "a2 * tan(X2) + E_X1");
-            pm.setNodeExpression(x4, "a3 * tan(X1) + a4 * tan(X3) + E_X1");
-//
-//            pm.setNodeExpression(x1, "E_X1");
-//            pm.setNodeExpression(x2, "a1 * X1 + E_X2");
-//            pm.setNodeExpression(x3, "a2 * X2 + E_X3");
-//            pm.setNodeExpression(x4, "a3 * X1 + a4 * X3 + E_X4");
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "StudentT(c2)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "StudentT(c4)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "StudentT(c6)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "StudentT(c8)");
-//
-//            pm.setNodeExpression(pm.getErrorNode(x1), "N(0, c2)");
-//            pm.setNodeExpression(pm.getErrorNode(x2), "N(0, c4)");
-//            pm.setNodeExpression(pm.getErrorNode(x3), "N(0, c6)");
-//            pm.setNodeExpression(pm.getErrorNode(x4), "N(0, c8)");
-
-            pm.setParameterExpression("c2", "3");
-            pm.setParameterExpression("c4", "3");
-            pm.setParameterExpression("c6", "3");
-            pm.setParameterExpression("c8", "3");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(500, false);
-
-            GeneralizedSemIm imInit = new GeneralizedSemIm(pm);
-            imInit.setParameterValue("c2", 1);
-            imInit.setParameterValue("c4", 1);
-            imInit.setParameterValue("c6", 1);
-            imInit.setParameterValue("c8", 1);
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(3.19, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test14() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * tan(X1) + E_X2");
-            pm.setNodeExpression(x3, "a2 * tan(X2) + E_X3");
-            pm.setNodeExpression(x4, "a3 * tan(X1) + a4 * tan(X3) ^ 2 + E_X4");
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "N(0, c1)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "N(0, c2)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "N(0, c3)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "N(0, c4)");
-
-            pm.setParameterExpression("a1", "1");
-            pm.setParameterExpression("a2", "1");
-            pm.setParameterExpression("a3", "1");
-            pm.setParameterExpression("a4", "1");
-            pm.setParameterExpression("c1", "4");
-            pm.setParameterExpression("c2", "4");
-            pm.setParameterExpression("c3", "4");
-            pm.setParameterExpression("c4", "4");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(1000, false);
-
-            GeneralizedSemIm imInit = new GeneralizedSemIm(pm);
-            imInit.setParameterValue("c1", 8);
-            imInit.setParameterValue("c2", 8);
-            imInit.setParameterValue("c3", 8);
-            imInit.setParameterValue("c4", 8);
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(71.25, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test15() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * X1 + E_X2");
-            pm.setNodeExpression(x3, "a2 * X2 + E_X3");
-            pm.setNodeExpression(x4, "a3 * X1 + a4 * X3 ^ 2 + E_X4");
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "Gamma(c1, c2)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "ChiSquare(c3)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "ChiSquare(c4)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "ChiSquare(c5)");
-
-            pm.setParameterExpression("c1", "5");
-            pm.setParameterExpression("c2", "2");
-            pm.setParameterExpression("c3", "10");
-            pm.setParameterExpression("c4", "10");
-            pm.setParameterExpression("c5", "10");
-
-            pm.setParameterEstimationInitializationExpression("c1", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c2", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c3", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c4", "U(1, 5)");
-            pm.setParameterEstimationInitializationExpression("c5", "U(1, 5)");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(1000, false);
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(.79, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test16() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * X1 + E_X2");
-            pm.setNodeExpression(x3, "a2 * X2 + E_X3");
-            pm.setNodeExpression(x4, "a3 * X1 + a4 * X3 ^ 2 + E_X4");
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "N(0, c1)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "N(0, c2)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "N(0, c3)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "N(0, c4)");
-
-//            pm.setParameterExpression("c1", "1");
-//            pm.setParameterExpression("c2", "1");
-//            pm.setParameterExpression("c3", "1");
-//            pm.setParameterExpression("c4", "1");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            im.setParameterValue("a1", 1);
-            im.setParameterValue("a2", 1);
-            im.setParameterValue("a3", 1);
-            im.setParameterValue("a4", 1);
-            im.setParameterValue("c1", 1);
-            im.setParameterValue("c2", 1);
-            im.setParameterValue("c3", 1);
-            im.setParameterValue("c4", 1);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(1000, false);
-
-            GeneralizedSemIm imInit = new GeneralizedSemIm(pm);
-
-            imInit.setParameterValue("a1", .5);
-            imInit.setParameterValue("a2", .5);
-            imInit.setParameterValue("a3", .5);
-            imInit.setParameterValue("a4", .7);
-            imInit.setParameterValue("c1", 2);
-            imInit.setParameterValue("c2", 2);
-            imInit.setParameterValue("c3", 2);
-            imInit.setParameterValue("c4", 2);
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(50.38, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    @Test
-    public void test17() {
-        RandomUtil.getInstance().setSeed(29999483L);
-
-        try {
-            Node x1 = new GraphNode("X1");
-            Node x2 = new GraphNode("X2");
-            Node x3 = new GraphNode("X3");
-            Node x4 = new GraphNode("X4");
-
-            Graph g = new EdgeListGraphSingleConnections();
-            g.addNode(x1);
-            g.addNode(x2);
-            g.addNode(x3);
-            g.addNode(x4);
-
-            g.addDirectedEdge(x1, x2);
-            g.addDirectedEdge(x2, x3);
-            g.addDirectedEdge(x3, x4);
-            g.addDirectedEdge(x1, x4);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(g);
-
-            pm.setNodeExpression(x1, "E_X1");
-            pm.setNodeExpression(x2, "a1 * X1 + E_X2");
-            pm.setNodeExpression(x3, "a2 * X2 + E_X3");
-            pm.setNodeExpression(x4, "a3 * X1 * a3 * a4 * X3 + E_X4");
-
-            pm.setNodeExpression(pm.getErrorNode(x1), "N(0, c1)");
-            pm.setNodeExpression(pm.getErrorNode(x2), "N(0, c2)");
-            pm.setNodeExpression(pm.getErrorNode(x3), "N(0, c3)");
-            pm.setNodeExpression(pm.getErrorNode(x4), "N(0, c4)");
-
-//            pm.setParameterExpression("c1", "1");
-//            pm.setParameterExpression("c2", "1");
-//            pm.setParameterExpression("c3", "1");
-//            pm.setParameterExpression("c4", "1");
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            im.setParameterValue("a1", 1);
-            im.setParameterValue("a2", 1);
-            im.setParameterValue("a3", 1);
-            im.setParameterValue("a4", 1);
-            im.setParameterValue("c1", 1);
-            im.setParameterValue("c2", 1);
-            im.setParameterValue("c3", 1);
-            im.setParameterValue("c4", 1);
-
-            print("True model: ");
-            print(im);
-
-            DataSet data = im.simulateDataRecursive(1000, false);
-
-            GeneralizedSemIm imInit = new GeneralizedSemIm(pm);
-
-            imInit.setParameterValue("a1", RandomUtil.getInstance().nextUniform(-3, 3));
-            imInit.setParameterValue("a2", RandomUtil.getInstance().nextUniform(-3, 3));
-            imInit.setParameterValue("a3", RandomUtil.getInstance().nextUniform(-3, 3));
-            imInit.setParameterValue("a4", RandomUtil.getInstance().nextUniform(-3, 3));
-            imInit.setParameterValue("c1", RandomUtil.getInstance().nextUniform(1, 3));
-            imInit.setParameterValue("c2", RandomUtil.getInstance().nextUniform(1, 3));
-            imInit.setParameterValue("c3", RandomUtil.getInstance().nextUniform(1, 3));
-            imInit.setParameterValue("c4", RandomUtil.getInstance().nextUniform(1, 3));
-
-            GeneralizedSemEstimator estimator = new GeneralizedSemEstimator();
-            GeneralizedSemIm estIm = estimator.estimate(pm, data);
-
-            print("\n\n\nEstimated model: ");
-            print(estIm);
-            print(estimator.getReport());
-
-            double aSquaredStar = estimator.getaSquaredStar();
-
-            assertEquals(14.26, aSquaredStar, 0.01);
-        } catch (ParseException e) {
-            e.printStackTrace();
-        }
-    }
-
-    private GeneralizedSemPm makeTypicalPm() {
-        List<Node> variableNodes = new ArrayList<>();
-        ContinuousVariable x1 = new ContinuousVariable("X1");
-        ContinuousVariable x2 = new ContinuousVariable("X2");
-        ContinuousVariable x3 = new ContinuousVariable("X3");
-        ContinuousVariable x4 = new ContinuousVariable("X4");
-        ContinuousVariable x5 = new ContinuousVariable("X5");
-
-        variableNodes.add(x1);
-        variableNodes.add(x2);
-        variableNodes.add(x3);
-        variableNodes.add(x4);
-        variableNodes.add(x5);
-
-        Graph _graph = new EdgeListGraph(variableNodes);
-        SemGraph graph = new SemGraph(_graph);
-        graph.addDirectedEdge(x1, x3);
-        graph.addDirectedEdge(x2, x3);
-        graph.addDirectedEdge(x3, x4);
-        graph.addDirectedEdge(x2, x4);
-        graph.addDirectedEdge(x4, x5);
-        graph.addDirectedEdge(x2, x5);
-
-        return new GeneralizedSemPm(graph);
-    }
-}
-
-
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestFaskGfci.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestFaskGfci.java
deleted file mode 100644
index c315a1ae..00000000
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestFaskGfci.java
+++ /dev/null
@@ -1,131 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.test;
-
-import edu.cmu.tetrad.algcomparison.Comparison;
-import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Fci;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Gfci;
-import edu.cmu.tetrad.algcomparison.algorithm.oracle.pag.Rfci;
-import edu.cmu.tetrad.algcomparison.graph.RandomForward;
-import edu.cmu.tetrad.algcomparison.independence.SemBicTest;
-import edu.cmu.tetrad.algcomparison.score.SemBicScore;
-import edu.cmu.tetrad.algcomparison.simulation.LinearFisherModel;
-import edu.cmu.tetrad.algcomparison.simulation.Simulations;
-import edu.cmu.tetrad.algcomparison.statistic.*;
-import edu.cmu.tetrad.util.Parameters;
-
-/**
- * Pulling this test out for Madelyn.
- *
- * @author jdramsey
- */
-public class TestFaskGfci {
-
-    public void TestFaskGfci() {
-        Parameters parameters = new Parameters();
-
-        // Random forward
-        parameters.set("numMeasures", 100);
-        parameters.set("numLatents", 20);
-        parameters.set("avgDegree", 2);
-        parameters.set("maxDegree", 100);
-        parameters.set("maxIndegree", 100);
-        parameters.set("maxOutdegree", 100);
-        parameters.set("connected", false   );
-
-        // Linear Fisher model
-        parameters.set("coefLow", .2);
-        parameters.set("coefHigh", .9);
-        parameters.set("varLow", 1);
-        parameters.set("varHigh", 3);
-        parameters.set("verbose", false);
-        parameters.set("includePositiveCoefs", true, false);
-        parameters.set("includeNegativeCoefs", true, false);
-        parameters.set("errorsNormal", false);
-        parameters.set("betaLeftValue", 1);
-        parameters.set("betaRightValue", 5);
-        parameters.set("numRuns", 1);
-        parameters.set("percentDiscrete", 0);
-        parameters.set("numCategories", 4);
-        parameters.set("differentGraphs", false);
-        parameters.set("sampleSize", 1000);
-        parameters.set("intervalBetweenShocks", 10);
-        parameters.set("intervalBetweenRecordings", 10);
-        parameters.set("fisherEpsilon", 0.001);
-        parameters.set("randomizeColumns", false);
-        
-        // Sem BIC, test
-        parameters.set("penaltyDiscount", 2);
-
-        parameters.set("alpha", 0.001);
-
-        // FASK GFCI Concatenated
-        parameters.set("depth", -1);
-        parameters.set("numRuns", 10);
-        parameters.set("randomSelectionSize", 1);
-
-        Statistics statistics = new Statistics();
-
-        statistics.add(new ParameterColumn("includePositiveCoefs"));
-        statistics.add(new ParameterColumn("includeNegativeCoefs"));
-        statistics.add(new AdjacencyPrecision());
-        statistics.add(new AdjacencyRecall());
-        statistics.add(new ArrowheadPrecision());
-        statistics.add(new ArrowheadRecall());
-        statistics.add(new ElapsedTime());
-
-        Simulations simulations = new Simulations();
-
-        simulations.add(new LinearFisherModel(new RandomForward()));
-
-        Algorithms algorithms = new Algorithms();
-
-        algorithms.add(new Fci(new SemBicTest()));
-        algorithms.add(new Rfci(new SemBicTest()));
-        algorithms.add(new Gfci(new SemBicTest(), new SemBicScore()));
-        Comparison comparison = new Comparison();
-
-        comparison.setShowAlgorithmIndices(true);
-        comparison.setShowSimulationIndices(true);
-        comparison.setSortByUtility(false);
-        comparison.setShowUtilities(false);
-        comparison.setParallelized(false);
-        comparison.setSaveGraphs(false);
-        comparison.setTabDelimitedTables(false);
-        comparison.setSaveGraphs(true);
-        comparison.setComparisonGraph(Comparison.ComparisonGraph.PAG_of_the_true_DAG);
-
-        String directory = "fask_gfci1";
-
-        comparison.compareFromSimulations(directory, simulations, algorithms, statistics, parameters);
-    }
-    
-    
-    public static void main(String... args) {
-        new TestFaskGfci().TestFaskGfci();
-    }
-}
-
-
-
-
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestFges.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestFges.java
index 27b00be8..2e6e64e6 100644
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestFges.java
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestFges.java
@@ -22,11 +22,12 @@
 package edu.cmu.tetrad.test;
 
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithm;
-import edu.cmu.tetrad.algcomparison.algorithm.multi.Fask;
 import edu.cmu.tetrad.algcomparison.graph.RandomForward;
 import edu.cmu.tetrad.algcomparison.graph.RandomGraph;
 import edu.cmu.tetrad.algcomparison.independence.FisherZ;
 import edu.cmu.tetrad.algcomparison.independence.IndependenceWrapper;
+import edu.cmu.tetrad.algcomparison.independence.SemBicDTest;
+import edu.cmu.tetrad.algcomparison.independence.SemBicTest;
 import edu.cmu.tetrad.algcomparison.score.FisherZScore;
 import edu.cmu.tetrad.algcomparison.score.ScoreWrapper;
 import edu.cmu.tetrad.algcomparison.simulation.LinearFisherModel;
@@ -47,13 +48,14 @@ import edu.cmu.tetrad.util.*;
 import edu.pitt.csb.mgm.MGM;
 import edu.pitt.csb.mgm.MixedUtils;
 import org.junit.Test;
+import org.junit.rules.TestWatcher;
 
 import java.io.*;
 import java.text.DecimalFormat;
 import java.text.NumberFormat;
 import java.util.*;
 
-import static java.lang.Math.sqrt;
+import static java.lang.Math.exp;
 import static junit.framework.TestCase.assertFalse;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
@@ -373,89 +375,10 @@ public class TestFges {
     }
 
     @Test
-    public void test11() {
-        Parameters parameters = new Parameters();
-
-        parameters.set("numMeasures", 100);
-        parameters.set("numLatents", 0);
-        parameters.set("avgDegree", 2);
-        parameters.set("maxDegree", 100);
-        parameters.set("maxIndegree", 100);
-        parameters.set("maxOutdegree", 100);
-        parameters.set("connected", false);
-
-        parameters.set("alpha", 1e-4);
-        parameters.set("penaltyDiscount", 1);
-        parameters.set("depth", -1);
-
-        parameters.set("coefLow", 0.2);
-        parameters.set("coefHigh", 0.6);
-        parameters.set("varLow", .5);
-        parameters.set("varHigh", 1);
-        parameters.set("verbose", false);
-        parameters.set("includePositiveCoefs", true);
-        parameters.set("includeNegativeCoefs", false);
-        parameters.set("errorsNormal", false);
-        parameters.set("betaLeftValue", 1);
-        parameters.set("betaRightValue", 5);
-        parameters.set("numRuns", 1);
-        parameters.set("percentDiscrete", 0);
-        parameters.set("numCategories", 3);
-        parameters.set("differentGraphs", false);
-        parameters.set("sampleSize", 1000);
-        parameters.set("intervalBetweenShocks", 20);
-        parameters.set("intervalBetweenRecordings", 20);
-        parameters.set("fisherEpsilon", 0.0001);
-        parameters.set("randomizeColumns", false);
-
-        parameters.set("numRuns", 1);
-        parameters.set("differentGraphs", false);
-        parameters.set("sampleSize", 2000);
-
-        parameters.set("faithfulnessAssumed", false);
-        parameters.set("symmetricFirstStep", false);
-        parameters.set("maxDegree", 10);
-        parameters.set("verbose", false);
-
-        parameters.set("measurementVariance", Math.pow(0.1, 2));
-
-        Simulation simulation = new LinearFisherModel(new RandomForward());
-        simulation.createData(parameters);
-
-        ScoreWrapper score = new edu.cmu.tetrad.algcomparison.score.SemBicScore();
-        IndependenceWrapper test = new edu.cmu.tetrad.algcomparison.independence.SemBicTest();
-
-        DataSet dataSet = (DataSet) simulation.getDataModel(0);
-        dataSet = DataUtils.standardizeData(dataSet);
-        Graph trueGraph = simulation.getTrueGraph(0);
-
-        Algorithm fges = new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Fges(score);
-//        Algorithm pc = new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Pc(test);
-//        Algorithm fas = new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.FAS(test);
-
-
-        Algorithm fask = new edu.cmu.tetrad.algcomparison.algorithm.multi.Fask(new edu.cmu.tetrad.algcomparison.score.SemBicScore());
-
-        Graph outGraph = fask.search(dataSet, parameters);
-//        Graph truePattern = SearchGraphUtils.patternForDag(trueGraph);
-
-        GraphUtils.GraphComparison comparison = SearchGraphUtils.getGraphComparison3(outGraph, trueGraph);
-        NumberFormat nf = new DecimalFormat("0.00");
-
-        System.out.println(
-                "\t" + nf.format(comparison.getAdjPrec()) +
-                        "\t" + nf.format(comparison.getAdjRec()) +
-                        "\t" + nf.format(comparison.getAhdPrec()) +
-                        "\t" + nf.format(comparison.getAhdRec()) +
-                        "\t" + nf.format(comparison.getTwoCycleFp())
-        );
-
-    }
-
-    //    @Test
     public void clarkTest() {
+        RandomGraph randomGraph = new RandomForward();
 
-        Simulation simulation = new LinearFisherModel(new RandomForward());
+        Simulation simulation = new LinearFisherModel(randomGraph);
 
         Parameters parameters = new Parameters();
 
@@ -473,15 +396,12 @@ public class TestFges {
         parameters.set("differentGraphs", false);
         parameters.set("sampleSize", 1000);
 
-        parameters.set("faithfulnessAssumed", true);
-        parameters.set("symmetricFirstStep", false);
-        parameters.set("maxDegree", 01);
+        parameters.set("faithfulnessAssumed", false);
+        parameters.set("maxDegree", -1);
         parameters.set("verbose", false);
 
         parameters.set("alpha", 0.01);
 
-        parameters.set("penaltyDiscount", 2);
-
         simulation.createData(parameters);
 
         DataSet dataSet = (DataSet) simulation.getDataModel(0);
@@ -679,6 +599,7 @@ public class TestFges {
                 "6. SEX --> PUBS";
 
 
+
         Graph trueGraph = null;
 
 
@@ -845,7 +766,7 @@ public class TestFges {
 
         edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.PcFges pcFges
                 = new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.PcFges(
-                new edu.cmu.tetrad.algcomparison.score.SemBicScore(), false);
+                new edu.cmu.tetrad.algcomparison.score.SemBicScore(),false);
 
         long start = System.currentTimeMillis();
 
@@ -918,7 +839,7 @@ public class TestFges {
 
                 Graph truePattern = SearchGraphUtils.patternForDag(dag);
 
-                GraphUtils.GraphComparison comparison = SearchGraphUtils.getGraphComparison3(pattern, truePattern);
+                GraphUtils.GraphComparison comparison = SearchGraphUtils.getGraphComparison3(pattern, truePattern, System.out);
                 NumberFormat nf = new DecimalFormat("0.00");
 
                 System.out.println(i +
@@ -1241,9 +1162,9 @@ public class TestFges {
 
                 double sum = adjPrecision + adjRecall + arrowPrecision + arrowRecall;
                 double mcAdj = (adjTp * adjTn - adjFp * adjFn) /
-                        sqrt((adjTp + adjFp) * (adjTp + adjFn) * (adjTn + adjFp) * (adjTn + adjFn));
+                        Math.sqrt((adjTp + adjFp) * (adjTp + adjFn) * (adjTn + adjFp) * (adjTn + adjFn));
                 double mcOr = (arrowsTp * arrowsTn - arrowsFp * arrowsFn) /
-                        sqrt((arrowsTp + arrowsFp) * (arrowsTp + arrowsFn) *
+                        Math.sqrt((arrowsTp + arrowsFp) * (arrowsTp + arrowsFn) *
                                 (arrowsTn + arrowsFp) * (arrowsTn + arrowsFn));
                 double f1Adj = 2 * (adjPrecision * adjRecall) / (adjPrecision + adjRecall);
                 double f1Arrows = 2 * (arrowPrecision * arrowRecall) / (arrowPrecision + arrowRecall);
@@ -1549,12 +1470,11 @@ public class TestFges {
         return dag;
     }
 
-    @Test
     public void test9() {
 
         Parameters parameters = new Parameters();
 
-        parameters.set("numMeasures", 300);
+        parameters.set("numMeasures", 50);
         parameters.set("numLatents", 0);
         parameters.set("avgDegree", 2);
         parameters.set("maxDegree", 20);
@@ -1572,30 +1492,55 @@ public class TestFges {
         parameters.set("percentDiscrete", 0);
         parameters.set("numCategories", 3);
         parameters.set("differentGraphs", true);
-        parameters.set("sampleSize", 1000);
-
-        parameters.set("intervalBetweenShocks", 5);
+        parameters.set("sampleSize", 500);
+        parameters.set("intervalBetweenShocks", 10);
         parameters.set("intervalBetweenRecordings", 10);
-        parameters.set("selfLoopCoef", 0.);
-
         parameters.set("fisherEpsilon", 0.001);
-        parameters.set("includePositiveCoefs", true);
-        parameters.set("includeNegativeCoefs", true);
-        parameters.set("errorsNormal", false);
-        parameters.set("betaLeftValue", 2);
-        parameters.set("betaRightValue", 5);
-        parameters.set("randomizeColumns", false);
-        parameters.set("measurementVariance", 0.0);
-
-        parameters.set("penaltyDiscount", .5);
+        parameters.set("randomizeColumns", true);
 
         RandomGraph graph = new RandomForward();
         LinearFisherModel sim = new LinearFisherModel(graph);
         sim.createData(parameters);
+        Graph previous = null;
+        int prevDiff = Integer.MAX_VALUE;
+
+//        for (int l = 7; l >= 1; l--) {
+        for (int i = 2; i <= 20; i++) {
+            parameters.set("penaltyDiscount", i / (double) 10);
+//            parameters.set("alpha", Double.parseDouble("1E-" + l));
+
+//            ScoreWrapper score = new edu.cmu.tetrad.algcomparison.score.SemBicScore();
+//            Algorithm alg = new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Fges(score);
+
+            IndependenceWrapper test = new SemBicTest();
+//            IndependenceWrapper test = new FisherZ();
+            Algorithm alg = new edu.cmu.tetrad.algcomparison.algorithm.oracle.pattern.Cpc(test);
 
-        Algorithm alg = new Fask(new edu.cmu.tetrad.algcomparison.score.SemBicScore());
+            Graph out = alg.search(sim.getDataModel(0), parameters);
+//            Graph out = GraphUtils.undirectedGraph(alg.search(sim.getDataModel(0), parameters));
 
-        Graph estGraph = alg.search(sim.getDataModel(0), parameters);
+            Set<Edge> edges1 = out.getEdges();
+
+            int numEdges = edges1.size();
+
+            if (previous != null) {
+                Set<Edge> edges2 = previous.getEdges();
+                edges2.removeAll(edges1);
+                int diff = edges2.size();
+//
+                System.out.println("Penalty discount =" + parameters.getDouble("penaltyDiscount")
+                        + " # edges = " + numEdges
+                        + " # additional = " + diff);
+
+                previous = out;
+                if (diff > prevDiff) break;
+                prevDiff = diff;
+            } else {
+                previous = out;
+            }
+        }
+
+        Graph estGraph = previous;
         Graph trueGraph = sim.getTrueGraph(0);
 
         estGraph = GraphUtils.replaceNodes(estGraph, trueGraph.getNodes());
@@ -1611,6 +1556,7 @@ public class TestFges {
         System.out.println("AHR = " + ahr.getValue(trueGraph, estGraph));
     }
 
+
     public static void main(String... args) {
         if (args.length > 0) {
             int numMeasures = Integer.parseInt(args[0]);
@@ -1661,26 +1607,6 @@ public class TestFges {
         }
     }
 
-    public void test13() {
-        try {
-            File file1 = new File("/Users/user/Downloads/MyFile.txt");
-            DataReader reader = new DataReader();
-            reader.setVariablesSupplied(false);
-            reader.setDelimiter(DelimiterType.COMMA);
-            DataSet data = reader.parseTabular(file1);
-            SemBicScore score = new SemBicScore(new CovarianceMatrixOnTheFly(data));
-            score.setPenaltyDiscount(1.0);
-
-            Fges fges = new Fges(score);
-
-            System.out.println(fges.search());
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-
-    }
-
 }
 
 
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestGFci.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestGFci.java
index 4746fe61..bc9edd11 100644
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestGFci.java
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestGFci.java
@@ -32,8 +32,6 @@ import edu.cmu.tetrad.util.DelimiterUtils;
 import edu.cmu.tetrad.util.RandomUtil;
 import edu.pitt.dbmi.data.reader.tabular.TabularDataReader;
 import edu.pitt.dbmi.data.reader.tabular.VerticalDiscreteTabularDataReader;
-
-import java.io.File;
 import java.io.IOException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
@@ -288,40 +286,4 @@ public class TestGFci {
 
         System.out.println("Elapsed " + (stop - start) + " ms");
     }
-
-//    @Test
-    public void testDan() {
-
-        Graph graph = null;
-        IKnowledge knowledge = null;
-        DataSet data = null;
-        try {
-            File file1 = new File("/Users/user/Downloads/resimulationproblem/data.1.txt");
-            File file2 = new File("/Users/user/Downloads/resimulationproblem/graph.1.txt");
-            graph = GraphUtils.loadGraphTxt(file2);
-            File file = new File("/Users/user/Downloads/resimulationproblem/CVARknowledge.txt");
-            DataReader reader = new DataReader();
-            knowledge = reader.parseKnowledge(file);
-            data = reader.parseTabular(file1);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-
-        DataSet lagData = TimeSeriesUtils.createLagData(data,1);
-        for (Node v : graph.getNodes()) {
-            if (lagData.getVariable(v.getName()) == null) {
-                v.setNodeType(NodeType.LATENT);
-            }
-        }
-        IndTestDSep Test = new IndTestDSep(graph, false);
-
-        TsFci tsFci = new TsFci(Test);
-        tsFci.setKnowledge(knowledge);
-        Graph pag = tsFci.search();
-        System.out.println(graph);
-        System.out.println(knowledge);
-        System.out.println(pag);
-
-    }
 }
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestKnowledge.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestKnowledge.java
index 182ac940..02134255 100644
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestKnowledge.java
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestKnowledge.java
@@ -92,7 +92,7 @@ public final class TestKnowledge {
 
         assertTrue(knowledge.isForbidden("X1.1", "X2-1"));
         assertTrue(knowledge.isForbidden("X2-1", "X1.1"));
-//        assertFalse(knowledge.isForbidden("X1.1", "X1.1"));
+        assertFalse(knowledge.isForbidden("X1.1", "X1.1"));
 
         boolean found = false;
 
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestLinearityTest.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestLinearityTest.java
deleted file mode 100755
index b1fe44a3..00000000
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestLinearityTest.java
+++ /dev/null
@@ -1,460 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.test;
-
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.*;
-import edu.cmu.tetrad.regression.RegressionDataset;
-import edu.cmu.tetrad.regression.RegressionResult;
-import edu.cmu.tetrad.sem.*;
-import edu.cmu.tetrad.util.*;
-import edu.pitt.dbmi.data.Dataset;
-import edu.pitt.dbmi.data.Delimiter;
-import edu.pitt.dbmi.data.reader.tabular.ContinuousTabularDataFileReader;
-import org.junit.Test;
-
-import java.io.*;
-import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import static java.lang.Math.abs;
-import static java.util.Collections.*;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertTrue;
-
-
-/**
- * Tests the BTN linearity test.
- *
- * @author Joseph Ramsey jdramsey@andrew.cmu.edu
- */
-public final class TestLinearityTest {
-
-    public void test1() {
-
-        try {
-            double alpha = 1e-6;
-
-            final double bootstrapSampleSize = 100;
-            final int numBootstraps = 100;
-            final double sensitivity = .15;
-            final int N = 500;
-
-            File dir = new File("/Users/user/Box Sync/data/nonlinearity/simulations/joe.test");
-            dir.mkdirs();
-
-            final String linearFunction = "TSUM(NEW(B)*$)";
-            final String nonlinearFunction = "TSUM(NEW(B)*$^1.05)";
-            final String gaussianError = "Normal(0, .5)";
-            final String nonGaussianError = "Laplace(0, .378)";
-            final String parameters = "Split(-.5,-.2,.2,.5)";
-
-
-            PrintStream out = new PrintStream(new File(dir, "description.txt"));
-
-            out.println("Linear function " + linearFunction);
-            out.println("Nonlinear function " + nonlinearFunction);
-            out.println("Gaussian error " + gaussianError);
-            out.println("Non-Gaussian error " + nonGaussianError);
-            out.println("Parameters " + parameters);
-            out.println("Sample size " + N);
-            out.println("Percent in bootstrap = " + bootstrapSampleSize);
-            out.println("Num bootstraps = " + numBootstraps);
-            out.println("Sensitivity = " + sensitivity);
-
-            out.println();
-            out.close();
-
-            Graph graph = GraphUtils.randomGraph(100, 0, 100, 100, 100, 100, true);
-
-            GeneralizedSemPm pm1 = getPm(graph, linearFunction, gaussianError, parameters);
-            GeneralizedSemPm pm2 = getPm(graph, linearFunction, nonGaussianError, parameters);
-            GeneralizedSemPm pm3 = getPm(graph, nonlinearFunction, gaussianError, parameters);
-            GeneralizedSemPm pm4 = getPm(graph, nonlinearFunction, nonGaussianError, parameters);
-
-            GeneralizedSemIm im1 = new GeneralizedSemIm(pm1);
-            GeneralizedSemIm im2 = new GeneralizedSemIm(pm2);
-            GeneralizedSemIm im3 = new GeneralizedSemIm(pm3);
-            GeneralizedSemIm im4 = new GeneralizedSemIm(pm4);
-
-            DataSet D1 = im1.simulateData(N, false);
-            DataSet D2 = im2.simulateData(N, false);
-            DataSet D3 = im3.simulateData(N, false);
-            DataSet D4 = im4.simulateData(N, false);
-
-            D1 = DataUtils.center(D1);
-            D2 = DataUtils.center(D2);
-            D3 = DataUtils.center(D3);
-            D4 = DataUtils.center(D4);
-
-            // Save these dataset out so we can compare with the White test. The judgements should be that edges for
-            // D1 and D2 are nonlinear and edges for D3 and D4 are nonlinear.
-            // Make sure you save out the graph as well.
-
-            DataWriter.writeRectangularData(D1, new FileWriter(new File(dir, "D1.txt")), '\t');
-            DataWriter.writeRectangularData(D2, new FileWriter(new File(dir, "D2.txt")), '\t');
-            DataWriter.writeRectangularData(D3, new FileWriter(new File(dir, "D3.txt")), '\t');
-            DataWriter.writeRectangularData(D4, new FileWriter(new File(dir, "D4.txt")), '\t');
-
-            GraphUtils.saveGraph(graph, new File(dir, "graph.txt"), false);
-
-            List<Edge> edges = new ArrayList<Edge>(graph.getEdges());
-            sort(edges);
-            List<Node> variables = graph.getNodes();
-
-            PrintStream graphOut = new PrintStream(new FileOutputStream(new File(dir, "graph.indices.txt")));
-
-            for (int i = 0; i < edges.size(); i++) {
-                Edge edge = edges.get(i);
-
-                Node x = edge.getNode1();
-                Node y = edge.getNode2();
-
-                int j1 = variables.indexOf(x);
-                int j2 = variables.indexOf(y);
-
-                graphOut.println((j1 + 1) + "\t" + (j2 + 1));
-            }
-
-            out.close();
-
-            doTest(alpha, graph, D1, D2, D3, D4);
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    // To the same but loading datasets and graphs in from files.
-    public void test2() {
-        final double alpha = 1e-6;
-
-        try {
-            for (int i = 1; i <= 10; i++) {
-
-                File dir = new File("/Users/user/Box Sync/data/nonlinearity/simulations7/example" + i);
-
-                Graph graph = GraphUtils.loadGraphTxt(new File(dir, "graph.txt"));
-
-                DataSet D1 = readInContinuousData(dir, "D1.txt");
-                DataSet D2 = readInContinuousData(dir, "D2.txt");
-                DataSet D3 = readInContinuousData(dir, "D3.txt");
-                DataSet D4 = readInContinuousData(dir, "D4.txt");
-
-                System.out.print((i) + ".\t");
-
-                doTest(alpha, graph, D1, D2, D3, D4);
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-    }
-
-    public void test3() {
-
-        double alpha = 1e-6;
-
-        final double bootstrapSampleSize = 100;
-        final int numBootstraps = 100;
-        final int N = 1000;
-
-
-        String[] linearFunctions = new String[]{
-                "TSUM(NEW(B)*$)"
-        };
-
-        String[] nonlinearFunctions = new String[]{
-                "abs(TSUM(NEW(B) * $))",
-                "TSUM(NEW(B) * (abs($) ^ .8))",
-                "TSUM(NEW(B) * (abs($) ^ 1.05))",
-                "TSUM(NEW(B) * (abs($) ^ 1.5))",
-                "(TSUM(NEW(B)*$) + TSUM(NEW(B) * ($^2)))",
-                "TSUM(NEW(B) * ($ ^ 2))",
-                "TSUM(NEW(B) * ($ ^ 3))",
-                "TSUM(NEW(B) * ln(cosh($)))",
-                " tanh(NEW(B) * (TSUM($)))",
-                " (TSUM(sin(NEW(B) * $)) + TSUM(cos(NEW(B) * $)))"
-        };
-
-        String[] gaussianErrors = new String[]{
-                "Normal(0, 0.3)"
-        };
-
-        String[] nonGaussianErrors = new String[]{
-//                "0.5 * Uniform(-1, 1)",
-//                "(U(0, 1)^3 - .5)",
-                "0.1 * Laplace(0, 1)"
-        };
-
-        String parameters = "Split(-.5, -.2, .2, .5)";
-
-        int index = 1;
-
-        try {
-            for (String linearFunction : linearFunctions) {
-                for (String nonlinearFunction : nonlinearFunctions) {
-                    for (String gaussianError : gaussianErrors) {
-                        for (String nonGaussianError : nonGaussianErrors) {
-
-                            nonlinearFunction = "1 * " + nonlinearFunction;
-
-                            File dir = new File("/Users/user/Box Sync/data/nonlinearity/simulations7/example" + index++);
-                            dir.mkdirs();
-
-                            PrintStream out = new PrintStream(new File(dir, "description.txt"));
-
-                            out.println("Linear function " + linearFunction);
-                            out.println("Nonlinear function " + nonlinearFunction);
-                            out.println("Gaussian error " + gaussianError);
-                            out.println("Non-Gaussian error " + nonGaussianError);
-                            out.println("Parameters " + parameters);
-                            out.println("Sample size " + N);
-                            out.println("Percent in bootstrap = " + bootstrapSampleSize);
-                            out.println("Num bootstraps = " + numBootstraps);
-
-                            out.println();
-                            out.close();
-
-                            Graph graph = GraphUtils.randomGraph(100, 0, 100, 100, 100, 100, true);
-
-                            GeneralizedSemPm pm1 = getPm(graph, linearFunction, gaussianError, parameters);
-                            GeneralizedSemPm pm2 = getPm(graph, linearFunction, nonGaussianError, parameters);
-                            GeneralizedSemPm pm3 = getPm(graph, nonlinearFunction, gaussianError, parameters);
-                            GeneralizedSemPm pm4 = getPm(graph, nonlinearFunction, nonGaussianError, parameters);
-
-                            GeneralizedSemIm im1 = new GeneralizedSemIm(pm1);
-                            GeneralizedSemIm im2 = new GeneralizedSemIm(pm2);
-                            GeneralizedSemIm im3 = new GeneralizedSemIm(pm3);
-                            GeneralizedSemIm im4 = new GeneralizedSemIm(pm4);
-
-                            DataSet D1 = im1.simulateData(N, false);
-                            DataSet D2 = im2.simulateData(N, false);
-                            DataSet D3 = im3.simulateData(N, false);
-                            DataSet D4 = im4.simulateData(N, false);
-
-                            D1 = DataUtils.center(D1);
-                            D2 = DataUtils.center(D2);
-                            D3 = DataUtils.center(D3);
-                            D4 = DataUtils.center(D4);
-
-                            // Save these dataset out so we can compare with the White test. The judgements should be that edges for
-                            // D1 and D2 are nonlinear and edges for D3 and D4 are nonlinear.
-                            // Make sure you save out the graph as well.
-
-                            DataWriter.writeRectangularData(D1, new FileWriter(new File(dir, "D1.txt")), '\t');
-                            DataWriter.writeRectangularData(D2, new FileWriter(new File(dir, "D2.txt")), '\t');
-                            DataWriter.writeRectangularData(D3, new FileWriter(new File(dir, "D3.txt")), '\t');
-                            DataWriter.writeRectangularData(D4, new FileWriter(new File(dir, "D4.txt")), '\t');
-
-                            GraphUtils.saveGraph(graph, new File(dir, "graph.txt"), false);
-
-                            List<Edge> edges = new ArrayList<Edge>(graph.getEdges());
-                            sort(edges);
-                            List<Node> variables = graph.getNodes();
-
-                            PrintStream graphOut = new PrintStream(new FileOutputStream(new File(dir, "graph.indices.txt")));
-
-                            for (int i = 0; i < edges.size(); i++) {
-                                Edge edge = edges.get(i);
-
-                                Node x = edge.getNode1();
-                                Node y = edge.getNode2();
-
-                                int j1 = variables.indexOf(x);
-                                int j2 = variables.indexOf(y);
-
-                                graphOut.println((j1 + 1) + "\t" + (j2 + 1));
-                            }
-
-                            out.close();
-
-                            doTest(alpha, graph, D1, D2, D3, D4);
-                        }
-                    }
-                }
-            }
-
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void test5() {
-        String function = "TSUM($^3)";
-        String error = "U(-1, 1)";
-        final String parameters = "";
-        int N = 1000;
-
-        Node X = new GraphNode("X");
-        Node Y = new GraphNode("Y");
-        final ContinuousVariable R = new ContinuousVariable("R");
-
-        Graph graph = new EdgeListGraph();
-        graph.addNode(X);
-        graph.addNode(Y);
-        graph.addDirectedEdge(X, Y);
-
-        GeneralizedSemPm pm = getPm(graph, function, error, parameters);
-        GeneralizedSemIm im = new GeneralizedSemIm(pm);
-        DataSet dataSet = im.simulateData(N, false);
-
-        RegressionDataset regression = new RegressionDataset(dataSet);
-
-        RegressionResult result = regression.regress(dataSet.getVariable("Y"),
-                Collections.singletonList(dataSet.getVariable("X")));
-        double[] r = result.getResiduals().toArray();
-
-        int indexx = dataSet.getColumn(dataSet.getVariable("X"));
-        double[] x = dataSet.getDoubleData().transpose().toArray()[indexx];
-
-        System.out.println("var XR = " + StatUtils.covariance(x, r));
-    }
-
-    public static DataSet readInContinuousData(File dir, String s) throws IOException {
-        Dataset dataset1 = new ContinuousTabularDataFileReader(new File(dir, s), Delimiter.TAB).readInData();
-        return (DataSet) DataConvertUtils.toDataModel(dataset1);
-    }
-
-
-    private void doTest(double alpha, Graph graph,
-                        DataSet D1, DataSet D2, DataSet D3, DataSet D4) {
-        DataSet[] datasets = {D1, D2, D3, D4};
-
-        List<Node> variables = graph.getNodes();
-
-
-        double[][] variances = new double[D4.getNumColumns()][4];
-
-        for (int i = 0; i < datasets.length; i++) {
-            DataSet dataset = datasets[i];
-            if (dataset == null) continue;
-            double[][] data = dataset.getDoubleData().transpose().toArray();
-
-            for (int j = 0; j < dataset.getNumColumns(); j++) {
-                double var = StatUtils.variance(data[j]);
-                variances[j][i] = var;
-            }
-        }
-
-        List<Edge> edges = new ArrayList<Edge>(graph.getEdges());
-        sort(edges);
-
-        int[][] result = new int[edges.size()][4];
-        int[][] linear = new int[edges.size()][4];
-        int[][] dep = new int[edges.size()][4];
-
-        for (int d = 0; d < 4; d++) {
-            DataSet d2 = datasets[d];
-            if (d2 == null) continue;
-            double[][] data = d2.getDoubleData().transpose().toArray();
-
-            for (int i = 0; i < edges.size(); i++) {
-                Edge edge = edges.get(i);
-
-                Node y = edge.getNode2();
-                Node x = edge.getNode1();
-                int __y = variables.indexOf(y);
-                double[] _y = data[__y];
-
-                int __x = variables.indexOf(x);
-                double[] _x = data[__x];
-
-                final boolean _linear = DataUtils.linear4(_x, _y, alpha);
-                final boolean xydep = DataUtils.xydep(_x, _y);
-
-                result[i][d] = !_linear && xydep ? 1 : 0;
-                linear[i][d] = _linear ? 1 : 0;
-                dep[i][d] = xydep ? 1 : 0;
-            }
-        }
-
-        int[] sumsResult = new int[4];
-        int[] sumsLinear = new int[4];
-        int[] sumsDep = new int[4];
-
-        for (int d = 0; d < 4; d++) {
-            int sum = 0;
-
-            for (int i = 0; i < result.length; i++) {
-                sum += result[i][d];
-            }
-
-            sumsResult[d] = sum;
-
-            int sum2 = 0;
-
-            for (int i = 0; i < result.length; i++) {
-                sum2 += linear[i][d];
-            }
-
-            sumsLinear[d] = sum2;
-
-            int sum3 = 0;
-
-            for (int i = 0; i < result.length; i++) {
-                sum3 += dep[i][d];
-            }
-
-            sumsDep[d] = sum3;
-        }
-
-        System.out.println("# nonlinear = " + MatrixUtils.toString(sumsResult) + " || # linear = " + MatrixUtils.toString(sumsLinear)
-                + " || # dep = " + MatrixUtils.toString(sumsDep));
-    }
-
-    private GeneralizedSemPm getPm(Graph graph, String function, String error, String parameters) {
-        GeneralizedSemPm pm = new GeneralizedSemPm(graph);
-
-        List<Node> variablesNodes = pm.getVariableNodes();
-        List<Node> errorNodes = pm.getErrorNodes();
-
-        try {
-            for (Node node : variablesNodes) {
-                String _template = TemplateExpander.getInstance().expandTemplate(
-                        function, pm, node);
-                pm.setNodeExpression(node, _template);
-            }
-
-            for (Node node : errorNodes) {
-                String _template = TemplateExpander.getInstance().expandTemplate(error, pm, node);
-                pm.setNodeExpression(node, _template);
-            }
-
-            for (String p : pm.getParameters()) {
-                pm.setParameterExpression(p, parameters);
-            }
-        } catch (ParseException e) {
-            System.out.println(e);
-        }
-
-        return pm;
-    }
-
-    public static void main(String...args) {
-        new TestLinearityTest().test3();;
-    }
-}
-
-
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSLiCK.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSLiCK.java
deleted file mode 100755
index 30e54fbc..00000000
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSLiCK.java
+++ /dev/null
@@ -1,403 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.test;
-
-import edu.cmu.tetrad.data.DataSet;
-import edu.cmu.tetrad.data.DataUtils;
-import edu.cmu.tetrad.data.DataWriter;
-import edu.cmu.tetrad.graph.Edge;
-import edu.cmu.tetrad.graph.Graph;
-import edu.cmu.tetrad.graph.GraphUtils;
-import edu.cmu.tetrad.graph.Node;
-import edu.cmu.tetrad.sem.GeneralizedSemIm;
-import edu.cmu.tetrad.sem.GeneralizedSemPm;
-import edu.cmu.tetrad.sem.TemplateExpander;
-import edu.cmu.tetrad.util.DataConvertUtils;
-import edu.cmu.tetrad.util.MatrixUtils;
-import edu.cmu.tetrad.util.StatUtils;
-import edu.cmu.tetrad.util.TetradMatrix;
-import edu.pitt.dbmi.data.Dataset;
-import edu.pitt.dbmi.data.Delimiter;
-import edu.pitt.dbmi.data.reader.tabular.ContinuousTabularDataFileReader;
-import org.junit.Test;
-
-import java.io.*;
-import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-import static java.util.Collections.checkedCollection;
-import static java.util.Collections.sort;
-
-
-/**
- * Tests the SLiCK linearity test.
- *
- * Symmetric about the Linear Coefficient (Kolmogorov-Smirnov/Kuiper) test for linearity
- *
- * @author Bryan Andrews bja43@pitt.edu
- */
-public final class TestSLiCK {
-
-    public void test1() {
-
-        String[] linearFunctions = new String[]{
-                "TSUM(NEW(B)*$)"
-        };
-
-        String[] nonlinearFunctions = new String[]{
-                "abs(TSUM(NEW(B) * $))",
-                "TSUM(NEW(B) * (abs($) ^ .8))",
-                "TSUM(NEW(B) * (abs($) ^ 1.05))",
-                "TSUM(NEW(B) * (abs($) ^ 1.5))",
-                "(TSUM(NEW(B)*$) + TSUM(NEW(B) * ($^2)))",
-                "TSUM(NEW(B) * ($ ^ 2))",
-                "TSUM(NEW(B) * ($ ^ 3))",
-                "TSUM(NEW(B) * ln(cosh($)))",
-                " tanh(NEW(B) * (TSUM($)))",
-                " (TSUM(sin(NEW(B) * $)) + TSUM(cos(NEW(B) * $)))"
-        };
-
-        String[] gaussianErrors = new String[]{
-                "Normal(0, 0.3)"
-        };
-
-        String[] nonGaussianErrors = new String[]{
-                "0.5 * Uniform(-1, 1)",
-//                "(U(0, 1)^3 - .5)",
-//                "0.1 * Laplace(0, 1)"
-        };
-
-        String parameters = "Split(-.5, -.2, .2, .5)";
-
-        int index = 1;
-
-        try {
-            for (String linearFunction : linearFunctions) {
-                for (String nonlinearFunction : nonlinearFunctions) {
-                    for (String gaussianError : gaussianErrors) {
-                        for (String nonGaussianError : nonGaussianErrors) {
-                            final double quantile = 0.33;
-                            final double alpha = 0.01;
-                            final int N = 1000;
-
-                            File dir = new File("/Users/user/Box Sync/data/nonlinearity/simulations8/example" + index++);
-                            dir.mkdirs();
-
-                            PrintStream out = new PrintStream(new File(dir, "description.txt"));
-
-                            out.println("Linear function " + linearFunction);
-                            out.println("Nonlinear function " + nonlinearFunction);
-                            out.println("Gaussian error " + gaussianError);
-                            out.println("Non-Gaussian error " + nonGaussianError);
-                            out.println("Parameters " + parameters);
-                            out.println("Sample size " + N);
-                            out.println("Quantile = " + quantile);
-                            out.println("Alpha = " + alpha);
-
-                            out.println();
-                            out.close();
-
-                            Graph graph = GraphUtils.randomGraph(100, 0, 100, 100, 100, 100, true);
-
-                            GeneralizedSemPm pm1 = getPm(graph, linearFunction, gaussianError, parameters);
-                            GeneralizedSemPm pm2 = getPm(graph, linearFunction, nonGaussianError, parameters);
-                            GeneralizedSemPm pm3 = getPm(graph, nonlinearFunction, gaussianError, parameters);
-                            GeneralizedSemPm pm4 = getPm(graph, nonlinearFunction, nonGaussianError, parameters);
-
-                            GeneralizedSemIm im1 = new GeneralizedSemIm(pm1);
-                            GeneralizedSemIm im2 = new GeneralizedSemIm(pm2);
-                            GeneralizedSemIm im3 = new GeneralizedSemIm(pm3);
-                            GeneralizedSemIm im4 = new GeneralizedSemIm(pm4);
-
-                            DataSet D1 = im1.simulateData(N, false);
-                            DataSet D2 = im2.simulateData(N, false);
-                            DataSet D3 = im3.simulateData(N, false);
-                            DataSet D4 = im4.simulateData(N, false);
-
-                            D1 = DataUtils.center(D1);
-                            D2 = DataUtils.center(D2);
-                            D3 = DataUtils.center(D3);
-                            D4 = DataUtils.center(D4);
-
-                            // Save these dataset out so we can compare with the White test. The judgements should be that edges for
-                            // D1 and D2 are nonlinear and edges for D3 and D4 are nonlinear.
-                            // Make sure you save out the graph as well.
-
-                            DataWriter.writeRectangularData(D1, new FileWriter(new File(dir, "D1.txt")), '\t');
-                            DataWriter.writeRectangularData(D2, new FileWriter(new File(dir, "D2.txt")), '\t');
-                            DataWriter.writeRectangularData(D3, new FileWriter(new File(dir, "D3.txt")), '\t');
-                            DataWriter.writeRectangularData(D4, new FileWriter(new File(dir, "D4.txt")), '\t');
-
-                            GraphUtils.saveGraph(graph, new File(dir, "graph.txt"), false);
-
-                            List<Edge> edges = new ArrayList<Edge>(graph.getEdges());
-                            sort(edges);
-                            List<Node> variables = graph.getNodes();
-
-                            PrintStream graphOut = new PrintStream(new FileOutputStream(new File(dir, "graph.indices.txt")));
-
-                            for (int i = 0; i < edges.size(); i++) {
-                                Edge edge = edges.get(i);
-
-                                Node x = edge.getNode1();
-                                Node y = edge.getNode2();
-
-                                int j1 = variables.indexOf(x);
-                                int j2 = variables.indexOf(y);
-
-                                graphOut.println((j1 + 1) + "\t" + (j2 + 1));
-                            }
-
-                            out.close();
-
-                            doTest(quantile, alpha, graph, D1, D2, D3, D4, true);
-                        }
-                    }
-                }
-            }
-
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-
-    // To the same but loading datasets and graphs in from files.
-    public void test2() {
-        final double quantile = 0.33;
-        final double alpha = 0.01;
-        boolean singleEdge = true;
-
-        try {
-            for (int i = 1; i <= 21; i++) {
-
-                File dir = new File("/Users/user/Box Sync/data/nonlinearity/simulations3/example" + i);
-
-                Graph graph = GraphUtils.loadGraphTxt(new File(dir, "graph.txt"));
-
-                DataSet D1 = readInContinuousData(dir, "D1.txt");
-                DataSet D2 = readInContinuousData(dir, "D2.txt");
-                DataSet D3 = readInContinuousData(dir, "D3.txt");
-                DataSet D4 = readInContinuousData(dir, "D4.txt");
-
-                System.out.print((i) + ".\t");
-
-                doTest(quantile, alpha, graph, D1, D2, D3, D4, singleEdge);
-            }
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-
-    }
-
-
-    public static DataSet readInContinuousData(File dir, String s) throws IOException {
-        Dataset dataset1 = new ContinuousTabularDataFileReader(new File(dir, s), Delimiter.TAB).readInData();
-        return (DataSet) DataConvertUtils.toDataModel(dataset1);
-    }
-
-
-    private boolean KStest(ArrayList<Double> x0, ArrayList<Double> x1, double alpha) {
-        Collections.sort(x0);
-        Collections.sort(x1);
-
-        int n0 = x0.size();
-        int n1 = x1.size();
-
-        double step0 = 1.0/n0;
-        double step1 = 1.0/n1;
-
-        double cdf0 = 0;
-        double cdf1 = 0;
-
-        int i0 = -1;
-        int i1 = -1;
-
-        double x;
-        double KSstat = 0;
-        // For Kuiper's statistic
-        double k0 = 0;
-        double k1 = 0;
-
-        while(1-cdf0 >= step0/2 && 1-cdf1 >= step1/2) {
-            if(x0.get(i0+1) <= x1.get(i1+1)) {
-                i0 ++;
-                x = x0.get(i0);
-            } else {
-                i1++;
-                x = x1.get(i1);
-            }
-            if(i0 != -1 && x0.get(i0) == x) {
-                cdf0 += step0;
-            } else {
-                cdf1 += step1;
-            }
-            KSstat = Math.max(KSstat, Math.abs(cdf0-cdf1));
-            k0 = Math.max(k0, cdf0-cdf1);
-            k1 = Math.max(k1, cdf1-cdf0);
-        }
-
-        double c = Math.sqrt(-0.5 * Math.log(alpha/2));
-//        return KSstat > c * Math.sqrt((double)(n0+n1)/(n0*n1));
-        return (k0 + k1) > c * Math.sqrt((double)(n0+n1)/(n0*n1));
-    }
-
-
-    private boolean SLiCK(double[] _x, double[] _y, double quantile, double alpha) {
-        TetradMatrix X = new TetradMatrix(_x.length, 2);
-        TetradMatrix y = new TetradMatrix(_y.length, 1);
-
-        for(int i = 0; i < _x.length; i++) {
-            X.set(i, 0, 1);
-            X.set(i, 1, _x[i]);
-            y.set(i, 0, _y[i]);
-        }
-
-        TetradMatrix r = y.minus(X.times(((X.transpose().times(X)).inverse()).times(X.transpose().times(y))));
-
-        ArrayList<Double> x0 = new ArrayList<>();
-        ArrayList<Double> x1 = new ArrayList<>();
-
-        ArrayList<Double> sorted = new ArrayList();
-        for(int i = 0; i < r.rows(); i++) {
-            sorted.add(r.get(i,0));
-        }
-        Collections.sort(sorted);
-
-        int t = (int) (Math.min(0.5, quantile) * r.rows());
-        double t0 = sorted.get(r.rows()-t);
-        double t1 = sorted.get(t);
-
-        for(int i = 0; i < r.rows(); i++) {
-            if(r.get(i,0) >= t0){
-                x0.add(X.get(i, 1));
-            } else if(r.get(i,0) <= t1){
-                x1.add(X.get(i, 1));
-            }
-        }
-
-        return KStest(x0, x1, alpha);
-    }
-
-
-    private void doTest(double quantile, double alpha, Graph graph, DataSet D1, DataSet D2, DataSet D3, DataSet D4, boolean singleEdge) {
-        DataSet[] datasets = {D1, D2, D3, D4};
-
-        List<Node> variables = graph.getNodes();
-
-        List<Edge> edges = new ArrayList<Edge>(graph.getEdges());
-        sort(edges);
-
-        int[][] result = new int[edges.size()][4];
-
-        for (int d = 0; d < 4; d++) {
-            DataSet d2 = datasets[d];
-            double[][] data = d2.getDoubleData().transpose().toArray();
-
-            for (int i = 0; i < edges.size(); i++) {
-                Edge edge = edges.get(i);
-
-                Node z = edge.getNode2();
-                Node x = edge.getNode1();
-                int __z = variables.indexOf(z);
-                double[] _z = data[__z];
-
-                List<Node> parents = graph.getParents(z);
-
-                int __x = variables.indexOf(x);
-                double[] _x = data[__x];
-
-                List<Node> otherParents;
-
-                if (singleEdge) {
-                    otherParents = new ArrayList<>();
-                } else {
-                    otherParents = new ArrayList<>(parents);
-                    otherParents.remove(x);
-                }
-
-                double[][] _otherParents = new double[otherParents.size()][];
-
-                for (int j = 0; j < otherParents.size(); j++) {
-                    int __o = variables.indexOf(otherParents.get(j));
-                    double[] _o = data[__o];
-                    _otherParents[j] = _o;
-                }
-
-                final boolean linear = SLiCK(_x, _z, quantile, alpha);
-
-                result[i][d] = linear ? 1 : 0;
-            }
-        }
-
-        int[] sums = new int[4];
-
-        for (int d = 0; d < 4; d++) {
-            int sum = 0;
-
-            for (int i = 0; i < result.length; i++) {
-                sum += result[i][d];
-            }
-
-            sums[d] = sum;
-        }
-
-        System.out.println(MatrixUtils.toString(sums));
-    }
-
-
-    private GeneralizedSemPm getPm(Graph graph, String function, String error, String parameters) {
-        GeneralizedSemPm pm = new GeneralizedSemPm(graph);
-
-        List<Node> variablesNodes = pm.getVariableNodes();
-        List<Node> errorNodes = pm.getErrorNodes();
-
-        try {
-            for (Node node : variablesNodes) {
-                String _template = TemplateExpander.getInstance().expandTemplate(
-                        function, pm, node);
-                pm.setNodeExpression(node, _template);
-            }
-
-            for (Node node : errorNodes) {
-                String _template = TemplateExpander.getInstance().expandTemplate(error, pm, node);
-                pm.setNodeExpression(node, _template);
-            }
-
-            for (String p : pm.getParameters()) {
-                pm.setParameterExpression(p, parameters);
-            }
-        } catch (ParseException e) {
-            System.out.println(e);
-        }
-
-        return pm;
-    }
-
-    public static void main(String...args) {
-        new TestSLiCK().test1();
-    }
-}
-
-
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmr3.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmr3.java
index fae9c975..a866b44f 100644
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmr3.java
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmr3.java
@@ -24,7 +24,6 @@ package edu.cmu.tetrad.test;
 import edu.cmu.tetrad.algcomparison.Comparison;
 import edu.cmu.tetrad.algcomparison.algorithm.Algorithms;
 import edu.cmu.tetrad.algcomparison.algorithm.multi.*;
-import edu.cmu.tetrad.algcomparison.score.SemBicScore;
 import edu.cmu.tetrad.algcomparison.simulation.Simulations;
 import edu.cmu.tetrad.algcomparison.statistic.*;
 import edu.cmu.tetrad.util.Parameters;
@@ -130,7 +129,7 @@ public class TestSimulatedFmr3 {
 
         Algorithms algorithms = new Algorithms();
 
-        algorithms.add(new Fask(new SemBicScore()));
+        algorithms.add(new Fask());
 
         Comparison comparison = new Comparison();
 
@@ -217,7 +216,7 @@ public class TestSimulatedFmr3 {
 
             Algorithms algorithms = new Algorithms();
 
-            algorithms.add(new FaskConcatenated(new SemBicScore()));
+            algorithms.add(new FaskConcatenated());
 
             Comparison comparison = new Comparison();
 
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmri.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmri.java
index bcf914b5..ab295af0 100644
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmri.java
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmri.java
@@ -51,12 +51,14 @@ public class TestSimulatedFmri {
 
     private void task(boolean testing) {
         Parameters parameters = new Parameters();
-        parameters.set("penaltyDiscount", 2);
+        parameters.set("penaltyDiscount", 4);
         parameters.set("depth", -1);
-        parameters.set("twoCycleAlpha", 1e-6);
-        parameters.set("faskDelta", -0.2);
+        parameters.set("twoCycleAlpha", 1e-10);
+        parameters.set("faskDelta", -.2);
+        parameters.set("reverseOrientationsBySignOfCorrelation", false);
+        parameters.set("reverseOrientationsBySkewnessOfVariables", false);
 
-        parameters.set("numRuns", 60);
+        parameters.set("numRuns", 10);
         parameters.set("randomSelectionSize", 10);
 
         parameters.set("Structure", "Placeholder");
@@ -202,7 +204,7 @@ public class TestSimulatedFmri {
         comparison.compareFromSimulations(directory, simulations, algorithms, statistics, parameters);
     }
 
-//    @Test
+    //    @Test
     public void task2() {
         Parameters parameters = new Parameters();
         parameters.set("penaltyDiscount", 1);
@@ -355,6 +357,149 @@ public class TestSimulatedFmri {
         comparison.compareFromSimulations("comparison", simulations, algorithms, statistics, parameters);
     }
 
+//    @Test
+    public void testClark() {
+
+        double f = .1;
+        int N = 512;
+        double alpha = 1.0;
+        double penaltyDiscount = 1.0;
+
+        for (int i = 0; i < 100; i++) {
+            {
+                Node x = new ContinuousVariable("X");
+                Node y = new ContinuousVariable("Y");
+                Node z = new ContinuousVariable("Z");
+
+                Graph g = new EdgeListGraph();
+                g.addNode(x);
+                g.addNode(y);
+                g.addNode(z);
+
+                g.addDirectedEdge(x, y);
+                g.addDirectedEdge(z, x);
+                g.addDirectedEdge(z, y);
+
+                GeneralizedSemPm pm = new GeneralizedSemPm(g);
+
+                try {
+                    pm.setNodeExpression(g.getNode("X"), "0.5 * Z + E_X");
+                    pm.setNodeExpression(g.getNode("Y"), "0.5 * X + 0.5 * Z + E_Y");
+                    pm.setNodeExpression(g.getNode("Z"), "E_Z");
+
+                    String error = "pow(Uniform(0, 1), " + f + ")";
+                    pm.setNodeExpression(pm.getErrorNode(g.getNode("X")), error);
+                    pm.setNodeExpression(pm.getErrorNode(g.getNode("Y")), error);
+                    pm.setNodeExpression(pm.getErrorNode(g.getNode("Z")), error);
+                } catch (ParseException e) {
+                    System.out.println(e);
+                }
+
+                GeneralizedSemIm im = new GeneralizedSemIm(pm);
+                DataSet data = im.simulateData(N, false);
+
+                edu.cmu.tetrad.search.SemBicScore score = new edu.cmu.tetrad.search.SemBicScore(new CovarianceMatrixOnTheFly(data, false));
+                score.setPenaltyDiscount(penaltyDiscount);
+
+                Fask fask = new Fask(data, score);
+                fask.setPenaltyDiscount(penaltyDiscount);
+                fask.setAlpha(alpha);
+                Graph out = fask.search();
+
+                System.out.println(out);
+            }
+
+            {
+                Node x = new ContinuousVariable("X");
+                Node y = new ContinuousVariable("Y");
+                Node z = new ContinuousVariable("Z");
+
+                Graph g = new EdgeListGraph();
+                g.addNode(x);
+                g.addNode(y);
+                g.addNode(z);
+
+                g.addDirectedEdge(x, y);
+                g.addDirectedEdge(x, z);
+                g.addDirectedEdge(y, z);
+
+                GeneralizedSemPm pm = new GeneralizedSemPm(g);
+
+                try {
+                    pm.setNodeExpression(g.getNode("X"), "E_X");
+                    pm.setNodeExpression(g.getNode("Y"), "0.4 * X + E_Y");
+                    pm.setNodeExpression(g.getNode("Z"), "0.4 * X + 0.4 * Y + E_Z");
+
+                    String error = "pow(Uniform(0, 1), " + f + ")";
+                    pm.setNodeExpression(pm.getErrorNode(g.getNode("X")), error);
+                    pm.setNodeExpression(pm.getErrorNode(g.getNode("Y")), error);
+                    pm.setNodeExpression(pm.getErrorNode(g.getNode("Z")), error);
+                } catch (ParseException e) {
+                    System.out.println(e);
+                }
+
+                GeneralizedSemIm im = new GeneralizedSemIm(pm);
+                DataSet data = im.simulateData(N, false);
+
+                edu.cmu.tetrad.search.SemBicScore score = new edu.cmu.tetrad.search.SemBicScore(new CovarianceMatrixOnTheFly(data, false));
+                score.setPenaltyDiscount(penaltyDiscount);
+
+                Fask fask = new Fask(data, score);
+                fask.setPenaltyDiscount(penaltyDiscount);
+                fask.setAlpha(alpha);
+                Graph out = fask.search();
+
+                System.out.println(out);
+
+            }
+        }
+    }
+
+
+//    @Test
+    public void testClark2() {
+
+        Node x = new ContinuousVariable("X");
+        Node y = new ContinuousVariable("Y");
+        Node z = new ContinuousVariable("Z");
+
+        Graph g = new EdgeListGraph();
+        g.addNode(x);
+        g.addNode(y);
+        g.addNode(z);
+
+        g.addDirectedEdge(x, y);
+        g.addDirectedEdge(x, z);
+        g.addDirectedEdge(y, z);
+
+        GeneralizedSemPm pm = new GeneralizedSemPm(g);
+
+        try {
+            pm.setNodeExpression(g.getNode("X"), "E_X");
+            pm.setNodeExpression(g.getNode("Y"), "0.4 * X + E_Y");
+            pm.setNodeExpression(g.getNode("Z"), "0.4 * X + 0.4 * Y + E_Z");
+
+            String error = "pow(Uniform(0, 1), 1.5)";
+            pm.setNodeExpression(pm.getErrorNode(g.getNode("X")), error);
+            pm.setNodeExpression(pm.getErrorNode(g.getNode("Y")), error);
+            pm.setNodeExpression(pm.getErrorNode(g.getNode("Z")), error);
+        } catch (ParseException e) {
+            System.out.println(e);
+        }
+
+
+        GeneralizedSemIm im = new GeneralizedSemIm(pm);
+        DataSet data = im.simulateData(1000, false);
+
+        edu.cmu.tetrad.search.SemBicScore score = new edu.cmu.tetrad.search.SemBicScore(new CovarianceMatrixOnTheFly(data, false));
+
+        Fask fask = new Fask(data, score);
+        fask.setPenaltyDiscount(1);
+        fask.setAlpha(0.5);
+        Graph out = fask.search();
+
+        System.out.println(out);
+    }
 
     public static void main(String... args) {
         new TestSimulatedFmri().task(false);
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmri2.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmri2.java
index 7b32117f..951752a5 100644
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmri2.java
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestSimulatedFmri2.java
@@ -37,10 +37,10 @@ public class TestSimulatedFmri2 {
 
     public void TestCycles_Data_fMRI_FASK() {
         Parameters parameters = new Parameters();
-        parameters.set("penaltyDiscount", 2);
+        parameters.set("penaltyDiscount", 8);
         parameters.set("depth", -1);
         parameters.set("faskDelta", -0.2);
-        parameters.set("twoCycleAlpha", 1e-6);
+        parameters.set("twoCycleAlpha", 1e-15);
 
         parameters.set("numRuns", 60);
 //        parameters.set("randomSelectionSize", 1);
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestTetradCmd.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestTetradCmd.java
new file mode 100644
index 00000000..82a67db9
--- /dev/null
+++ b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestTetradCmd.java
@@ -0,0 +1,80 @@
+///////////////////////////////////////////////////////////////////////////////
+// For information as to what this class does, see the Javadoc, below.       //
+// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
+// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
+// Ramsey, and Clark Glymour.                                                //
+//                                                                           //
+// This program is free software; you can redistribute it and/or modify      //
+// it under the terms of the GNU General Public License as published by      //
+// the Free Software Foundation; either version 2 of the License, or         //
+// (at your option) any later version.                                       //
+//                                                                           //
+// This program is distributed in the hope that it will be useful,           //
+// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
+// GNU General Public License for more details.                              //
+//                                                                           //
+// You should have received a copy of the GNU General Public License         //
+// along with this program; if not, write to the Free Software               //
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
+///////////////////////////////////////////////////////////////////////////////
+
+package edu.cmu.tetrad.test;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+// This just has to run, no checking. jdramsey 12/16/2015
+public class TestTetradCmd extends TestCase {
+    public TestTetradCmd(String name) {
+        super(name);
+    }
+
+    public void test1() {
+        new edu.cmu.tetrad.cmd.TetradCmd(new String[] {"-data", "src/test/resources/avatarwithdependencies.esv",
+                "-datatype", "discrete", "-algorithm", "pc", "-depth", "3",
+                "-significance", "0.001", "-knowledge", "src/test/resources/avatarknowledge.txt", "-silent"});
+
+
+    }
+
+
+    public void test2() {
+        new edu.cmu.tetrad.cmd.TetradCmd(new String[] {"-data", "src/test/resources/avatarwithdependencies.esv",
+                     "-datatype", "discrete", "-algorithm", "cpc", "-depth", "3",
+                     "-significance", "0.001", "-knowledge", "src/test/resources/avatarknowledge.txt", "-silent"});
+
+
+    }
+
+    public void test3() {
+        new edu.cmu.tetrad.cmd.TetradCmd(new String[] {"-data", "src/test/resources/eigenvox2.txt",
+                     "-datatype", "continuous", "-algorithm", "cpc", "-depth", "3",
+                     "-significance", "0.001", "-whitespace", "-silent"});
+
+
+    }
+
+    public void test4() {
+        new edu.cmu.tetrad.cmd.TetradCmd(new String[] {"-covariance", "src/test/resources/lead.modified.txt",
+                "-algorithm", "cpc", "-depth", "3",
+                "-significance", "0.001", "-whitespace", "-silent"});
+
+
+    }
+
+    public void test5() {
+        new edu.cmu.tetrad.cmd.TetradCmd(new String[] {"-data", "src/test/resources/eigenvox2.txt",
+                "-datatype", "continuous", "-algorithm", "fges", "-penaltydiscount", "3",
+                "-whitespace", "-silent"});
+
+
+    }
+
+    public static Test suite() {
+        return new TestSuite(TestTetradCmd.class);
+    }
+}
+
+
diff --git a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestVxx.java b/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestVxx.java
deleted file mode 100644
index aa82c210..00000000
--- a/tetrad-lib/src/test/java/edu/cmu/tetrad/test/TestVxx.java
+++ /dev/null
@@ -1,266 +0,0 @@
-///////////////////////////////////////////////////////////////////////////////
-// For information as to what this class does, see the Javadoc, below.       //
-// Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,       //
-// 2007, 2008, 2009, 2010, 2014, 2015 by Peter Spirtes, Richard Scheines, Joseph   //
-// Ramsey, and Clark Glymour.                                                //
-//                                                                           //
-// This program is free software; you can redistribute it and/or modify      //
-// it under the terms of the GNU General Public License as published by      //
-// the Free Software Foundation; either version 2 of the License, or         //
-// (at your option) any later version.                                       //
-//                                                                           //
-// This program is distributed in the hope that it will be useful,           //
-// but WITHOUT ANY WARRANTY; without even the implied warranty of            //
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             //
-// GNU General Public License for more details.                              //
-//                                                                           //
-// You should have received a copy of the GNU General Public License         //
-// along with this program; if not, write to the Free Software               //
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA //
-///////////////////////////////////////////////////////////////////////////////
-
-package edu.cmu.tetrad.test;
-
-import edu.cmu.tetrad.data.*;
-import edu.cmu.tetrad.graph.*;
-import edu.cmu.tetrad.search.Fask;
-import edu.cmu.tetrad.search.SearchGraphUtils;
-import edu.cmu.tetrad.sem.GeneralizedSemIm;
-import edu.cmu.tetrad.sem.GeneralizedSemPm;
-import edu.cmu.tetrad.util.StatUtils;
-import edu.pitt.dbmi.data.ContinuousTabularDataset;
-import edu.pitt.dbmi.data.Delimiter;
-import edu.pitt.dbmi.data.reader.DataReader;
-import edu.pitt.dbmi.data.reader.tabular.ContinuousTabularDataFileReader;
-import org.junit.Test;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintStream;
-import java.text.DecimalFormat;
-import java.text.NumberFormat;
-import java.text.ParseException;
-import java.util.*;
-
-import static java.lang.Math.abs;
-
-/**
- * My script.
- *
- * @author jdramsey
- */
-public class TestVxx {
-
-    @Test
-    public void TestCycles_Data_fMRI_FASK() {
-
-        int num = 100;
-        double[] e1 = new double[num];
-        double[] e2 = new double[num];
-        double[] e3 = new double[num];
-        double[] e4 = new double[num];
-        double[] e5 = new double[num];
-
-        for (int i = 0; i < num; i++) {
-            Node x = new GraphNode("X");
-            Node y = new GraphNode("Y");
-            Node z = new GraphNode("Z");
-
-            EdgeListGraph graph = new EdgeListGraph();
-            graph.addNode(x);
-            graph.addNode(y);
-            graph.addNode(z);
-
-            graph.addDirectedEdge(x, y);
-            graph.addDirectedEdge(z, x);
-            graph.addDirectedEdge(z, y);
-
-            GeneralizedSemPm pm = new GeneralizedSemPm(graph);
-
-            List<Node> errorNodes = pm.getErrorNodes();
-
-            try {
-                for (Node node : errorNodes) {
-                    pm.setNodeExpression(node, "Beta(1, 5)");
-                }
-
-                pm.setParameterExpression("B", "Split(-.9,-.1,.1, .9)");
-            } catch (ParseException e) {
-                System.out.println(e);
-            }
-
-            GeneralizedSemIm im = new GeneralizedSemIm(pm);
-
-            DataSet dataSet = im.simulateData(1000, false);
-
-            Node dX = dataSet.getVariable("X");
-            Node dY = dataSet.getVariable("Y");
-            Node dZ = dataSet.getVariable("Z");
-            List<Node> dVars = dataSet.getVariables();
-
-            int iX = dVars.indexOf(dX);
-            int iY = dVars.indexOf(dY);
-            int iZ = dVars.indexOf(dZ);
-
-            double[][] dd = dataSet.getDoubleData().transpose().toArray();
-
-            double vzy = cu(dd[iZ], dd[iZ], dd[iY]);
-            double vxy = cu(dd[iX], dd[iX], dd[iY]);
-            double vzx = cu(dd[iZ], dd[iZ], dd[iX]);
-            double vxx = cu(dd[iX], dd[iX], dd[iX]);
-            double vxzy = cu(dd[iX], dd[iZ], dd[iY]);
-            double vxzx = cu(dd[iX], dd[iZ], dd[iX]);
-
-            System.out.println("\nvzx = " + vxx + " vxx = " + vxx + " vzy = " + vzy + " vxy = " + vxy);
-
-            System.out.println(" vzy / vxy = " + (vzy / vxy) + " vzx / vxx = " + (vzx / vxx));
-
-            e1[i] = vzy / vxy;
-            e2[i] = vzx / vxx;
-            e4[i] = vzx;
-            e5[i] = vzy;
-            e3[i] = e4[i] - e5[i];
-        }
-
-        System.out.println();
-
-        System.out.println("mean vzx = " + StatUtils.mean(e4));
-        System.out.println("variance vzx = " + StatUtils.variance(e4));
-        System.out.println("mean vzy = " + StatUtils.mean(e5));
-        System.out.println("variance vzy = " + StatUtils.variance(e5));
-
-//        System.out.println("mean vzy / vxy = " + StatUtils.mean(e1));
-//        System.out.println("variance vzy / vxy = " + StatUtils.variance(e1));
-//        System.out.println("mean vzx / vxx = " + StatUtils.mean(e2));
-//        System.out.println("variance vzx / vxx = " + StatUtils.variance(e2));
-//
-        System.out.println("mean diff = " + StatUtils.mean(e3));
-        System.out.println("variance diff = " + StatUtils.variance(e3));
-    }
-
-    public static double cu(double[] x, double[] y, double[] condition) {
-        double exy = 0.0;
-
-        int n = 0;
-
-        for (int k = 0; k < x.length; k++) {
-            if (condition[k] > 0) {
-                exy += x[k] * y[k];
-                n++;
-            }
-        }
-
-        return exy / n;
-    }
-
-    @Test
-    public void testRubenLoop() {
-        try {
-
-            double sumAdjPrec = 0.0;
-            double sumAdjRec = 0.0;
-            double sumAhdPrec = 0.0;
-            double sumAhdRec = 0.0;
-
-            List<DataSet> dataSets = new ArrayList<>();
-
-            for (int i = 1; i <= 60; i++) {
-
-
-                String dir = "/Users/user/Downloads/allpositive 2/";
-                File file = new File(dir, "network_E_coeff" + i + "_allpos.txt");
-
-                NumberFormat nf = new DecimalFormat("00");
-
-//                String dir = "/Users/user/Downloads/allpositive_concat/";
-//                File file = new File(dir, "concat_" + nf.format(i) + ".txt");
-
-                DataReader reader = new ContinuousTabularDataFileReader(file, Delimiter.TAB);
-
-                ContinuousTabularDataset data = (ContinuousTabularDataset) reader.readInData();
-
-                List<Node> variables = new ArrayList<>();
-
-                for (String var : data.getVariables()) {
-                    variables.add(new ContinuousVariable(var));
-                }
-
-                dataSets.add(new BoxDataSet(new DoubleDataBox(data.getData()), variables));
-            }
-
-            int count = 60;
-
-            for (int i = 1; i <= count; i++) {
-                Collections.shuffle(dataSets);
-
-                List<DataSet> toConcatenate = new ArrayList<>();
-
-                for (int j = 0; j < 10; j++) {
-                    toConcatenate.add(DataUtils.standardizeData(dataSets.get(j)));
-                }
-
-                DataSet dataSet = DataUtils.concatenate(toConcatenate);
-
-//                File f = new File("/Users/user/Downloads/stddata.txt");
-//
-//                PrintStream out = new PrintStream(f);
-//
-//                out.println(dataSet);
-//                out.close();
-
-//                dataSet = DataUtils.standardizeData(dataSet);
-
-                edu.cmu.tetrad.search.SemBicScore score = new edu.cmu.tetrad.search.SemBicScore(new CovarianceMatrixOnTheFly(dataSet));
-                score.setPenaltyDiscount(1);
-
-                Fask fask = new Fask(dataSet, score);
-                fask.setAlpha(1e-10);
-                fask.setPenaltyDiscount(2);
-//                fask.setPresumePositiveCoefficients(true);
-
-                Graph G = fask.search();
-
-                System.out.println(G);
-
-                Graph dag = new EdgeListGraph(dataSet.getVariables());
-                Node X = dag.getNode("X");
-                Node Y = dag.getNode("Y");
-                Node Z = dag.getNode("Z");
-
-                dag.addDirectedEdge(Z, X);
-                dag.addDirectedEdge(X, Y);
-                dag.addDirectedEdge(Y, Z);
-
-                GraphUtils.GraphComparison comparison = SearchGraphUtils.getGraphComparison3(G, dag);
-
-                System.out.println(comparison.getAdjPrec() + " " +
-                        comparison.getAdjRec() + " " +
-                        comparison.getAhdPrec() + " " +
-                        comparison.getAhdRec() + " ");
-
-                sumAdjPrec += comparison.getAdjPrec();
-                sumAdjRec += comparison.getAdjRec();
-                sumAhdPrec += comparison.getAhdPrec();
-                sumAhdRec += comparison.getAhdRec();
-            }
-
-            System.out.println("\nAverages:\n");
-
-            System.out.println("AdjPred = " + (sumAdjPrec / count));
-            System.out.println("AdjRec = " + (sumAdjRec / count));
-            System.out.println("AhdPred = " + (sumAhdPrec / count));
-            System.out.println("AhdRec = " + (sumAhdRec / count));
-        } catch (IOException e) {
-            e.printStackTrace();
-        }
-    }
-
-
-    public static void main(String... args) {
-        new TestVxx().TestCycles_Data_fMRI_FASK();
-    }
-}
-
-
-
-
